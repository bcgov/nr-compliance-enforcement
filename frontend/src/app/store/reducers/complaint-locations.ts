import { createSlice } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../store";
import config from "../../../config";
import { AllegationComplaint } from "../../types/complaints/allegation-complaint";
import { HwcrComplaint } from "../../types/complaints/hwcr-complaint";
import COMPLAINT_TYPES from "../../types/app/complaint-types";
import { ComplaintFilters } from "../../types/complaints/complaint-filters";
import { toggleLoading } from "./app";
import { generateApiParameters, get } from "../../common/api";
import { ComplaintQueryParams } from "../../types/api-params/complaint-query-params";
import { Coordinates } from "../../types/app/coordinate-type";
import { from } from "linq-to-typescript";
import { ComplaintLocationsCollection, ComplaintLocationsState } from "../../types/state/complaint-location-state";

const initialState: ComplaintLocationsState = {

  complaintItemsOnMap: {
    wildlife: [],
    allegations: [],
  },
};

export const complaintLocationsSlice = createSlice({
  name: "complaintLocations",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setComplaintsOnMap: (state, action) => {
      const {
        payload: { type, data },
      } = action;
      const { complaintItemsOnMap } = state;

      let update: ComplaintLocationsCollection = { wildlife: [], allegations: [] };

      switch (type) {
        case COMPLAINT_TYPES.ERS:
          update = { ...complaintItemsOnMap, allegations: data };
          break;
        case COMPLAINT_TYPES.HWCR:
          update = { ...complaintItemsOnMap, wildlife: data };
          break;
      }

      return { ...state, complaintItemsOnMap: update };
    },

  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {},
});

// export the actions/reducers
export const {
  setComplaintsOnMap,
} = complaintLocationsSlice.actions;

export const getComplaintsOnMap =
  (complaintType: string, payload: ComplaintFilters): AppThunk =>
  async (dispatch) => {
    const {
      sortColumn,
      sortOrder,
      regionCodeFilter,
      areaCodeFilter,
      zoneCodeFilter,
      officerFilter,
      natureOfComplaintFilter,
      speciesCodeFilter,
      startDateFilter,
      endDateFilter,
      violationFilter,
      complaintStatusFilter,
    } = payload;
    try {
      dispatch(toggleLoading(true));
      const apiEndpoint = (type: string): string => {
        switch (type) {
          case COMPLAINT_TYPES.ERS:
            return "allegation-complaint";
          default:
            return "hwcr-complaint";
        }
      };

      const parameters = generateApiParameters(
        `${config.API_BASE_URL}/v1/${apiEndpoint(complaintType)}/map/search`,
        {
          sortColumn: sortColumn,
          sortOrder: sortOrder,
          region: regionCodeFilter?.value,
          zone: zoneCodeFilter?.value,
          community: areaCodeFilter?.value,
          officerAssigned: officerFilter?.value,
          natureOfComplaint: natureOfComplaintFilter?.value,
          speciesCode: speciesCodeFilter?.value,
          incidentReportedStart: startDateFilter,
          incidentReportedEnd: endDateFilter,
          violationCode: violationFilter?.value,
          status: complaintStatusFilter?.value,
        }
      );
      const response = await get<
        HwcrComplaint | AllegationComplaint,
        ComplaintQueryParams
      >(dispatch, parameters);
      dispatch(setComplaintsOnMap({ type: complaintType, data: response }));
    } catch (error) {
      console.log(`Unable to retrieve ${complaintType} complaints: ${error}`);
    } finally {
      dispatch(toggleLoading(false));
    }
  };

export const selectTotalComplaintsOnMapByType = 
(complaintType: string) =>
(state: RootState): number => {
  const {
    complaintLocations: { complaintItemsOnMap },
  } = state;
  const { allegations, wildlife } = complaintItemsOnMap;

  switch (complaintType) {
    case COMPLAINT_TYPES.ERS:
      return allegations ? allegations.length : 0;
    case COMPLAINT_TYPES.HWCR:
      return wildlife ? wildlife.length : 0;
    default:
      return 0;
  }
};
export const selectComplaintLocations =
  (complaintType: string) =>
  (state: RootState): Array<{ complaint_type: string; complaint_identifier: string; lat: number; lng: number }> => {
    const {
      complaintLocations: { complaintItemsOnMap },
    } = state;
    const flattenCoordinates = (
      complaint_type: string,
      collection: Array<HwcrComplaint> | Array<AllegationComplaint>
    ): Array<{ complaint_type: string, complaint_identifier: string; lat: number; lng: number }> => {
      if (collection) {
        return collection.map((item) => ({
          complaint_type: complaint_type,
          complaint_identifier: item.complaint_identifier.complaint_identifier,
          lat: +item.complaint_identifier.location_geometry_point.coordinates[
            Coordinates.Latitude
          ],
          lng: +item.complaint_identifier.location_geometry_point.coordinates[
            Coordinates.Longitude
          ],
        }));
      }

      return new Array<{complaint_type: string; complaint_identifier: string; lat: number; lng: number }>();
    };

    let coordinates = new Array<{ complaint_type: string; complaint_identifier: string; lat: number; lng: number }>();

    switch (complaintType) {
      case COMPLAINT_TYPES.ERS:
        const { allegations } = complaintItemsOnMap;

        if (allegations && from(allegations).any()) {
          coordinates = flattenCoordinates(COMPLAINT_TYPES.ERS,allegations);
        }
        break;
      case COMPLAINT_TYPES.HWCR:
      default:
        const { wildlife } = complaintItemsOnMap;

        if (wildlife && from(wildlife).any()) {
          coordinates = flattenCoordinates(COMPLAINT_TYPES.HWCR,wildlife);
        }
        break;
    }

    return coordinates;
  };

export default complaintLocationsSlice.reducer;
