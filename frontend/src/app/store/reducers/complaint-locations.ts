import { createSlice } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../store";
import config from "../../../config";
import { AllegationComplaint } from "../../types/complaints/allegation-complaint";
import { HwcrComplaint } from "../../types/complaints/hwcr-complaint";
import COMPLAINT_TYPES from "../../types/app/complaint-types";
import { ComplaintFilters } from "../../types/complaints/complaint-filters";
import { generateApiParameters, get } from "../../common/api";
import { ComplaintQueryParams } from "../../types/api-params/complaint-query-params";
import { Coordinates } from "../../types/app/coordinate-type";
import { from } from "linq-to-typescript";
import {
  ComplaintLocationsCollection,
  ComplaintLocationsState,
} from "../../types/state/complaint-location-state";
import { MapReturn } from "../../types/complaints/map-return";

const initialState: ComplaintLocationsState = {
  complaintItemsOnMap: {
    wildlife: {complaints: [], unmappedComplaints: 0},
    allegations: {complaints: [], unmappedComplaints: 0},
  },
};

export const complaintLocationsSlice = createSlice({
  name: "complaintLocations",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setComplaintsOnMap: (state, action) => {
      const {
        payload: { type, data },
      } = action;
      const { complaintItemsOnMap } = state;

      let update: ComplaintLocationsCollection = {
        wildlife: {complaints: [], unmappedComplaints: 0},
        allegations: {complaints: [], unmappedComplaints: 0},
      };

      switch (type) {
        case COMPLAINT_TYPES.ERS:
          update = { ...complaintItemsOnMap, allegations: data };
          break;
        case COMPLAINT_TYPES.HWCR:
          update = { ...complaintItemsOnMap, wildlife: data };
          break;
      }
      return { ...state, complaintItemsOnMap: update };
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {},
});

// export the actions/reducers
export const { setComplaintsOnMap } = complaintLocationsSlice.actions;

export const getComplaintsOnMap =
  (complaintType: string, payload: ComplaintFilters): AppThunk =>
  async (dispatch) => {
    const {
      sortColumn,
      sortOrder,
      regionCodeFilter,
      areaCodeFilter,
      zoneCodeFilter,
      officerFilter,
      natureOfComplaintFilter,
      speciesCodeFilter,
      startDateFilter,
      endDateFilter,
      violationFilter,
      complaintStatusFilter,
      query
    } = payload;
    try {
      const apiEndpoint = (type: string): string => {
        switch (type) {
          case COMPLAINT_TYPES.ERS:
            return "allegation-complaint";
          default:
            return "hwcr-complaint";
        }
      };

      const parameters = generateApiParameters(
        `${config.API_BASE_URL}/v1/${apiEndpoint(complaintType)}/map/search`,
        {
          sortColumn: sortColumn,
          sortOrder: sortOrder,
          region: regionCodeFilter?.value,
          zone: zoneCodeFilter?.value,
          community: areaCodeFilter?.value,
          officerAssigned: officerFilter?.value,
          natureOfComplaint: natureOfComplaintFilter?.value,
          speciesCode: speciesCodeFilter?.value,
          incidentReportedStart: startDateFilter,
          incidentReportedEnd: endDateFilter,
          violationCode: violationFilter?.value,
          status: complaintStatusFilter?.value,
          query
        },
      );
      const response = await get<
        MapReturn,
        ComplaintQueryParams
      >(dispatch, parameters);
      dispatch(setComplaintsOnMap({ type: complaintType, data: response }));
    } catch (error) {
      console.log(`Unable to retrieve ${complaintType} complaints: ${error}`);
    }
  };

export const selectTotalComplaintsOnMapByType =
  (complaintType: string) =>
  (state: RootState): number => {
    const {
      complaintLocations: { complaintItemsOnMap },
    } = state;
    const { allegations, wildlife } = complaintItemsOnMap;

    switch (complaintType) {
      case COMPLAINT_TYPES.ERS:
        return allegations.complaints ? allegations.complaints.length : 0;
      case COMPLAINT_TYPES.HWCR:
        return wildlife.complaints ? wildlife.complaints.length : 0;
      default:
        return 0;
    }
  };

  export const selectTotalUnmappedComplaintsOnMapByType =
  (complaintType: string) =>
  (state: RootState): number => {
    const {
      complaintLocations: { complaintItemsOnMap },
    } = state;
    const { allegations, wildlife } = complaintItemsOnMap;

    switch (complaintType) {
      case COMPLAINT_TYPES.ERS:
        return allegations ? allegations.unmappedComplaints : 0;
      case COMPLAINT_TYPES.HWCR:
        return wildlife ? wildlife.unmappedComplaints : 0;
      default:
        return 0;
    }
  };

export const selectComplaintLocations =
  (complaintType: string) =>
  (
    state: RootState,
  ): Array<{
    complaint_type: string;
    complaint_identifier: string;
    lat: number;
    lng: number;
  }> => {
    const {
      complaintLocations: { complaintItemsOnMap },
    } = state;
    const flattenCoordinates = (
      complaint_type: string,
      collection: Array<HwcrComplaint> | Array<AllegationComplaint>,
    ): Array<{
      complaint_type: string;
      complaint_identifier: string;
      lat: number;
      lng: number;
    }> => {
      if (collection) {
        return collection.map((item) => ({
          complaint_type: complaint_type,
          complaint_identifier: item.complaint_identifier.complaint_identifier,
          lat: +item.complaint_identifier.location_geometry_point.coordinates[
            Coordinates.Latitude
          ],
          lng: +item.complaint_identifier.location_geometry_point.coordinates[
            Coordinates.Longitude
          ],
        }));
      }

      return new Array<{
        complaint_type: string;
        complaint_identifier: string;
        lat: number;
        lng: number;
      }>();
    };

    let coordinates = new Array<{
      complaint_type: string;
      complaint_identifier: string;
      lat: number;
      lng: number;
    }>();

    switch (complaintType) {
      case COMPLAINT_TYPES.ERS:
        const { allegations } = complaintItemsOnMap;

        const allegationComplaints = allegations.complaints as AllegationComplaint[];
        if (allegationComplaints && from(allegationComplaints).any()) {
          coordinates = flattenCoordinates(COMPLAINT_TYPES.ERS, allegationComplaints);
        }
        break;
      case COMPLAINT_TYPES.HWCR:
      default:
        const { wildlife } = complaintItemsOnMap;
        const hwcrComplaints = wildlife.complaints as HwcrComplaint[];
        if (hwcrComplaints && from(hwcrComplaints).any()) {
          coordinates = flattenCoordinates(COMPLAINT_TYPES.HWCR, hwcrComplaints);
        }
        break;
    }

    return coordinates;
  };

export default complaintLocationsSlice.reducer;
