import { Assessment } from "../../types/outcomes/assessment";
import { AppThunk, RootState } from "../store";
import { createAction, createSlice, Action, ThunkAction } from "@reduxjs/toolkit";
import config from "../../../config";
import { generateApiParameters, get, patch, post } from "../../common/api";
import { CasesState } from "../../types/state/cases-state";
import { CreateAssessmentInput } from "../../types/app/case-files/create-assessment-input";
import { UpdateAssessmentInput } from "../../types/app/case-files/update-assessment-input";
import { CaseFileDto } from "../../types/app/case-files/case-file";
import { AssessmentActionDto } from "../../types/app/case-files/assessment-action";
import { Officer } from "../../types/person/person";
import { Equipment } from "../../types/outcomes/equipment";
import { CreateEquipmentInput } from "../../types/app/case-files/create-equipment-input";
import { EquipmentDetailsDto } from "../../types/app/case-files/equipment-details";
import { AssessmentDetailsDto } from "../../types/app/case-files/assessment-details";

const initialState: CasesState = {
  assessment: {
    action_required: undefined,
    date: undefined,
    justification: undefined,
    officer: undefined,
    assessment_type: [],
  },
  equipment: []
};

interface AssessmentResponse {
  caseIdentifier: string;
  assessment: AssessmentDetailsDto;
}

export const casesSlice = createSlice({
  name: "cases",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setAssessment: (state, action) => {
      const {
        payload: { assessment },
      } = action;
      state.assessment = { ...assessment }; // Update only the assessment property
    },
    setEquipment: (state, action) => {
      const {
        payload: { equipment },
      } = action;
      state.equipment = [...equipment];
    },

  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(resetAssessment, (state) => {
      return initialState;
    });
    builder.addCase(resetEquipment, (state) => {
      return initialState;
    });
  },
});

// export the actions/reducers
export const { setAssessment } = casesSlice.actions;
export const { setEquipment } = casesSlice.actions;

export const selectAssessment = (state: RootState): Assessment => {
  const { cases } = state;
  return cases.assessment;
};

export const selectEquipment = (state: RootState): EquipmentDetailsDto[] => {
  const { cases } = state;
  return cases.equipment;
};


export const resetAssessment = createAction("assessment/reset");

export const resetEquipment = createAction("equipment/reset");

// Given a compaint id, returns the assessment
export const getAssessment =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData.assessment }));

      });
    };

    export const findAssessment =
    (complaintIdentifier?: string): ThunkAction<Promise<AssessmentResponse | undefined>, RootState, unknown, Action<string>> =>
      async (dispatch) => {
        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
        const response = await get<CaseFileDto>(dispatch, parameters);
        if (response) {
          const assessmentResponse: AssessmentResponse = {
            caseIdentifier: response.caseIdentifier,
            assessment: response.assessmentDetails, // Call a function to parse assessment data from response
          };
          return assessmentResponse;
        } else {
          return undefined;
        }
      };
export const upsertAssessment =
  (
    complaintIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch) => {
      if (!assessment) {
        return;
      }
      const assessmentResponse = await dispatch(findAssessment(complaintIdentifier));
      if (assessmentResponse) {
      if (!assessmentResponse.caseIdentifier || assessmentResponse.assessment?.actions?.length <= 0) {
        dispatch(addAssessment(complaintIdentifier, assessment));
      } else {
        dispatch(updateAssessment(complaintIdentifier, assessmentResponse.caseIdentifier, assessment));
      }
    }
    }

const addAssessment =
  (
    complaintIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch, getState) => {
      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();
      let createAssessmentInput = {
        createAssessmentInput: {
          leadIdentifier: complaintIdentifier,
          createUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          assessmentDetails: {
            actionNotRequired: (assessment.action_required?.value === "No"),
            actions: assessment.assessment_type.map((item) => {
              return {
                date: assessment.date,
                actor: assessment.officer?.value,
                activeIndicator: true,
                actionCode: item.value
              }
            }),
            actionJustificationCode: assessment.justification?.value
          }
        }
      } as CreateAssessmentInput;

      let { createAssessmentInput: { assessmentDetails: { actions } } } = createAssessmentInput;
      for (let item of assessmentType.filter((record) => record.isActive)) {
        if (!actions.map((action) => {
          return action.actionCode
        }).includes(item.assessmentType)) {
          actions.push(
            {
              date: assessment.date,
              actor: assessment.officer?.value,
              activeIndicator: false,
              actionCode: item.assessmentType
            } as AssessmentActionDto
          )
        }
      }

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/assessment`, createAssessmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData.assessment }));

      });
    }

const updateAssessment =
  (
    complaintIdentifier: string,
    caseIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch, getState) => {

      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();

      let updateAssessmentInput = {
        updateAssessmentInput: {
          leadIdentifier: complaintIdentifier,
          caseIdentifier: caseIdentifier,
          updateUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          assessmentDetails: {
            actionNotRequired: (assessment.action_required?.value === "No"),
            actionJustificationCode: assessment.justification?.value,
            actions: assessment.assessment_type.map((item) => {
              return {
                actor: assessment.officer?.value,
                date: assessment.date,
                actionCode: item.value,
                activeIndicator: true
              }
            })
          }
        }
      } as UpdateAssessmentInput;
      let { updateAssessmentInput: { assessmentDetails: { actions } } } = updateAssessmentInput;

      for (let item of assessmentType.filter((record) => record.isActive)) {
        if (!actions.map((action) => {
          return action.actionCode
        }).includes(item.assessmentType)) {
          actions.push(
            {
              actor: assessment.officer?.value,
              date: assessment.date,
              actionCode: item.assessmentType,
              activeIndicator: false
            } as AssessmentActionDto
          )
        }
      }
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/assessment`, updateAssessmentInput);
      await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData.assessment }));
      });
    }


// Given a complaint id, returns the equipment
export const getEquipment =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const equipmentDetails = await parseResponse(res, officers);
        dispatch(setEquipment({ equipment: equipmentDetails.equipment }));

      });
    };

export const findEquipment =
  (complaintIdentifier?: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
    async (dispatch) => {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      const response = await get<CaseFileDto>(dispatch, parameters);
      return response?.caseIdentifier;
    };

export const upsertEquipment =
  (
    complaintIdentifier: string,
    equipment: Equipment
  ): AppThunk =>
    async (dispatch) => {
      if (!equipment) {
        return;
      }
      const caseIdentifier = await dispatch(findEquipment(complaintIdentifier));
      //if (!caseIdentifier) {
        dispatch(addEquipment(complaintIdentifier, equipment));
      //} else {
        //dispatch(updateEquipment(complaintIdentifier, caseIdentifier, equipment));
      //}
    }

const addEquipment =
  (
    complaintIdentifier: string,
    equipment: Equipment
  ): AppThunk =>
    async (dispatch, getState) => {
      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();

      let actions = [{
        date: equipment.dateSet,
        actor: equipment.officerSet.value,
        activeIndicator: true,
        actionCode: "SETEQUIPMT",
      }];

      if (equipment.dateRemoved) {
        actions.push({
            date: equipment.dateRemoved,
            actor: equipment.officerRemoved?.value,
            activeIndicator: true,
            actionCode: "REMEQUIPMT",
        });
    }
    

      // Transform the equipment array into the structure expected by EquipmentDetailsDto
      const equipmentDetails = {
        actionEquipmentTypeCode: equipment.type.value,
        actionEquipmentTypeActiveIndicator: true,
        address: equipment.address,
        xCoordinate: equipment.xCoordinate,
        yCoordinate: equipment.yCoordinate,
        actions: actions
      } as EquipmentDetailsDto;

      let createEquipmentInput = {
        createEquipmentInput: {
          leadIdentifier: complaintIdentifier,
          createUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          equipmentDetails: [equipmentDetails],
        },
      } as CreateEquipmentInput;

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/equipment`, createEquipmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const equipmentDetails = await parseResponse(res, officers);
        dispatch(setEquipment({ equipment: equipmentDetails.equipment }));

      });
    }

    const parseResponse = async (res: CaseFileDto, officers: Officer[]): Promise<{ assessment: Assessment | undefined | null, equipment: EquipmentDetailsDto[] | undefined }> => {
      let updatedAssessmentData: Assessment | undefined | null = null;
      let equipmentDetails: EquipmentDetailsDto[] | undefined = undefined;
    
      // Parse assessment details
      if (res?.assessmentDetails?.actions?.length) {
        const { actor, date } = res.assessmentDetails.actions[0];
        const officerFullName = officers.find(person => person.person_guid.person_guid === actor)?.person_guid?.first_name || actor;
    
        updatedAssessmentData = {
          date: date,
          officer: { label: officerFullName, value: actor },
          action_required: {
            label: res.assessmentDetails.actionNotRequired ? "No" : "Yes",
            value: res.assessmentDetails.actionNotRequired ? "No" : "Yes"
          },
          justification: {
            value: res.assessmentDetails.actionJustificationCode,
            label: res.assessmentDetails.actionJustificationLongDescription
          },
          assessment_type: res.assessmentDetails.actions.filter((action) => action.activeIndicator).map((action) => ({
            label: action.longDescription || "",
            value: action.actionCode
          })),
        };
      }
    
      // Parse equipment details
      if (res?.equipmentDetails) {
        equipmentDetails = Object.values(res.equipmentDetails).map((equipment: any) => ({
          actionEquipmentTypeCode: equipment.actionEquipmentTypeCode,
          actionEquipmentTypeActiveIndicator: equipment.actionEquipmentTypeActiveIndicator,
          address: equipment.address || "",
          xCoordinate: equipment.xCoordinate || "",
          yCoordinate: equipment.yCoordinate || "",
          actions: equipment.actions.map((action: any) => ({
            actor: action.actor,
            date: action.date,
            actionCode: action.actionCode,
            shortDescription: action.shortDescription || "",
            longDescription: action.longDescription || "",
            activeIndicator: action.activeIndicator
          }))
        }));
      }
      return { assessment: updatedAssessmentData, equipment: equipmentDetails };
    };
    

export default casesSlice.reducer;
