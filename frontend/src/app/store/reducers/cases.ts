import { Assessment } from "../../types/outcomes/assessment";
import { AppThunk, RootState } from "../store";
import { createAction, createSlice, Action, ThunkAction } from "@reduxjs/toolkit";
import config from "../../../config";
import { generateApiParameters, get, patch, post } from "../../common/api";
import { CasesState } from "../../types/state/cases-state";
import { CreateAssessmentInput } from "../../types/app/case-files/create-assessment-input";
import { UpdateAssessmentInput } from "../../types/app/case-files/update-assessment-input";
import { CaseFileDto } from "../../types/app/case-files/case-file";
import { AssessmentActionDto } from "../../types/app/case-files/assessment-action";
import { Officer } from "../../types/person/person";
import { CreateSupplementalNotesInput } from "../../types/app/case-files/supplemental-notes/create-supplemental-notes-input";
import { ToggleSuccess, ToggleError } from "../../common/toast";


const initialState: CasesState = {
  assessment: {
    action_required: undefined,
    date: undefined,
    justification: undefined,
    officer: undefined,
    assessment_type: [],
  },
};

export const casesSlice = createSlice({
  name: "cases",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setAssessment: (state, action) => {
      const {
        payload: { assessment },
      } = action;
      state.assessment = { ...assessment }; // Update only the assessment property
    },
    clearAssessment: (state) => {
      state.assessment = {...initialState.assessment};
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(resetAssessment, (state) => {
      return initialState;
    });
  },
});

// export the actions/reducers
export const { setAssessment, clearAssessment } = casesSlice.actions;

export const selectAssessment = (state: RootState): Assessment => {
  const { cases } = state;
  return cases.assessment;
};

export const resetAssessment = createAction("assessment/reset");

// Given a compaint id, returns the assessment
export const getAssessment =
  (complaintIdentifier: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {
        
        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData }));

      });
    };

export const findAssessment =
  (complaintIdentifier?: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
  async (dispatch) => {
    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
    const response = await get<CaseFileDto>(dispatch, parameters);
    return response?.caseIdentifier;
  };

export const upsertAssessment =
  (complaintIdentifier: string, assessment: Assessment): AppThunk =>
  async (dispatch) => {
    if (!assessment) {
      return;
    }
    const caseIdentifier = await dispatch(findAssessment(complaintIdentifier));
    if (!caseIdentifier) {
      dispatch(addAssessment(complaintIdentifier, assessment));
    } else {
      dispatch(updateAssessment(complaintIdentifier, caseIdentifier, assessment));
    }
  };

const addAssessment =
  (complaintIdentifier: string, assessment: Assessment): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "assessment-type": assessmentType },
      officers: { officers },
      app: { profile },
    } = getState();
    let createAssessmentInput = {
      createAssessmentInput: {
        leadIdentifier: complaintIdentifier,
        createUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        assessmentDetails: {
          actionNotRequired: assessment.action_required?.value === "No",
          actions: assessment.assessment_type.map((item) => {
            return {
              date: assessment.date,
              actor: assessment.officer?.value,
              activeIndicator: false,
              actionCode: item.assessmentType
            } as AssessmentActionDto
          )
        }
      }

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/create`, createAssessmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseResponse(res, officers);
        if (res) {
          dispatch(setAssessment({ assessment: updatedAssessmentData }));
          ToggleSuccess(`Assessment has been saved`);
        } else {
          await dispatch(clearAssessment());
          ToggleError(`Unable to create assessment`);
        }
      });
    }

    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/create`, createAssessmentInput);
    await post<CaseFileDto>(dispatch, parameters).then(async (res) => {
      const updatedAssessmentData = await parseResponse(res, officers);
      dispatch(setAssessment({ assessment: updatedAssessmentData }));
    });
  };

const updateAssessment =
  (complaintIdentifier: string, caseIdentifier: string, assessment: Assessment): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "assessment-type": assessmentType },
      officers: { officers },
      app: { profile },
    } = getState();

    let updateAssessmentInput = {
      updateAssessmentInput: {
        leadIdentifier: complaintIdentifier,
        caseIdentifier: caseIdentifier,
        updateUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        assessmentDetails: {
          actionNotRequired: assessment.action_required?.value === "No",
          actionJustificationCode: assessment.justification?.value,
          actions: assessment.assessment_type.map((item) => {
            return {
              actor: assessment.officer?.value,
              date: assessment.date,
              actionCode: item.value,
              activeIndicator: true,
            };
          }),
        },
      },
    } as UpdateAssessmentInput;
    let {
      updateAssessmentInput: {
        assessmentDetails: { actions },
      },
    } = updateAssessmentInput;

    for (let item of assessmentType.filter((record) => record.isActive)) {
      if (
        !actions
          .map((action) => {
            return action.actionCode;
          })
          .includes(item.assessmentType)
      ) {
        actions.push({
          actor: assessment.officer?.value,
          date: assessment.date,
          actionCode: item.assessmentType,
          activeIndicator: false,
        } as AssessmentActionDto);
      }

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/update`, updateAssessmentInput);
      await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedAssessmentData = await parseResponse(res, officers);
        if (res) {
          dispatch(setAssessment({ assessment: updatedAssessmentData }));
          ToggleSuccess(`Assessment has been updated`);
        } else {
          await dispatch(getAssessment(complaintIdentifier));
          ToggleError(`Unable to update assessment`);
        }
      });
    }
    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/update`, updateAssessmentInput);
    await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
      const updatedAssessmentData = await parseResponse(res, officers);
      dispatch(setAssessment({ assessment: updatedAssessmentData }));
    });
  };

const parseResponse = async (res: CaseFileDto, officers: Officer[]): Promise<Assessment | undefined | null> => {
  if (res?.assessmentDetails?.actions?.length) {
    const { actor, actionDate } = res.assessmentDetails.actions.map((action) => {
      return { actor: action.actor, actionDate: action.date };
    })[0];

    let officerFullName = null;
    let officerNames = officers
      .filter((person) => person.person_guid.person_guid === actor)
      .map((officer) => {
        return `${officer.person_guid.first_name} ${officer.person_guid.last_name}`;
      });

    if (officerNames?.length) {
      officerFullName = officerNames[0];
    } else {
      officerFullName = actor;
    }

    const updatedAssessmentData = {
      date: actionDate,
      officer: { label: officerFullName, value: actor },
      action_required: {
        label: res.assessmentDetails.actionNotRequired ? "No" : "Yes",
        value: res.assessmentDetails.actionNotRequired ? "No" : "Yes",
      },
      justification: {
        value: res.assessmentDetails.actionJustificationCode,
        label: res.assessmentDetails.actionJustificationLongDescription,
      },
      assessment_type: res.assessmentDetails.actions
        .filter((action) => {
          return action.activeIndicator;
        })
        .map((action) => {
          return { label: action.longDescription, value: action.actionCode };
        }),
    } as Assessment;
    return updatedAssessmentData;
  } else {
    return null;
  }
};

export const addNote = async (complaintIdentifier: string, notes: string): AppThunk => async (dispatch, getState) => {
  const {
    officers: { officers },
    app: { profile: { idir_username: idir} },
  } = getState();

  let input = {
    leadIdentifier: complaintIdentifier,
    createUserId: idir,
    agencyCode: "COS",
    caseCode: "HWCR",
    notes
  } as CreateSupplementalNotesInput

  const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/note`, input);
  post<CaseFileDto>(dispatch, parameters).then(async (response) => {
    console.log(response)
    // const updatedAssessmentData = await parseResponse(response, officers);
    // dispatch(setAssessment({ assessment: updatedAssessmentData }));
  });

};
export const updateNote = async () => {}

export default casesSlice.reducer;
