import { Assessment } from "../../types/outcomes/assessment"; 
import { AppThunk, RootState } from "../store";
import { createAction, createSlice, Action, ThunkAction } from "@reduxjs/toolkit";
import config from "../../../config";
import { generateApiParameters, get, patch, post } from "../../common/api";
import { CasesState } from "../../types/state/cases-state";
import { CreateAssessmentInput } from "../../types/app/case-files/create-assessment-input";
import { UpdateAssessmentInput } from "../../types/app/case-files/update-assessment-input";
import { CaseFileDto } from "../../types/app/case-files/case-file";
import { AssessmentActionDto } from "../../types/app/case-files/assessment-action";
import { Officer } from "../../types/person/person";
import { Equipment } from "../../types/outcomes/equipment";
import { CreateEquipmentInput } from "../../types/app/case-files/create-equipment-input";
import { EquipmentDetailsDto } from "../../types/app/case-files/equipment-details";
import { AssessmentDetailsDto } from "../../types/app/case-files/assessment-details";
import { Prevention } from "../../types/outcomes/prevention";
import { CreatePreventionInput } from "../../types/app/case-files/prevention/create-prevention-input";
import { PreventionActionDto } from "../../types/app/case-files/prevention/prevention-action";
import { UpdatePreventionInput } from "../../types/app/case-files/prevention/update-prevention-input";
import { SupplementalNote } from "../../types/outcomes/supplemental-note";
import { CreateSupplementalNotesInput } from "../../types/app/case-files/supplemental-notes/create-supplemental-notes-input";
import { UpdateSupplementalNotesInput } from "../../types/app/case-files/supplemental-notes/update-supplemental-notes-input";
import { UUID } from "crypto";
import { ToggleError, ToggleSuccess } from "../../common/toast";

const initialState: CasesState = {
  assessment: {
    action_required: undefined,
    date: undefined,
    justification: undefined,
    officer: undefined,
    assessment_type: [],
  },
  equipment: []
  prevention: {
    date: undefined,
    officer: undefined,
    prevention_type: [],
  },
  note: {
    note: "",
  },
};

interface AssessmentResponse {
  caseIdentifier: string;
  assessment: AssessmentDetailsDto;
}

export const casesSlice = createSlice({
  name: "cases",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setAssessment: (state, action) => {
      const {
        payload: { assessment },
      } = action;
      state.assessment = { ...assessment }; // Update only the assessment property
    },
    setEquipment: (state, action) => {
      const {
        payload: { equipment },
      } = action;
      state.equipment = [...equipment];
    },

    setPrevention: (state, action) => {
      const {
        payload: { prevention },
      } = action;
      state.prevention = { ...prevention }; // Update only the assessment property
    },
    clearAssessment: (state) => {
      state.assessment = {...initialState.assessment};
    },
    clearPrevention: (state) => {
      state.prevention = {...initialState.prevention};
    },
    setCaseFile: (state, action) => {
      const {
        payload: { note },
      } = action;

      //--
      //-- TODO: need to have each dev add thier state to this section instead of requesting
      //-- each individual state. Add assessment, prevention, equipment here
      return { ...state, note };
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(resetAssessment, (state) => {
      return initialState;
    });
    builder.addCase(resetEquipment, (state) => {
      return initialState;
    });
  },
});

// export the actions/reducers
export const { setAssessment, setEquipment, setPrevention, clearAssessment, clearPrevention, setCaseFile} = casesSlice.actions;

export const selectPrevention = (state: RootState): Prevention => {
  const { cases } = state;
  return cases.prevention;
};

export const selectEquipment = (state: RootState): EquipmentDetailsDto[] => {
  const { cases } = state;
  return cases.equipment;
};


export const resetAssessment = createAction("assessment/reset");
export const resetPrevention = createAction("prevention/reset");

export const resetEquipment = createAction("equipment/reset");

// Given a compaint id, returns the assessment
export const getPrevention =
  (complaintIdentifier?: string): AppThunk =>
  async (dispatch, getState) => {
    const {
      officers: { officers },
    } = getState();
    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
    await get<CaseFileDto>(dispatch, parameters).then(async (res) => {
      const updatedPreventionData = await parsePreventionResponse(res, officers);
      dispatch(setPrevention({ prevention: updatedPreventionData }));
    });
  };

export const findCase =
  (complaintIdentifier?: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
  async (dispatch) => {
    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
    const response = await get<CaseFileDto>(dispatch, parameters);
    return response?.caseIdentifier;
  };

export const getCaseFile =
  (complaintIdentifier?: string): AppThunk =>
  async (dispatch) => {
    const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
    const response = await get<CaseFileDto>(dispatch, parameters);

    dispatch(setCaseFile(response));
  };

export const upsertPrevention =
  (complaintIdentifier: string, prevention: Prevention): AppThunk =>
  async (dispatch) => {
    if (!prevention) {
      return;
    }
    const caseIdentifier = await dispatch(findCase(complaintIdentifier));
    if (!caseIdentifier) {
      dispatch(addPrevention(complaintIdentifier, prevention));
    } else {
      dispatch(updatePrevention(complaintIdentifier, caseIdentifier, prevention));
    }
  };

const addPrevention =
  (complaintIdentifier: string, prevention: Prevention): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "prevention-type": preventionType },
      officers: { officers },
      app: { profile },
    } = getState();
    let createPreventionInput = {
      createPreventionInput: {
        leadIdentifier: complaintIdentifier,
        createUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        preventionDetails: {
          actions: prevention.prevention_type.map((item) => {
            return {
              date: prevention.date,
              actor: prevention.officer?.value,

              activeIndicator: true,
              actionCode: item.value,
            };
          }),
        },
      },
    } as CreatePreventionInput;

    let {
      createPreventionInput: {
        preventionDetails: { actions },
      },
    } = createPreventionInput;
    for (let item of preventionType.filter((record) => record.isActive)) {
      if (
        !actions
          .map((action) => {
            return action.actionCode;
          })
          .includes(item.preventionType)
      ) {
        actions.push({
          date: prevention.date,
          actor: prevention.officer?.value,
          activeIndicator: false,
          actionCode: item.preventionType,
        } as PreventionActionDto);
      }
    } 
    
        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/createPrevention`, createPreventionInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedPreventionData = await parsePreventionResponse(res, officers);
        if (res) {
          dispatch(setPrevention({ prevention: updatedPreventionData }));
          ToggleSuccess(`Prevention and education has been saved`);
        } else {
          await dispatch(clearPrevention());
          ToggleError(`Unable to create prevention and education`);
        }
      });
  };

const updatePrevention =
  (complaintIdentifier: string, caseIdentifier: string, prevention: Prevention): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "prevention-type": preventionType },
      officers: { officers },
      app: { profile },
    } = getState();

    let updatePreventionInput = {
      updatePreventionInput: {
        leadIdentifier: complaintIdentifier,
        caseIdentifier: caseIdentifier,
        updateUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        preventionDetails: {
          actions: prevention.prevention_type.map((item) => {
            return {
              actor: prevention.officer?.value,
              date: prevention.date,
              actionCode: item.value,
              activeIndicator: true,
            };
          }),
        },
      },
    } as UpdatePreventionInput;
    let {
      updatePreventionInput: {
        preventionDetails: { actions },
      },
    } = updatePreventionInput;

    for (let item of preventionType.filter((record) => record.isActive)) {
      if (
        !actions
          .map((action) => {
            return action.actionCode;
          })
          .includes(item.preventionType)
      ) {
        actions.push({
          actor: prevention.officer?.value,
          date: prevention.date,
          actionCode: item.preventionType,
          activeIndicator: false,
        } as PreventionActionDto);
      }
    }
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/updatePrevention`, updatePreventionInput);
      await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedPreventionData = await parsePreventionResponse(res, officers);
        if (res) {
          dispatch(setPrevention({ prevention: updatedPreventionData }));
          ToggleSuccess(`Prevention and education has been updated`);
        } else {
          await dispatch(getPrevention(complaintIdentifier));
          ToggleError(`Unable to update prevention and education`);
        }        
      });
  };

const parsePreventionResponse = async (
  res: CaseFileDto,
  officers: Officer[],
): Promise<Prevention | undefined | null> => {
  if (res?.preventionDetails?.actions?.length) {
    const { actor, actionDate } = res.preventionDetails.actions.map((action) => {
      return { actor: action.actor, actionDate: action.date };
    })[0];

    let officerFullName = null;
    let officerNames = officers
      .filter((person) => person.person_guid.person_guid === actor)
      .map((officer) => {
        return `${officer.person_guid.first_name} ${officer.person_guid.last_name}`;
      });

    if (officerNames?.length) {
      officerFullName = officerNames[0];
    } else {
      officerFullName = actor;
    }
    const updatedPreventionData = {
      date: actionDate,
      officer: { label: officerFullName, value: actor },
      prevention_type: res.preventionDetails.actions
        .filter((action) => {
          return action.activeIndicator;
        })
        .map((action) => {
          return { label: action.longDescription, value: action.actionCode };
        }),
    } as Prevention;
    return updatedPreventionData;
  } else {
    return null;
  }
};

export const selectAssessment = (state: RootState): Assessment => {
  const { cases } = state;
  return cases.assessment;
};

export const resetAssessment = createAction("assessment/reset");

// Given a compaint id, returns the assessment
export const getAssessment =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseAssessmentResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData }));

      });
    };

export const upsertAssessment =
  (
    complaintIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch) => {
      if (!assessment) {
        return;
      }
      const assessmentResponse = await dispatch(findAssessment(complaintIdentifier));
      if (assessmentResponse) {
      if (!assessmentResponse.caseIdentifier || assessmentResponse.assessment?.actions?.length <= 0) {
        dispatch(addAssessment(complaintIdentifier, assessment));
      } else {
        dispatch(updateAssessment(complaintIdentifier, assessmentResponse.caseIdentifier, assessment));
      }
    }
    }

const addAssessment =
  (complaintIdentifier: string, assessment: Assessment): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "assessment-type": assessmentType },
      officers: { officers },
      app: { profile },
    } = getState();
    let createAssessmentInput = {
      createAssessmentInput: {
        leadIdentifier: complaintIdentifier,
        createUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        assessmentDetails: {
          actionNotRequired: assessment.action_required?.value === "No",
          actions: assessment.assessment_type.map((item) => {
            return {
              date: assessment.date,
              actor: assessment.officer?.value,
              activeIndicator: true,
              actionCode: item.value,
            };
          }),
          actionJustificationCode: assessment.justification?.value,
        },
      },
    } as CreateAssessmentInput;

    let {
      createAssessmentInput: {
        assessmentDetails: { actions },
      },
    } = createAssessmentInput;
    for (let item of assessmentType.filter((record) => record.isActive)) {
      if (
        !actions
          .map((action) => {
            return action.actionCode;
          })
          .includes(item.assessmentType)
      ) {
        actions.push({
          date: assessment.date,
          actor: assessment.officer?.value,
          activeIndicator: false,
          actionCode: item.assessmentType,
        } as AssessmentActionDto);
      }
    }

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/createAssessment`, createAssessmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedAssessmentData = await parseAssessmentResponse(res, officers);
        if (res) {
          dispatch(setAssessment({ assessment: updatedAssessmentData }));
          ToggleSuccess(`Assessment has been saved`);
        } else {
          await dispatch(clearAssessment());
          ToggleError(`Unable to create assessment`);
        }
      });
  };

const updateAssessment =
  (complaintIdentifier: string, caseIdentifier: string, assessment: Assessment): AppThunk =>
  async (dispatch, getState) => {
    const {
      codeTables: { "assessment-type": assessmentType },
      officers: { officers },
      app: { profile },
    } = getState();

    let updateAssessmentInput = {
      updateAssessmentInput: {
        leadIdentifier: complaintIdentifier,
        caseIdentifier: caseIdentifier,
        updateUserId: profile.idir_username,
        agencyCode: "COS",
        caseCode: "HWCR",
        assessmentDetails: {
          actionNotRequired: assessment.action_required?.value === "No",
          actionJustificationCode: assessment.justification?.value,
          actions: assessment.assessment_type.map((item) => {
            return {
              actor: assessment.officer?.value,
              date: assessment.date,
              actionCode: item.value,
              activeIndicator: true,
            };
          }),
        },
      },
    } as UpdateAssessmentInput;
    let {
      updateAssessmentInput: {
        assessmentDetails: { actions },
      },
    } = updateAssessmentInput;

    for (let item of assessmentType.filter((record) => record.isActive)) {
      if (
        !actions
          .map((action) => {
            return action.actionCode;
          })
          .includes(item.assessmentType)
      ) {
        actions.push({
          actor: assessment.officer?.value,
          date: assessment.date,
          actionCode: item.assessmentType,
          activeIndicator: false,
        } as AssessmentActionDto);
      }
    }
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/updateAssessment`, updateAssessmentInput);
      await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedAssessmentData = await parseAssessmentResponse(res, officers);
        if (res) {
          dispatch(setAssessment({ assessment: updatedAssessmentData.assessment }));
          ToggleSuccess(`Assessment has been updated`);
        } else {
          await dispatch(getAssessment(complaintIdentifier));
          ToggleError(`Unable to update assessment`);
        }        
      });
  };

// Given a complaint id, returns the equipment
export const getEquipment =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const equipmentDetails = await parseResponse(res, officers);
        dispatch(setEquipment({ equipment: equipmentDetails.equipment }));

    let officerFullName = null;

    let officerNames = officers
      .filter((person) => person.person_guid.person_guid === actor)
      .map((officer) => {
        return `${officer.person_guid.first_name} ${officer.person_guid.last_name}`;
      });
    };

export const findEquipment =
  (complaintIdentifier?: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
    async (dispatch) => {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      const response = await get<CaseFileDto>(dispatch, parameters);
      return response?.caseIdentifier;
    };

export const upsertEquipment =
  (
    complaintIdentifier: string,
    equipment: Equipment
  ): AppThunk =>
    async (dispatch) => {
      if (!equipment) {
        return;
      }
      const caseIdentifier = await dispatch(findEquipment(complaintIdentifier));
      //if (!caseIdentifier) {
        dispatch(addEquipment(complaintIdentifier, equipment));
      //} else {
        //dispatch(updateEquipment(complaintIdentifier, caseIdentifier, equipment));
      //}
    }

const addEquipment =
  (
    complaintIdentifier: string,
    equipment: Equipment
  ): AppThunk =>
    async (dispatch, getState) => {
      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();

      let actions = [{
        date: equipment.dateSet,
        actor: equipment.officerSet.value,
        activeIndicator: true,
        actionCode: "SETEQUIPMT",
      }];

      if (equipment.dateRemoved) {
        actions.push({
            date: equipment.dateRemoved,
            actor: equipment.officerRemoved?.value,
            activeIndicator: true,
            actionCode: "REMEQUIPMT",
        });
    }
    

      // Transform the equipment array into the structure expected by EquipmentDetailsDto
      const equipmentDetails = {
        actionEquipmentTypeCode: equipment.type.value,
        actionEquipmentTypeActiveIndicator: true,
        address: equipment.address,
        xCoordinate: equipment.xCoordinate,
        yCoordinate: equipment.yCoordinate,
        actions: actions
      } as EquipmentDetailsDto;

      let createEquipmentInput = {
        createEquipmentInput: {
          leadIdentifier: complaintIdentifier,
          createUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          equipmentDetails: [equipmentDetails],
        },
      } as CreateEquipmentInput;

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/equipment`, createEquipmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const equipmentDetails = await parseResponse(res, officers);
        dispatch(setEquipment({ equipment: equipmentDetails.equipment }));

      });
    }

    const parseResponse = async (res: CaseFileDto, officers: Officer[]): Promise<{ assessment: Assessment | undefined | null, equipment: EquipmentDetailsDto[] | undefined }> => {
      let updatedAssessmentData: Assessment | undefined | null = null;
      let equipmentDetails: EquipmentDetailsDto[] | undefined = undefined;
    
      // Parse assessment details
      if (res?.assessmentDetails?.actions?.length) {
        const { actor, date } = res.assessmentDetails.actions[0];
        const officerFullName = officers.find(person => person.person_guid.person_guid === actor)?.person_guid?.first_name || actor;
    
        updatedAssessmentData = {
          date: date,
          officer: { label: officerFullName, value: actor },
          action_required: {
            label: res.assessmentDetails.actionNotRequired ? "No" : "Yes",
            value: res.assessmentDetails.actionNotRequired ? "No" : "Yes"
          },
          justification: {
            value: res.assessmentDetails.actionJustificationCode,
            label: res.assessmentDetails.actionJustificationLongDescription
          },
          assessment_type: res.assessmentDetails.actions.filter((action) => action.activeIndicator).map((action) => ({
            label: action.longDescription || "",
            value: action.actionCode
          })),
        };
      }
    
      // Parse equipment details
      if (res?.equipmentDetails) {
        equipmentDetails = Object.values(res.equipmentDetails).map((equipment: any) => ({
          actionEquipmentTypeCode: equipment.actionEquipmentTypeCode,
          actionEquipmentTypeActiveIndicator: equipment.actionEquipmentTypeActiveIndicator,
          address: equipment.address || "",
          xCoordinate: equipment.xCoordinate || "",
          yCoordinate: equipment.yCoordinate || "",
          actions: equipment.actions.map((action: any) => ({
            actor: action.actor,
            date: action.date,
            actionCode: action.actionCode,
            shortDescription: action.shortDescription || "",
            longDescription: action.longDescription || "",
            activeIndicator: action.activeIndicator
          }))
        }));
      }
      return { assessment: updatedAssessmentData, equipment: equipmentDetails };
    };
    

export const selectSupplementalNote = (state: RootState): SupplementalNote => {
  const {
    cases: { note },
  } = state;

  if (note?.note) {
    return note;
  } else {
    return { ...note, note: "" };
  }
};

export const selectNotesOfficer = (state: RootState) => {
  const {
    app: { profile },
    cases: {
      note: { action },
    },
    officers: { officers: data },
  } = state;

  let currentOfficer: { initials: string; displayName: string } = { initials: "UN", displayName: "Unknown" };

  if (!action) {
    currentOfficer = {
      initials: `${profile.givenName?.substring(0, 1)}${profile.surName?.substring(0, 1)}`,
      displayName: `${profile.givenName} ${profile.surName}`,
    };
  } else {
    const { actor } = action;
    const officer = data.find((item) => item.officer_guid === actor);
    if (officer) {
      const {
        person_guid: { first_name: givenName, last_name: surName },
      } = officer;
      currentOfficer = {
        initials: `${givenName?.substring(0, 1)}${surName?.substring(0, 1)}`,
        displayName: `${givenName} ${surName}`,
      };
    }
  }

  return currentOfficer;
};

export const upsertNote =
  (id: string, note: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
  async (dispatch, getState) => {
    const {
      officers: { officers },
      app: {
        profile: { idir_username: idir },
      },
      cases: { note: currentNote },
    } = getState();

    const _createNote =
      (
        id: string,
        note: string,
        actor: string,
        userId: string,
      ): ThunkAction<Promise<CaseFileDto>, RootState, unknown, Action<CaseFileDto>> =>
      async (dispatch) => {
        const input: CreateSupplementalNotesInput = {
          note,
          leadIdentifier: id,
          agencyCode: "COS",
          caseCode: "HWCR",
          actor,
          createUserId: userId,
        };

        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/note`, input);
        return await post<CaseFileDto>(dispatch, parameters);
      };

    const _updateNote =
      (
        id: UUID,
        note: string,
        actor: string,
        userId: string,
      ): ThunkAction<Promise<CaseFileDto>, RootState, unknown, Action<CaseFileDto>> =>
      async (dispatch) => {
        const caseId = await dispatch(findCase(id));

        const input: UpdateSupplementalNotesInput = {
          note,
          caseIdentifier: caseId as UUID,
          actor,
          updateUserId: userId,
        };

        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/note`, input);
        return await patch<CaseFileDto>(dispatch, parameters);
      };

    const officer = officers.find((item) => item.user_id === idir);

    let result;
    if (!currentNote?.action) {
      result = await dispatch(_createNote(id, note, officer ? officer.officer_guid : "", idir));
      if (result !== null) {
        ToggleSuccess("Supplemental note created");
      } else {
        ToggleError("Error, unable to create supplemental note");
      }
    } else {
      result = await dispatch(_updateNote(id as UUID, note, officer ? officer.officer_guid : "", idir));

      if (result !== null) {
        ToggleSuccess("Supplemental note updated");
      } else {
        ToggleError("Error, unable to update supplemental note");
      }
    }

    if (result !== null) {
      return "success";
    } else {
      return "error";
    }
  };

export default casesSlice.reducer;
