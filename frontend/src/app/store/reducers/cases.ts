import { Assessment } from "../../types/outcomes/assessment";
import { AppThunk, RootState } from "../store";
import { createAction, createSlice, Action, ThunkAction } from "@reduxjs/toolkit";
import config from "../../../config";
import { generateApiParameters, get, patch, post } from "../../common/api";
import { CasesState } from "../../types/state/cases-state";
import { CreateAssessmentInput } from "../../types/app/case-files/create-assessment-input";
import { UpdateAssessmentInput } from "../../types/app/case-files/update-assessment-input";
import { CaseFileDto } from "../../types/app/case-files/case-file";
import { AssessmentActionDto } from "../../types/app/case-files/assessment-action";
import { Officer } from "../../types/person/person";
import { PreventionEducation } from "../../types/outcomes/hwcr-prevention";
import { CreatePreventionEducationInput } from "../../types/app/case-files/create-prevention-education-input";
import { UpdatePreventionEducationInput } from "../../types/app/case-files/update-prevention-education-input";

const initialState: CasesState = {
  assessment: {
    action_required: undefined,
    date: undefined,
    justification: undefined,
    officer: undefined,
    assessment_type: [],
  },
  preventionEducation: {
    date: undefined,
    officer: undefined,
    prevention_education_type: [],
  },
};

export const casesSlice = createSlice({
  name: "cases",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setAssessment: (state, action) => {
      const {
        payload: { assessment },
      } = action;
      state.assessment = { ...assessment }; // Update only the assessment property
    },
    setPreventionEducation: (state, action) => {
      const {
        payload: { preventionEducation },
      } = action;
      state.preventionEducation = { ...preventionEducation }; // Update only the assessment property
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(resetAssessment, (state) => {
      return initialState;
    });
  },
});

// export the actions/reducers
export const { setAssessment, setPreventionEducation } = casesSlice.actions;

export const selectAssessment = (state: RootState): Assessment => {
  const { cases } = state;
  return cases.assessment;
};
export const selectPreventionEducation = (state: RootState): PreventionEducation => {
  const { cases } = state;
  return cases.preventionEducation;
};

export const resetAssessment = createAction("assessment/reset");
export const resetPreventionEducation = createAction("prevention-education/reset");

export const findCaseFile =
  (complaintIdentifier?: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
    async (dispatch) => {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      const response = await get<CaseFileDto>(dispatch, parameters);
      return response?.caseIdentifier;
    };

// Given a compaint id, returns the assessment
export const getAssessment =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData }));

      });
    };
// Given a compaint id, returns the prevention education
export const getPreventionEducation =
  (complaintIdentifier?: string): AppThunk =>
    async (dispatch, getState) => {
      const {
        officers: { officers },
      } = getState();
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/${complaintIdentifier}`);
      await get<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedPreventionEducationData = await parsePreventionEducationResponse(res, officers);
        dispatch(setPreventionEducation({ preventionEducation: updatedPreventionEducationData }));

      });
    };

export const upsertAssessment =
  (
    complaintIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch) => {
      if (!assessment) {
        return;
      }
      const caseIdentifier = await dispatch(findCaseFile(complaintIdentifier));
      if (!caseIdentifier) {
        dispatch(addAssessment(complaintIdentifier, assessment));
      } else {
        dispatch(updateAssessment(complaintIdentifier, caseIdentifier, assessment));
      }
    }
  export const upsertPreventionEducation =
    (
      complaintIdentifier: string,
      preventionEducation: PreventionEducation
    ): AppThunk =>
      async (dispatch) => {
        if (!preventionEducation) {
          return;
        }
        const caseIdentifier = await dispatch(findCaseFile(complaintIdentifier));
        if (!caseIdentifier) {
          dispatch(addPreventionEducation(complaintIdentifier, preventionEducation));
        } else {
          dispatch(updatePreventionEducation(complaintIdentifier, caseIdentifier, preventionEducation));
        }
      }

const addAssessment =
  (
    complaintIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch, getState) => {
      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();
      let createAssessmentInput = {
        createAssessmentInput: {
          leadIdentifier: complaintIdentifier,
          createUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          assessmentDetails: {
            actionNotRequired: (assessment.action_required?.value === "No"),
            actions: assessment.assessment_type.map((item) => {
              return {
                date: assessment.date,
                actor: assessment.officer?.value,
                activeIndicator: true,
                actionCode: item.value
              }
            }),
            actionJustificationCode: assessment.justification?.value
          }
        }
      } as CreateAssessmentInput;

      let { createAssessmentInput: { assessmentDetails: { actions } } } = createAssessmentInput;
      for (let item of assessmentType.filter((record) => record.isActive)) {
        if (!actions.map((action) => {
          return action.actionCode
        }).includes(item.assessmentType)) {
          actions.push(
            {
              date: assessment.date,
              actor: assessment.officer?.value,
              activeIndicator: false,
              actionCode: item.assessmentType
            } as AssessmentActionDto
          )
        }
      }

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/create`, createAssessmentInput);
      await post<CaseFileDto>(dispatch, parameters).then(async (res) => {

        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData }));

      });
    }
    const addPreventionEducation =
    (
      complaintIdentifier: string,
      preventionEducation: PreventionEducation
    ): AppThunk =>
      async (dispatch, getState) => {
        const {
          codeTables: { "assessment-type": assessmentType },
          officers: { officers },
          app: { profile },
        } = getState();
        let createPreventionEducationInput = {
          createPreventionEducationInput: {
            leadIdentifier: complaintIdentifier,
            createUserId: profile.idir_username,
            agencyCode: "COS",
            caseCode: "HWCR",
            preventionEducationDetails: {
              actions: preventionEducation.prevention_education_type.map((item) => {
                return {
                  date: preventionEducation.date,
                  actor: preventionEducation.officer?.value,
                  activeIndicator: true,
                  actionCode: item.value
                }
              }),
            }
          }
        } as CreatePreventionEducationInput;
  
        let { createPreventionEducationInput: { preventionEducationDetails: { actions } } } = createPreventionEducationInput;
        for (let item of assessmentType.filter((record) => record.isActive)) {
          if (!actions.map((action) => {
            return action.actionCode
          }).includes(item.assessmentType)) {
            actions.push(
              {
                date: preventionEducation.date,
                actor: preventionEducation.officer?.value,
                activeIndicator: false,
                actionCode: item.assessmentType
              } as AssessmentActionDto
            )
          }
        }
  
        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/create`, createPreventionEducationInput);
        await post<CaseFileDto>(dispatch, parameters).then(async (res) => {
  
          const updatedPreventionEducationData = await parsePreventionEducationResponse(res, officers);
          dispatch(setPreventionEducation({ assessment: updatedPreventionEducationData }));
  
        });
      }

const updateAssessment =
  (
    complaintIdentifier: string,
    caseIdentifier: string,
    assessment: Assessment
  ): AppThunk =>
    async (dispatch, getState) => {

      const {
        codeTables: { "assessment-type": assessmentType },
        officers: { officers },
        app: { profile },
      } = getState();

      let updateAssessmentInput = {
        updateAssessmentInput: {
          leadIdentifier: complaintIdentifier,
          caseIdentifier: caseIdentifier,
          updateUserId: profile.idir_username,
          agencyCode: "COS",
          caseCode: "HWCR",
          assessmentDetails: {
            actionNotRequired: (assessment.action_required?.value === "No"),
            actionJustificationCode: assessment.justification?.value,
            actions: assessment.assessment_type.map((item) => {
              return {
                actor: assessment.officer?.value,
                date: assessment.date,
                actionCode: item.value,
                activeIndicator: true
              }
            })
          }
        }
      } as UpdateAssessmentInput;
      let { updateAssessmentInput: { assessmentDetails: { actions } } } = updateAssessmentInput;

      for (let item of assessmentType.filter((record) => record.isActive)) {
        if (!actions.map((action) => {
          return action.actionCode
        }).includes(item.assessmentType)) {
          actions.push(
            {
              actor: assessment.officer?.value,
              date: assessment.date,
              actionCode: item.assessmentType,
              activeIndicator: false
            } as AssessmentActionDto
          )
        }
      }
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/update`, updateAssessmentInput);
      await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
        const updatedAssessmentData = await parseResponse(res, officers);
        dispatch(setAssessment({ assessment: updatedAssessmentData }));
      });
    }
    const updatePreventionEducation =
    (
      complaintIdentifier: string,
      caseIdentifier: string,
      preventionEducation: PreventionEducation
    ): AppThunk =>
      async (dispatch, getState) => {
  
        const {
          codeTables: { "assessment-type": preventionEducationType },
          officers: { officers },
          app: { profile },
        } = getState();
  
        let updatePreventionEducationInput = {
          updatePreventionEducationInput: {
            leadIdentifier: complaintIdentifier,
            caseIdentifier: caseIdentifier,
            updateUserId: profile.idir_username,
            agencyCode: "COS",
            caseCode: "HWCR",
            preventionEducationDetails: {
              actions: preventionEducation.prevention_education_type.map((item) => {
                return {
                  actor: preventionEducation.officer?.value,
                  date: preventionEducation.date,
                  actionCode: item.value,
                  activeIndicator: true
                }
              })
            }
          }
        } as UpdatePreventionEducationInput;
        let { updatePreventionEducationInput: { preventionEducationDetails: { actions } } } = updatePreventionEducationInput;
  
        for (let item of preventionEducationType.filter((record) => record.isActive)) {
          if (!actions.map((action) => {
            return action.actionCode
          }).includes(item.assessmentType)) {
            actions.push(
              {
                actor: preventionEducation.officer?.value,
                date: preventionEducation.date,
                actionCode: item.assessmentType,
                activeIndicator: false
              } as AssessmentActionDto
            )
          }
        }
        const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/case/update`, updatePreventionEducationInput);
        await patch<CaseFileDto>(dispatch, parameters).then(async (res) => {
          const updatedPreventionEducationData = await parsePreventionEducationResponse(res, officers);
          dispatch(setPreventionEducation({ preventionEducation: updatedPreventionEducationData }));
        });
      }

const parseResponse = async (res: CaseFileDto, officers: Officer[]): Promise<Assessment | undefined | null> => {

  if (res?.assessmentDetails?.actions?.length) {

    const { actor, actionDate } = res.assessmentDetails.actions.map((action) => {
      return { actor: action.actor, actionDate: action.date }
    })[0];

    let officerFullName = null;
    let officerNames = officers.filter((person) => person.person_guid.person_guid === actor).map((officer) => {
      return `${officer.person_guid.first_name} ${officer.person_guid.last_name}`
    })

    if (officerNames?.length) {
      officerFullName = officerNames[0];
    } else {
      officerFullName = actor;
    }

    const updatedAssessmentData = {
      date: actionDate,
      officer: { label: officerFullName, value: actor },
      action_required: {
        label: res.assessmentDetails.actionNotRequired ? "No" : "Yes",
        value: res.assessmentDetails.actionNotRequired ? "No" : "Yes"
      },
      justification: {
        value: res.assessmentDetails.actionJustificationCode,
        label: res.assessmentDetails.actionJustificationLongDescription
      },
      assessment_type: res.assessmentDetails.actions.filter((action) => { return action.activeIndicator }).map((action) => {
        return { label: action.longDescription, value: action.actionCode }
      }),
    } as Assessment;
    return updatedAssessmentData;
  }
  else {
    return null;
  }
}
const parsePreventionEducationResponse = async (res: CaseFileDto, officers: Officer[]): Promise<PreventionEducation | undefined | null> => {

  if (res?.preventionEducationDetails?.actions?.length) {

    const { actor, actionDate } = res.preventionEducationDetails.actions.map((action) => {
      return { actor: action.actor, actionDate: action.date }
    })[0];

    let officerFullName = null;
    let officerNames = officers.filter((person) => person.person_guid.person_guid === actor).map((officer) => {
      return `${officer.person_guid.first_name} ${officer.person_guid.last_name}`
    })

    if (officerNames?.length) {
      officerFullName = officerNames[0];
    } else {
      officerFullName = actor;
    }

    const updatedPreventionEducationData = {
      date: actionDate,
      officer: { label: officerFullName, value: actor },
      prevention_education_type: res.assessmentDetails.actions.filter((action) => { return action.activeIndicator }).map((action) => {
        return { label: action.longDescription, value: action.actionCode }
      }),
    } as PreventionEducation;
    return updatedPreventionEducationData;
  }
  else {
    return null;
  }
}

export default casesSlice.reducer;
