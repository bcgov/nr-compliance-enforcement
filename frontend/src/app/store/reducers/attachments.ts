import { createSlice } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../store";
import {
  deleteMethod,
  generateApiParameters,
  get,
  putFile,
} from "../../common/api";
import { from } from "linq-to-typescript";
import { COMSObject } from "../../types/coms/object";
import { AttachmentsState } from "../../types/state/attachments-state";
import config from "../../../config";
import { injectComplaintIdentifierToFilename, injectComplaintIdentifierToThumbFilename, isImage } from "../../common/methods";
import { ToggleError, ToggleSuccess } from "../../common/toast";
import axios from "axios";
import { fromImage } from 'imtool';

const initialState: AttachmentsState = {
  attachments: [],
};

const SLIDE_HEIGHT = 130;
const SLIDE_WIDTH = 289; // width of the carousel slide, in pixels

/**
 * Attachments for each complaint
 */
export const attachmentsSlice = createSlice({
  name: "attachments",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {

    // used when retrieving attachments from objectstore
    setAttachments: (state, action) => {
      const {
        payload: { attachments },
      } = action;
      return { ...state, attachments: attachments ?? [] };
    },

    // used when removing an attachment from a complaint
    removeAttachment: (state, action) => {
      return {
        ...state,
        attachments: state.attachments.filter(attachment => attachment.id !== action.payload),
      };
    },

    // used when adding an attachment to a complaint
    addAttachment: (state, action) => {
      const { name, type, size, id } = action.payload; // Extract relevant info
      const serializedFile = { name, type, size, id }; 

      return {
        ...state,
        attachments: [...state.attachments, serializedFile],
      };
    },
    
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {},
});

// export the actions/reducers
export const { setAttachments, removeAttachment , addAttachment} = attachmentsSlice.actions;

// Get list of the attachments and update store
export const getAttachments =
  (complaint_identifier: string): AppThunk =>
  async (dispatch) => {
    try {
      const parameters = generateApiParameters(
        `${config.COMS_URL}/object?bucketId=${config.COMS_BUCKET}`
      );
      const response = await get<Array<COMSObject>>(dispatch, parameters, {
        "x-amz-meta-complaint-id": complaint_identifier,
        "x-amz-meta-is-thumb": "N",
      });
      if (response && from(response).any()) {
        for(let i = 0; i < response.length; i++)
        {

          if(isImage(response[i].name))
          {
            const thumbArrayResponse = await get<Array<COMSObject>>(dispatch, parameters, {
              "x-amz-meta-complaint-id": complaint_identifier,
              "x-amz-meta-is-thumb": "Y",
              "x-amz-meta-thumb-for": response[i].id,
            });
        
            const thumbParameters = generateApiParameters(
              `${config.COMS_URL}/object/${thumbArrayResponse[0].id}?download=url`
            );

        
            const thumbResponse = await get<string>(dispatch, thumbParameters);
            response[i].imageIconString = thumbResponse;
            response[i].imageIconId = thumbArrayResponse[0].id;
            }

          }
        }
        dispatch(
          setAttachments({
            attachments: response ?? [],
          })
        );
    } catch (error) {
      ToggleError(`Error retrieving attachments`);
    }
  };

// delete attachments from objectstore
export const deleteAttachments =
  (attachments: COMSObject[]): AppThunk =>
  async (dispatch) => {
    if (attachments) {
      for (const attachment of attachments) {
        try {
          const parameters = generateApiParameters(
            `${config.COMS_URL}/object/${attachment.id}`
          );

          const thumbParameters = generateApiParameters(
            `${config.COMS_URL}/object/${attachment.imageIconId}`
          );

          await deleteMethod<string>(dispatch, parameters);
          await deleteMethod<string>(dispatch, thumbParameters);
          dispatch(removeAttachment(attachment.id)); // delete from store
          dispatch(removeAttachment(attachment.imageIconId)); // delete from store
          ToggleSuccess(`Attachment ${decodeURIComponent(attachment.name)} has been removed`);
        } catch (error) {
          ToggleError(`Attachment ${decodeURIComponent(attachment.name)} could not be deleted`);
        }
      }
    }

  };

// save new attachment(s) to object store
export const saveAttachments =
  (attachments: File[], complaint_identifier: string): AppThunk =>
  async (dispatch) => {
    if (attachments) {
      for (const attachment of attachments) {
        const header = {
          "x-amz-meta-complaint-id": complaint_identifier,
          "x-amz-meta-is-thumb": "N",
          "Content-Disposition": `attachment; filename="${encodeURIComponent(injectComplaintIdentifierToFilename(
            attachment.name,
            complaint_identifier
          ))}"`,
          "Content-Type": attachment?.type,
        };

        try {
          const parameters = generateApiParameters(
            `${config.COMS_URL}/object?bucketId=${config.COMS_BUCKET}`
          );
          const response = await putFile<COMSObject>(
            dispatch,
            parameters,
            header,
            attachment
          );
          dispatch(addAttachment(response)); // dispatch with serializable payload
          if(isImage(attachment.name))
          {
            const thumbHeader = {
              "x-amz-meta-complaint-id": complaint_identifier,
              "x-amz-meta-is-thumb": "Y",
              "x-amz-meta-thumb-for": response.id,
              "Content-Disposition": `attachment; filename="${encodeURIComponent(injectComplaintIdentifierToThumbFilename(
                attachment.name,
                complaint_identifier
              ))}"`,
              "Content-Type": "image/jpeg",
            };  
            const tool = await fromImage(attachment);
            const heightRatio = SLIDE_HEIGHT / tool.originalHeight;
            const widthRatio = SLIDE_WIDTH / tool.originalWidth;
            const thumbnailFile = await (heightRatio > widthRatio ? tool.scale(tool.originalWidth * heightRatio, tool.originalHeight * heightRatio).crop(0,0,SLIDE_WIDTH, SLIDE_HEIGHT).toFile(attachment.name + "-thumb.jpg") : tool.scale(tool.originalWidth * widthRatio, tool.originalHeight * widthRatio).crop(0,0,SLIDE_WIDTH, SLIDE_HEIGHT).toFile(attachment.name + "-thumb.jpg"));
  
  
            await putFile<COMSObject>(
              dispatch,
              parameters,
              thumbHeader,
              thumbnailFile
            );
          }

          if (response) {
            ToggleSuccess(`Attachment "${attachment.name}" saved`);
          }

        } catch (error) {
          console.log(error);
          if (axios.isAxiosError(error) && error.response?.status === 409) {
            ToggleError(`Attachment "${attachment.name}" could not be saved.  Duplicate file.`);
          } else {
            ToggleError(`Attachment "${attachment.name}" could not be saved.`);
          }
        }
      }
    }
  };

//-- selectors
export const selectAttachments = (state: RootState): COMSObject[]  => {
  const { attachments: attachmentsRoot } = state;
  const { attachments } = attachmentsRoot;

  return attachments ?? [];
};

export default attachmentsSlice.reducer;
