import { Action, createSlice, createSelector, ThunkAction } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "@store/store";
import config from "@/config";
import { OfficerState } from "@apptypes/complaints/officers-state";
import { AppUser } from "@apptypes/app/app_user/app_user";
import { NewAppUser } from "@apptypes/app/app_user/new-app-user";
import { UUID } from "node:crypto";
import { AppUserComplaintXref } from "@apptypes/complaints/app-user-complaint-xref";
import COMPLAINT_TYPES from "@apptypes/app/complaint-types";
import {
  updateWildlifeComplaintByRow,
  updateAllegationComplaintByRow,
  updateGeneralComplaintByRow,
  getComplaintById,
  selectComplaint,
  selectComplaintCollaborators,
} from "./complaints";
import { generateApiParameters, get, patch, post } from "@common/api";
import { from } from "linq-to-typescript";
import { NewAppUserComplaintXref } from "@apptypes/api-params/new-app-user-complaint-xref";
import Option from "@apptypes/app/option";
import { toggleNotification } from "./app";
import { WildlifeComplaint } from "@apptypes/app/complaints/wildlife-complaint";
import { AllegationComplaint } from "@apptypes/app/complaints/allegation-complaint";
import { GeneralIncidentComplaint } from "@apptypes/app/complaints/general-complaint";
import { Roles } from "@apptypes/app/roles";
import { ToggleError, ToggleSuccess } from "@/app/common/toast";
import { Collaborator } from "@/app/types/app/complaints/collaborator";
import { renderLabelElement } from "@/app/components/common/collaborator-badge";
import { CodeTableState } from "@/app/types/state/code-table-state";

const initialState: OfficerState = {
  officers: [],
};

export const officerSlice = createSlice({
  name: "officers",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setOfficers: (state, action) => {
      const {
        payload: { officers },
      } = action;
      return { ...state, officers };
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {},
});

// export the actions/reducers
export const { setOfficers } = officerSlice.actions;

// Get list of the officers and update store
export const getOfficers =
  (zone?: string): AppThunk =>
  async (dispatch, getState) => {
    try {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/app-user/`);
      const response = await get<Array<AppUser>>(dispatch, parameters);
      const agencyTable = getState()?.codeTables?.agency as CodeTableState["agency"] | undefined;

      for (const officer of response) {
        officer.agency_code = agencyTable?.find((item) => item.agency === officer.agency_code_ref);
      }

      if (response && from(response).any()) {
        dispatch(
          setOfficers({
            officers: response,
          }),
        );
      }
    } catch (error) {
      //-- handle errors
    }
  };

// Assigns the current user to an office
export const assignCurrentUserToComplaint =
  (userId: string, userGuid: UUID, complaint_identifier: string, complaint_type: string, isHeader: boolean): AppThunk =>
  async (dispatch) => {
    try {
      let appUserParams = generateApiParameters(
        `${config.API_BASE_URL}/v1/app-user/find-by-auth-user-guid/${userGuid}`,
      );
      let appUserResponse = await get<AppUser>(dispatch, appUserParams);

      if (appUserResponse.auth_user_guid === undefined) {
        appUserParams = generateApiParameters(`${config.API_BASE_URL}/v1/app-user/find-by-userid/${userId}`);

        let appUserByUserIdResponse = await get<AppUser>(dispatch, appUserParams);
        const appUserGuid = appUserByUserIdResponse.app_user_guid;

        appUserParams = generateApiParameters(`${config.API_BASE_URL}/v1/app-user/${appUserGuid}`, {
          auth_user_guid: userGuid,
        });

        await patch<AppUser>(dispatch, appUserParams);
      }

      dispatch(
        updateComplaintAssignee(
          userId,
          complaint_identifier,
          complaint_type,
          isHeader,
          appUserResponse.app_user_guid as UUID,
        ),
      );
    } catch (error) {
      //-- handle error
    }
  };

// creates a new cross reference for a person and office.  Assigns a person to an office.
export const updateComplaintAssignee =
  (
    currentUser: string,
    complaint_identifier: string,
    complaint_type: string,
    isHeader: boolean,
    appUserGuid?: UUID,
  ): AppThunk =>
  async (dispatch) => {
    try {
      // add new person complaint record
      const payload = {
        active_ind: true,
        app_user_guid: appUserGuid,
        complaint_identifier: complaint_identifier,
        app_user_complaint_xref_code: "ASSIGNEE",
        create_user_id: currentUser,
      } as NewAppUserComplaintXref;

      // assign a complaint to an app user
      let appUserComplaintXrefGuidParams = generateApiParameters(
        `${config.API_BASE_URL}/v1/app-user-complaint-xref/${complaint_identifier}`,
        payload,
      );
      await post<Array<AppUserComplaintXref>>(dispatch, appUserComplaintXrefGuidParams);

      if (!isHeader) {
        // thunk was called via the list view, get the latest version
        const parameters = generateApiParameters(
          `${config.API_BASE_URL}/v1/complaint/by-complaint-identifier/${complaint_type}/${complaint_identifier}`,
        );
        const response = await get<WildlifeComplaint | AllegationComplaint | GeneralIncidentComplaint>(
          dispatch,
          parameters,
        );

        // refresh complaints.  Note we should just update the changed record instead of the entire list of complaints
        if (COMPLAINT_TYPES.HWCR === complaint_type) {
          dispatch(updateWildlifeComplaintByRow(response as WildlifeComplaint));
        } else if (COMPLAINT_TYPES.GIR === complaint_type) {
          dispatch(updateGeneralComplaintByRow(response as GeneralIncidentComplaint));
        } else {
          dispatch(updateAllegationComplaintByRow(response as AllegationComplaint));
        }
      } else {
        // Thunk was called via complaint header, refresh complaint to view the changes
        dispatch(getComplaintById(complaint_identifier, complaint_type));
      }
    } catch (error) {
      console.log(error);
    }
  };

//-- assign a user to a complaint and return the result of the assignment
export const assignComplaintToOfficer =
  (id: string, appUserId: string): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
  async (dispatch, getState) => {
    const {
      app: {
        profile: { idir_username: currentUser },
      },
    } = getState();

    // assign a complaint to a person
    let payload = generateApiParameters(`${config.API_BASE_URL}/v1/app-user-complaint-xref/${id}`, {
      active_ind: true,
      app_user_guid: appUserId,
      complaint_identifier: id,
      app_user_complaint_xref_code: "ASSIGNEE",
      create_user_id: currentUser,
    });

    const result = await post<Array<AppUserComplaintXref>>(dispatch, payload);

    if (result) {
      return "success";
    } else {
      return "error";
    }
  };

export const assignOfficerToOffice =
  (appUserId: string, officeGuid: string): AppThunk =>
  async (dispatch, getState) => {
    const {
      officers: { officers },
    } = getState();

    try {
      const selectedOfficer = officers.find((item) => {
        return appUserId === item.app_user_guid;
      });

      const update = { ...selectedOfficer, office_guid: officeGuid };
      const { agency_code, ...updateWithoutAgencyCode } = update;

      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/app-user/${selectedOfficer?.app_user_guid}`, {
        ...updateWithoutAgencyCode,
      });
      const response = await patch<Array<AppUser>>(dispatch, parameters);

      if (response && from(response).any()) {
        dispatch(toggleNotification("success", "officer assigned"));
      }
    } catch (error) {
      //-- handle errors
      dispatch(toggleNotification("error", "unable to assign officer to office"));
    }
  };

export const createOfficer =
  (newOfficerData: NewAppUser): AppThunk =>
  async (dispatch, getState) => {
    try {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/app-user`, newOfficerData);
      const response = await post<AppUser>(dispatch, parameters);
      if (response) {
        ToggleSuccess("Officer created successfully");
        dispatch(getOfficers());
      } else {
        ToggleError("Unable to add new officer");
      }
    } catch (error) {
      //-- handle errors
      dispatch(toggleNotification("error", "Unable to create officer"));
    }
  };

export const updateOfficer =
  (
    officerGuid: string,
    updatedData: Partial<AppUser>,
  ): ThunkAction<Promise<string | undefined>, RootState, unknown, Action<string>> =>
  async (dispatch, getState) => {
    try {
      const parameters = generateApiParameters(`${config.API_BASE_URL}/v1/app-user/${officerGuid}`, updatedData);
      const response = await patch<AppUser>(dispatch, parameters);

      if (response) {
        return "success";
      }
      return "error";
    } catch (error) {
      //-- handle errors
      return "error";
    }
  };

//-- selectors

export const selectOfficers = (state: RootState): AppUser[] | null => {
  const { officers: officerRoot } = state;
  const { officers } = officerRoot;

  return officers;
};

export const searchOfficers =
  (input: string, agency: string, complaintType: string) =>
  (state: RootState): Array<AppUser> => {
    const {
      officers: { officers: items },
    } = state;

    let results: Array<AppUser> = [];
    const searchInput = input.toLowerCase();
    const role = mapAgencyToRole(agency);
    //-- look for any officers that match firstname, lastname, or office
    if (input.length >= 2) {
      results = items.filter((officer) => {
        const { first_name: firstName, last_name: lastName, office_guid, user_roles } = officer;
        // Safely handle office_guid and cos_geo_org_unit
        const fromAdminOffice = office_guid?.cos_geo_org_unit?.administrative_office_ind ?? undefined; // Will be undefined if cos_geo_org_unit is null or undefined

        const nameMatch =
          firstName.toLocaleLowerCase().includes(searchInput) || lastName.toLocaleLowerCase().includes(searchInput);
        const roleMatch = user_roles.includes(role) && !user_roles.includes(Roles.READ_ONLY);
        if (complaintType !== "HWCR" && user_roles.includes(Roles.HWCR_ONLY)) {
          //Don't include HWCR_ONLY users if the complaint is not an HWCR
          return false;
        } else if (agency === "COS") {
          return !fromAdminOffice && nameMatch && roleMatch;
        } else if (agency === "EPO" || agency === "PARKS") {
          return roleMatch && nameMatch;
        } else {
          return false;
        }
      });
    }

    return results;
  };

// find officers that have an office in the given zone
export const selectOfficersByZone =
  (zone?: string) =>
  (state: RootState): AppUser[] | null => {
    const { officers: officerRoot } = state;
    const { officers } = officerRoot;

    if (zone) {
      return officers.filter((officer) => {
        // check for nulls
        const zoneCode = officer?.office_guid?.cos_geo_org_unit?.zone_code ?? null;
        return zone === zoneCode;
      });
    }

    return [];
  };

// find officers that have an office in the given agency
const mapAgencyToRole = (agency: string): string => {
  let role: string = "";
  if (agency === "COS") {
    role = "COS";
  } else if (agency === "EPO") {
    role = "CEEB";
  } else if (agency === "PARKS") {
    role = "PARKS";
  }
  return role;
};

export const filterOfficerByAgency = (agency: string, officers: AppUser[]): AppUser[] => {
  const role = mapAgencyToRole(agency);
  const result = officers.filter((officer) => {
    const { office_guid, user_roles } = officer;

    // Safely handle office_guid and cos_geo_org_unit
    const fromAdminOffice = office_guid?.cos_geo_org_unit?.administrative_office_ind ?? false; // Assume false if cos_geo_org_unit is null or undefined
    const roleMatch = user_roles.includes(role) && !user_roles.includes(Roles.READ_ONLY);

    //Deactivated officers has empty roles,
    //so the only way to  determine agency is based on whether office_guid null/not null for now
    let agencyCodeForDeactivatedOfficer;
    if (officer.deactivate_ind) {
      if (officer.office_guid) {
        agencyCodeForDeactivatedOfficer = "COS";
      } else {
        agencyCodeForDeactivatedOfficer = "EPO";
      }
    }

    if (agency === "COS") {
      if (officer.deactivate_ind) {
        return agency === agencyCodeForDeactivatedOfficer;
      } else return !fromAdminOffice && roleMatch;
    } else if (agency === "EPO") {
      let result = officer.deactivate_ind === true ? agency === agencyCodeForDeactivatedOfficer : roleMatch;
      return result;
    } else if (agency === "PARKS") {
      //Cannot handle deactivated officers for parks... will be addressed once we understand if Parks users have offices
      return roleMatch;
    } else {
      return false;
    }
  });
  return result;
};

export const selectOfficersByAgency = createSelector(
  (state: RootState) => state.officers.officers,
  (state: RootState, agency: string) => agency,
  (officers, agency) => {
    return filterOfficerByAgency(agency, officers);
  },
);

export const selectOfficersAndCollaboratorsByAgency = createSelector(
  (state: RootState) => state.officers.officers,
  (state: RootState) => state.complaints.complaintCollaborators as Collaborator[],
  (state: RootState, agency: string) => agency,
  (officers, complaintCollaborators, agency): AppUser[] => {
    // First let's trim down to only the officers for a specific agency
    const officersByAgency = filterOfficerByAgency(agency, officers);
    const officerGuids = new Set(officersByAgency.map((officer) => officer.auth_user_guid));

    // Map Collaborators into Officer object so we are dealing with a single type
    const extraOfficersFromCollaborators = complaintCollaborators
      .filter((c) => !officerGuids.has(c.authUserGuid)) // only add if not already in list
      .map((c) => {
        // Try to find the full officer data based on authUserGuid
        return officers.find((o) => o.auth_user_guid === c.authUserGuid);
      })
      .filter((o): o is AppUser => o !== undefined); // remove undefined so we can guarantee the return type

    return [...officersByAgency, ...extraOfficersFromCollaborators];
  },
);

export const selectOfficerListByAgency = createSelector(
  [selectOfficers, selectComplaint],
  (officers, complaint): Array<Option> => {
    if (complaint?.ownedBy) {
      const officerList = filterOfficerByAgency(complaint.ownedBy, officers || []);
      const officerDropdown = officerList.map((officer: AppUser) => ({
        value: officer.auth_user_guid,
        label: `${officer.last_name}, ${officer.first_name}`,
      }));
      return officerDropdown;
    }
    return [];
  },
);

export const selectOfficerAndCollaboratorListByAgency = createSelector(
  [selectOfficers, selectComplaint, selectComplaintCollaborators],
  (officers, complaint, collaborators): Array<Option> => {
    if (complaint?.ownedBy) {
      const officerList = filterOfficerByAgency(complaint.ownedBy, officers ?? []);

      const officerOptions = officerList.map((officer: AppUser) => ({
        value: officer.auth_user_guid,
        label: `${officer.last_name}, ${officer.first_name}`,
      }));

      const collaboratorOptions = collaborators.map((collaborator: Collaborator) => ({
        value: collaborator.authUserGuid,
        label: `${collaborator.lastName}, ${collaborator.firstName}`,
        labelElement: renderLabelElement(collaborator),
      }));

      return [...collaboratorOptions, ...officerOptions].filter(
        (current, index, self) => index === self.findIndex((item) => item.value === current.value),
      );
    }
    return [];
  },
);

export const selectOfficersByAgencyDropdownUsingPersonGuid =
  (agency: string, complaintType: string) =>
  (state: RootState): Array<Option> => {
    const { officers: officerRoot } = state;
    const { officers } = officerRoot;
    const officerList = filterOfficerByAgency(agency, officers);
    const officerDropdown = officerList
      .filter(
        (officer: AppUser) => complaintType === COMPLAINT_TYPES.HWCR || !officer.user_roles.includes(Roles.HWCR_ONLY),
      ) // Keep the officer if the complaint type is HWCR or if they don't have the HWCR_ONLY role for non-HWCR.
      .map((officer: AppUser) => ({
        value: officer.app_user_guid,
        label: `${officer.last_name}, ${officer.first_name}`,
      }));

    return officerDropdown;
  };

export const selectOfficersByReportedBy =
  (reportedBy: string) =>
  (state: RootState): AppUser[] | null => {
    const { officers: officerRoot } = state;
    const { officers } = officerRoot;

    return officers.filter((officer) => {
      // check for nulls
      const reportedByCode = officer?.office_guid?.reported_by_code?.reported_by_code ?? null;
      return reportedBy === reportedByCode;
    });
  };

export const selectOfficersByZoneAgencyAndRole =
  (agency: string, zone?: string, park_area_guids?: string[]) =>
  (state: RootState): AppUser[] | null => {
    const { officers: officerRoot } = state;
    const { officers } = officerRoot;

    const role = mapAgencyToRole(agency);
    let result: boolean = false;

    if (agency === "COS") {
      if (zone) {
        return officers.filter((officer) => {
          const zoneCode = officer?.office_guid?.cos_geo_org_unit?.zone_code ?? null;
          const agencyCode = officer?.office_guid?.agency_code_ref ?? null;
          const fromAdminOffice = officer?.office_guid?.cos_geo_org_unit?.administrative_office_ind;
          const zoneAgencyMatch = zone === zoneCode && (agency === agencyCode || !agency);
          const roleMatch =
            officer?.user_roles.includes(role) &&
            !officer?.user_roles.includes(Roles.READ_ONLY) &&
            !officer?.user_roles.includes(Roles.HWCR_ONLY);
          result = !fromAdminOffice && zoneAgencyMatch && roleMatch;
          return result;
        });
      }
    } else if (agency === "EPO") {
      //only include officers who have the agency of "EPO" and do not have the read only role
      return officers.filter((officer) => {
        result = officer?.user_roles.includes(role) && !officer?.user_roles.includes(Roles.READ_ONLY);
        return result;
      });
    } else if (agency === "PARKS") {
      //only include officers that meet the criteria
      return officers.filter((officer) => {
        const hasRole = officer?.user_roles.includes(role);
        const isNotReadOnly = !officer?.user_roles.includes(Roles.READ_ONLY);
        const matchesParkArea =
          Array.isArray(park_area_guids) && park_area_guids.length > 0 && officer.park_area_guid
            ? park_area_guids.includes(officer.park_area_guid)
            : true;

        return hasRole && isNotReadOnly && matchesParkArea;
      });
    }
    return [];
  };

export const selectOfficerByIdir =
  (idir: string) =>
  (state: RootState): AppUser | null => {
    const {
      officers: { officers: data },
    } = state;
    const selected = data.find(({ user_id }) => user_id === idir);

    if (selected?.app_user_guid) {
      return selected;
    }

    return null;
  };

export const selectOfficerByAuthUserGuid =
  (userGuid: string) =>
  (state: RootState): AppUser | null => {
    const {
      officers: { officers: data },
    } = state;
    const selected = data.find(({ auth_user_guid }) => auth_user_guid === userGuid);

    if (selected?.auth_user_guid) {
      return selected;
    }

    return null;
  };

export const selectOfficerByPersonGuid =
  (appUserGuid: string | undefined) =>
  (state: RootState): AppUser | null => {
    const {
      officers: { officers: data },
    } = state;
    if (appUserGuid) {
      const selected = data.find(({ app_user_guid }) => app_user_guid === appUserGuid);
      if (selected?.app_user_guid) {
        return selected;
      }
    }

    return null;
  };

export const selectCurrentOfficer = createSelector(
  (state: RootState) => state.app.profile.idir_username,
  (state: RootState) => state.officers.officers,
  (idir, officers): AppUser | null => {
    const selected = officers.find(({ user_id }) => user_id === idir);
    return selected || null;
  },
);

export default officerSlice.reducer;
