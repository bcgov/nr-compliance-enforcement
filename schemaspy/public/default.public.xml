<?xml version="1.0" encoding="UTF-8"?><database name="default" schema="public" type="PostgreSQL - 16.4 (Debian 16.4-1.pgdg110+2)">
   <sequences>
      <sequence increment="1" name="complaint_sequence" startValue="40000"/>
   </sequences>
   <tables>
      <table name="action_taken" remarks="Contains information about who the call centre staff contacted and when to allow Officers to know who to follow up with and/or if someone else is already taking action." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="action_taken_guid" nullable="false" remarks="System generated unique key for an action taken record.  This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="complaint_identifier" nullable="true" remarks="Natural key for a complaint generated by webEOC.  Format is YY-###### where the number portion of the sequence resets to 0 on the new year.  Either a complaint_update_guid or a complaint_identifier must be present on the record." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="complaint_update_guid" nullable="true" remarks="System generated unique key for a COMPLAINT_UPDATE.  This key should never be exposed to users via any system utilizing the tables.   Either a complaint_update_guid or a complaint_identifier must be present on the record." size="2147483647" type="uuid" typeCode="1111">
            <parent column="complaint_update_guid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="complaint_update"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="action_details_txt" nullable="true" remarks="Text about who the call centre staff contacted and when" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="logged_by_txt" nullable="true" remarks="The name of the webEOC User that recorded the ACTION_TAKEN" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="action_utc_timestamp" nullable="true" remarks="The date from webEOC that the ACTION_TAKEN was recorded.   The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="create_user_id" nullable="false" remarks="The id of the user that created the ACTION_TAKEN" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the ACTION_TAKEN was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="update_user_id" nullable="false" remarks="The id of the user that updated the ACTION_TAKEN" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="9" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the ACTION_TAKEN was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="action_taken_guid" sequenceNumberInPK="1"/>
         <index name="PK_action_taken_guid" unique="true">
            <column ascending="true" name="action_taken_guid"/>
         </index>
         <checkConstraint constraint="(((complaint_identifier IS NOT NULL) OR (complaint_update_guid IS NOT NULL)))" name="action_taken_check"/>
      </table>
      <table name="action_taken_h" remarks="History table for complaint table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_action_taken_guid" nullable="false" remarks="System generated unique key for complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the complaint that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the complaint table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_action_taken_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_action_taken_guid" unique="true">
            <column ascending="true" name="h_action_taken_guid"/>
         </index>
      </table>
      <table name="agency_code" remarks="An agency is an organized and named grouping of people that interacts in some way with the Ministry." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="agency_code" nullable="false" remarks="A human readable code used to identify an agency." size="10" type="varchar" typeCode="12">
            <child column="agency_code" foreignKey="FK_comp_mthd_recv_cd_agcy_cd_xref_agencycode" implied="false" onDeleteCascade="false" schema="public" table="comp_mthd_recv_cd_agcy_cd_xref"/>
            <child column="owned_by_agency_code" foreignKey="FK_complaint_owned_by_agencycode" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
            <child column="agency_code" foreignKey="FK_complaint_type_code_agency_code" implied="false" onDeleteCascade="false" schema="public" table="complaint_type_code"/>
            <child column="agency_code" foreignKey="FK_agencycode" implied="false" onDeleteCascade="false" schema="public" table="feature_agency_xref"/>
            <child column="agency_code" foreignKey="FK_gorgustrct_agencycode" implied="false" onDeleteCascade="false" schema="public" table="geo_org_unit_structure"/>
            <child column="agency_code" foreignKey="team_agency_code_fk" implied="false" onDeleteCascade="false" schema="public" table="team"/>
            <child column="agency_code" foreignKey="FK_violation_agency_xref__agency_code" implied="false" onDeleteCascade="false" schema="public" table="violation_agency_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the agency code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the agency code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the agency code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the agency code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the agency code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the agency was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the agency code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the agency was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="agency_code" sequenceNumberInPK="1"/>
         <index name="PK_agengycode" unique="true">
            <column ascending="true" name="agency_code"/>
         </index>
      </table>
      <table name="allegation_complaint" remarks="A complaint for which a caller believes that a Violation has occurred and should be investigated." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="allegation_complaint_guid" nullable="false" remarks="System generated unique key for an allegation complaint. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="in_progress_ind" nullable="false" remarks="True if the alleged violation is currently described as being in progress.  False otherwise." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="observed_ind" nullable="false" remarks="True if the alleged violation was observed first hand.  False otherwise." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="suspect_witnesss_dtl_text" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the allegation complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the allegation complaint was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the allegation complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the allegation complaint was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="complaint_identifier" nullable="false" remarks="Natural key for a complaint generated by webEOC." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_algtncmplt_complaint" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="violation_code" nullable="true" remarks="A human readable code used to identify a violation." size="10" type="varchar" typeCode="12">
            <parent column="violation_code" foreignKey="FK_algtncmplt_violatncd" implied="false" onDeleteCascade="false" schema="public" table="violation_code"/>
         </column>
         <primaryKey column="allegation_complaint_guid" sequenceNumberInPK="1"/>
         <index name="PK_algtncmplt" unique="true">
            <column ascending="true" name="allegation_complaint_guid"/>
         </index>
         <index name="UQ_algtncmplt" unique="true">
            <column ascending="true" name="complaint_identifier"/>
         </index>
      </table>
      <table name="allegation_complaint_h" remarks="History table for allegation_complaint table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_algtncmplt_guid" nullable="false" remarks="System generated unique key for allegation complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the allegation complaint that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the allegation complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the allegation complaint table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_algtncmplt_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_algtncmplt" unique="true">
            <column ascending="true" name="h_algtncmplt_guid"/>
         </index>
      </table>
      <table name="attractant_code" remarks="A human factor contributing to a Human Wildlife Conflict (E.g. RESFRUIT = Residential Fruit/Berries; LVSFEED = Livestock Feed)" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="attractant_code" nullable="false" remarks="A human readable code used to identify an attractant." size="10" type="varchar" typeCode="12">
            <child column="attractant_code" foreignKey="FK_attrhwcrx_atractntcd" implied="false" onDeleteCascade="false" schema="public" table="attractant_hwcr_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the attractant code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the attractant code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the attractant code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the attractant code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the attractant code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the attractant code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the attractant code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the attractant code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="attractant_code" sequenceNumberInPK="1"/>
         <index name="PK_atractntcd" unique="true">
            <column ascending="true" name="attractant_code"/>
         </index>
      </table>
      <table name="attractant_hwcr_xref" remarks="Cross reference table for linking attractants to HWCR Complaints." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="attractant_hwcr_xref_guid" nullable="false" remarks="System generated unique key for an attractant hwcr relationship. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="attractant_code" nullable="false" remarks="A human readable code used to identify an attractant." size="10" type="varchar" typeCode="12">
            <parent column="attractant_code" foreignKey="FK_attrhwcrx_atractntcd" implied="false" onDeleteCascade="false" schema="public" table="attractant_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="hwcr_complaint_guid" nullable="false" remarks="System generated unique key for a hwcr complaint." size="2147483647" type="uuid" typeCode="1111">
            <parent column="hwcr_complaint_guid" foreignKey="FK_attrhwcrx_hwcrcmplnt" implied="false" onDeleteCascade="false" schema="public" table="hwcr_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="create_user_id" nullable="false" remarks="The id of the user that created the attractant hwcr cross reference." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the attractant hwcr cross reference was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="update_user_id" nullable="false" remarks="The id of the user that updated the attractant hwcr cross reference." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the attractant hwcr cross reference was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="7" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="attractant_hwcr_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_attrhwcrx" unique="true">
            <column ascending="true" name="attractant_hwcr_xref_guid"/>
         </index>
         <index name="FK_hwcrcmplntguid" unique="false">
            <column ascending="true" name="hwcr_complaint_guid"/>
         </index>
      </table>
      <table name="attractant_hwcr_xref_h" remarks="History table for attractant_hwcr_xref table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_attrhwcrx_guid" nullable="false" remarks="System generated unique key for attractant hwcr xref history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the attractant hwcr xref that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the attractant hwcr xref table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the attractant hwcr xref table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_attrhwcrx_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_attrhwcrx" unique="true">
            <column ascending="true" name="h_attrhwcrx_guid"/>
         </index>
      </table>
      <table name="comp_mthd_recv_cd_agcy_cd_xref" remarks="complaint_method_received_code and AGENCIES that allow for features to be displayed or hidden as required." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="comp_mthd_recv_cd_agcy_cd_xref_guid" nullable="false" remarks="" size="2147483647" type="uuid" typeCode="1111">
            <child column="comp_mthd_recv_cd_agcy_cd_xref_guid" foreignKey="complaint_comp_mthd_recv_cd_agcy_cd_xref_fk" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="agency_code" nullable="false" remarks="A human readable code used to identify an AGENCY." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_comp_mthd_recv_cd_agcy_cd_xref_agencycode" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="complaint_method_received_code" nullable="false" remarks="A human readable code used to identify a complaint_method_received_code that is controlled by the comp_mthd_recv_cd_agcy_cd_xref table." size="10" type="varchar" typeCode="12">
            <parent column="complaint_method_received_code" foreignKey="FK_comp_mthd_recv_cd_agcy_cd_xref_complaint_method_received_cod" implied="false" onDeleteCascade="false" schema="public" table="complaint_method_received_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the complaint_method_received_code should be rendered the for users in the given AGENCY" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the complaint_method_received_code / AGENCY mapping." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the complaint_method_received_code / AGENCY mapping was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the complaint_method_received_code / AGENCY mapping" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the complaint_method_received_code / AGENCY mapping was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="comp_mthd_recv_cd_agcy_cd_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_comp_mthd_recv_cd_agcy_cd_xref" unique="true">
            <column ascending="true" name="comp_mthd_recv_cd_agcy_cd_xref_guid"/>
         </index>
         <index name="UK_comp_mthd_recv_cd_agcy_cd_xref" unique="true">
            <column ascending="true" name="agency_code"/>
            <column ascending="true" name="complaint_method_received_code"/>
         </index>
      </table>
      <table name="complaint" remarks="Initial information provided on a potential incident." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="complaint_identifier" nullable="false" remarks="" size="20" type="varchar" typeCode="12">
            <child column="complaint_identifier" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="action_taken"/>
            <child column="complaint_identifier" foreignKey="FK_algtncmplt_complaint" implied="false" onDeleteCascade="false" schema="public" table="allegation_complaint"/>
            <child column="complaint_identifier" foreignKey="complaint_update_fk" implied="false" onDeleteCascade="false" schema="public" table="complaint_update"/>
            <child column="complaint_identifier" foreignKey="FK_gircmplnt_complaint" implied="false" onDeleteCascade="false" schema="public" table="gir_complaint"/>
            <child column="complaint_identifier" foreignKey="FK_hwcrcmplnt_complaint" implied="false" onDeleteCascade="false" schema="public" table="hwcr_complaint"/>
            <child column="complaint_identifier" foreignKey="FK_lnkcmplxref_complaint" implied="false" onDeleteCascade="false" schema="public" table="linked_complaint_xref"/>
            <child column="linked_complaint_identifier" foreignKey="FK_lnkcmplxref_linked_complaint" implied="false" onDeleteCascade="false" schema="public" table="linked_complaint_xref"/>
            <child column="complaint_identifier" foreignKey="FK_person_complaint_xref__complaint_identifier" implied="false" onDeleteCascade="false" schema="public" table="person_complaint_xref"/>
            <child column="complaint_identifier" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="staging_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="detail_text" nullable="true" remarks="Verbatim details of the complaint as recorded by the call centre or through the web form." size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="caller_name" nullable="true" remarks="The name provided by the caller to the call centre or entered onto the web form." size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="caller_address" nullable="true" remarks="The address provided by the caller to the call centre or entered onto the web form." size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="caller_email" nullable="true" remarks="The email address provided by the caller to the call centre or entered onto the web form." size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="caller_phone_1" nullable="true" remarks="The primary phone number provided by the caller to the call centre or entered onto the web form." size="15" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="caller_phone_2" nullable="true" remarks="An alternate phone number provided by the caller to the call centre or entered onto the web form." size="15" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="caller_phone_3" nullable="true" remarks="An alternate phone number provided by the caller to the call centre or entered onto the web form." size="15" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="location_summary_text" nullable="true" remarks="A brief summary of the location of the complaint." size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="location_detailed_text" nullable="true" remarks="A more detailed description of the location of the complaint." size="4000" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="10" name="incident_utc_datetime" nullable="true" remarks="The date and time at which the complaint occurred." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="11" name="incident_reported_utc_timestmp" nullable="true" remarks="The date and time at which the complaint was reported." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="reported_by_other_text" nullable="true" remarks="Provides a more detailed description when the referred by Agency is of type &quot;OTHER&quot;" size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="create_user_id" nullable="false" remarks="The id of the user that created the complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="14" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the complaint was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="update_user_id" nullable="false" remarks="The id of the user that updated the complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="16" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the complaint was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="reported_by_code" nullable="true" remarks="A human readable code used to identify an agency.  The agency that originally referred the complaint." size="10" type="varchar" typeCode="12">
            <parent column="reported_by_code" foreignKey="FK_complaint_reported_by_code" implied="false" onDeleteCascade="false" schema="public" table="reported_by_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="owned_by_agency_code" nullable="true" remarks="A human readable code used to identify an agency.  The agency that currently owns the complaint." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_complaint_owned_by_agencycode" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="complaint_status_code" nullable="true" remarks="A human readable code used to identify a complaint status." size="10" type="varchar" typeCode="12">
            <parent column="complaint_status_code" foreignKey="FK_complaint_compntstscd" implied="false" onDeleteCascade="false" schema="public" table="complaint_status_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="geo_organization_unit_code" nullable="true" remarks="A human readable code used to identify a geographical organization unit.   The finest known grain geographical organization unit where the complaint occurred." size="10" type="varchar" typeCode="12">
            <parent column="geo_organization_unit_code" foreignKey="FK_complaint_geoorgutnd" implied="false" onDeleteCascade="false" schema="public" table="geo_organization_unit_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="location_geometry_point" nullable="true" remarks="The closest approximation to where the incident occurred. Stored as a geometric point using the EPSG:3005 Projected Coordinate System (BC Albers)" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="22" name="webeoc_identifier" nullable="true" remarks="Unique Identifier from the webEOC source system to identify a complaint update.   This is required as the natural key is not available in all webEOC APIs" size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="comp_mthd_recv_cd_agcy_cd_xref_guid" nullable="true" remarks="Methods in which the complaint was received.  Examples include: DGIR forward, Direct email or phone call,Minister's office,RAPP ,Referral" size="2147483647" type="uuid" typeCode="1111">
            <parent column="comp_mthd_recv_cd_agcy_cd_xref_guid" foreignKey="complaint_comp_mthd_recv_cd_agcy_cd_xref_fk" implied="false" onDeleteCascade="false" schema="public" table="comp_mthd_recv_cd_agcy_cd_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="'U'::bpchar" digits="0" id="24" name="is_privacy_requested" nullable="true" remarks="flag to represent that the caller has asked for special care when handling their personal information" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="reference_number" nullable="true" remarks="Allows users to link complaints to files in external systems.   Currently labeled in the system as COORS reference number and initially only used for COORS linkages." size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="26" name="comp_last_upd_utc_timestamp" nullable="true" remarks="The time the complaint was last updated, or null if the complaint has never been touched.  This value might also be updated by business logic that touches sub-tables to indicate that the business object complaint has been updated." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="complaint_identifier" sequenceNumberInPK="1"/>
         <index name="PK_complaint" unique="true">
            <column ascending="true" name="complaint_identifier"/>
         </index>
         <index name="IDX_adbfa452bdecec83d2daf17d18" unique="false">
            <column ascending="true" name="location_geometry_point"/>
         </index>
         <checkConstraint constraint="((is_privacy_requested = ANY (ARRAY['Y'::bpchar, 'N'::bpchar, 'U'::bpchar])))" name="complaint_is_privacy_requested"/>
      </table>
      <table name="complaint_h" remarks="History table for complaint table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_complaint_guid" nullable="false" remarks="System generated unique key for complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the complaint that has been created or modified." size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the complaint table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_complaint_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_complaint" unique="true">
            <column ascending="true" name="h_complaint_guid"/>
         </index>
      </table>
      <table name="complaint_method_received_code" remarks="Methods in which the complaint was received.  Examples include: DGIR forward, Direct email or phone call,Minister's office,RAPP ,Referral" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="complaint_method_received_code" nullable="false" remarks="A human readable code used to define the method in which the complaint was received" size="10" type="varchar" typeCode="12">
            <child column="complaint_method_received_code" foreignKey="FK_comp_mthd_recv_cd_agcy_cd_xref_complaint_method_received_cod" implied="false" onDeleteCascade="false" schema="public" table="comp_mthd_recv_cd_agcy_cd_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of a METHOD_COMPLAINT_RECEIVED_CODE" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of a METHOD_COMPLAINT_RECEIVED_CODE" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the METHOD_COMPLAINT_RECEIVED_CODE is active" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the wdr schedule code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the METHOD_COMPLAINT_RECEIVED_CODE was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the METHOD_COMPLAINT_RECEIVED_CODE." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the METHOD_COMPLAINT_RECEIVED_CODE was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="complaint_method_received_code" sequenceNumberInPK="1"/>
         <index name="PK_complaint_method_received_code" unique="true">
            <column ascending="true" name="complaint_method_received_code"/>
         </index>
      </table>
      <table name="complaint_status_code" remarks="The status of a Complaint.  Values include OPEN = Open and CLOSED = Closed." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="complaint_status_code" nullable="false" remarks="A human readable code used to identify a complaint status." size="10" type="varchar" typeCode="12">
            <child column="complaint_status_code" foreignKey="FK_complaint_compntstscd" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the complaint status code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the complaint status code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the complaint status code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the complaint status code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the complaint status code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the  complaint status code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the complaint status code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the complaint status code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="9" name="manually_assignable_ind" nullable="false" remarks="Indicates if the stastus code can be manually assigned by a user." size="1" type="bool" typeCode="-7"/>
         <primaryKey column="complaint_status_code" sequenceNumberInPK="1"/>
         <index name="PK_cmpntstscd" unique="true">
            <column ascending="true" name="complaint_status_code"/>
         </index>
      </table>
      <table name="complaint_type_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="complaint_type_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="create_user_guid" nullable="true" remarks="" size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="update_user_guid" nullable="true" remarks="" size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="10" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="'COS'::character varying" digits="0" id="11" name="agency_code" nullable="false" remarks="A human readable code used to identify an agency." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_complaint_type_code_agency_code" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <primaryKey column="complaint_type_code" sequenceNumberInPK="1"/>
         <index name="PK_complainttypecode" unique="true">
            <column ascending="true" name="complaint_type_code"/>
         </index>
      </table>
      <table name="complaint_update" remarks="Callers will sometimes call in with a COMPLAINT_UPDATE.   This table is used to track items that are considered to be amendments to the complaint information such as additional details, or location information." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="complaint_update_guid" nullable="false" remarks="System generated unique key for a complaint update.  This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <child column="complaint_update_guid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="action_taken"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="complaint_identifier" nullable="false" remarks="Natural key for a complaint generated by webEOC.  Format is YY-250744772125074477212507447721 where the number portion of the sequence resets to 0 on the new year." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="complaint_update_fk" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="update_seq_number" nullable="false" remarks="An integer that is used to reflect the order that complaint updates were entered into the call center system." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="upd_detail_text" nullable="true" remarks="Verbatim details of the complaint as recorded by the call centre or through the web form." size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="upd_location_summary_text" nullable="true" remarks="A brief summary of the location of the complaint." size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="upd_location_detailed_text" nullable="true" remarks="A more detailed description of the location of the complaint." size="4000" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="upd_location_geometry_point" nullable="true" remarks="The closest approximation to where the incident occurred.   Stored as a geometric point using the EPSG:3005 Projected Coordinate System (BC Albers)" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="create_user_id" nullable="false" remarks="The id of the user that created the complaint update record." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the complaint update record was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="update_user_id" nullable="false" remarks="The id of the user that updated the complaint update record." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="10" name="update_utc_timestamp" nullable="true" remarks="The timestamp when the complaint_update record was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="webeoc_identifier" nullable="true" remarks="Unique Identifier from the webEOC source system to identify a complaint update.   This is required as the natural key is not available in all webEOC APIs" size="20" type="varchar" typeCode="12"/>
         <primaryKey column="complaint_update_guid" sequenceNumberInPK="1"/>
         <index name="complaint_update_pk" unique="true">
            <column ascending="true" name="complaint_update_guid"/>
         </index>
      </table>
      <table name="complaint_update_h" remarks="History table for complaint_update table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_complaint_update_guid" nullable="false" remarks="System generated unique key for complaint update history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the complaint update that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the complaint update table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the complaint update table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_complaint_update_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_complaint_update" unique="true">
            <column ascending="true" name="h_complaint_update_guid"/>
         </index>
      </table>
      <table name="configuration" remarks="The configuration table is used to store constants which are expected to change over the lifecycle of the application, or have different values in different environments.   By making changes to in the database the behaviour of the application can be altered without requiring a full deployment." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="configuration_code" nullable="false" remarks="A human readable code used to identify an configuration entry." size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="configuration_value" nullable="false" remarks="The value of the configuration entry." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="false" remarks="The long description of the configuration entry." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the configuration_entry is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the configuration entry." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the configuration entry was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the configuration entry." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="true" remarks="The timestamp when the configuration entry was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="configuration_code" sequenceNumberInPK="1"/>
         <index name="configuration_pk" unique="true">
            <column ascending="true" name="configuration_code"/>
         </index>
      </table>
      <table name="configuration_h" remarks="History table for configuration table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_configuration_guid" nullable="false" remarks="System generated unique key for configuration history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the configuration that has been created or modified." size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the configuration table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the configuration table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_configuration_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_configuration" unique="true">
            <column ascending="true" name="h_configuration_guid"/>
         </index>
      </table>
      <table name="cos_geo_org_unit_flat_mvw" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT DISTINCT gou.geo_organization_unit_code AS region_code,&#10;    gou.short_description AS region_name,&#10;    gou2.geo_organization_unit_code AS zone_code,&#10;    gou2.short_description AS zone_name,&#10;    gou3.geo_organization_unit_code AS offloc_code,&#10;    gou3.short_description AS offloc_name,&#10;    (COALESCE(gou4.geo_organization_unit_code, NULL::character varying))::character varying(10) AS area_code,&#10;    (COALESCE(gou4.short_description, NULL::character varying))::character varying(50) AS area_name,&#10;    gou3.administrative_office_ind&#10;   FROM (((((((geo_org_unit_structure gos&#10;     JOIN geo_organization_unit_code gou ON (((gos.parent_geo_org_unit_code)::text = (gou.geo_organization_unit_code)::text)))&#10;     JOIN geo_org_unit_structure gos2 ON (((gos2.parent_geo_org_unit_code)::text = (gou.geo_organization_unit_code)::text)))&#10;     JOIN geo_organization_unit_code gou2 ON (((gos2.child_geo_org_unit_code)::text = (gou2.geo_organization_unit_code)::text)))&#10;     JOIN geo_org_unit_structure gos3 ON (((gos3.parent_geo_org_unit_code)::text = (gou2.geo_organization_unit_code)::text)))&#10;     JOIN geo_organization_unit_code gou3 ON (((gos3.child_geo_org_unit_code)::text = (gou3.geo_organization_unit_code)::text)))&#10;     LEFT JOIN geo_org_unit_structure gos4 ON (((gos4.parent_geo_org_unit_code)::text = (gou3.geo_organization_unit_code)::text)))&#10;     LEFT JOIN geo_organization_unit_code gou4 ON (((gos4.child_geo_org_unit_code)::text = (gou4.geo_organization_unit_code)::text)))&#10;  WHERE (((gou.geo_org_unit_type_code)::text = 'REGION'::text) AND ((gou2.geo_org_unit_type_code)::text = 'ZONE'::text) AND ((gou3.geo_org_unit_type_code)::text = 'OFFLOC'::text) AND (((gou4.geo_org_unit_type_code)::text = 'AREA'::text) OR (gou4.geo_org_unit_type_code IS NULL)) AND ((gos.agency_code)::text = 'COS'::text));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="region_code" nullable="true" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="region_name" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="zone_code" nullable="true" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="zone_name" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="offloc_code" nullable="true" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="offloc_name" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="area_code" nullable="true" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="area_name" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="administrative_office_ind" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
      </table>
      <table name="entity_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="entity_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <child column="entity_code" foreignKey="staging_staging_metadata_mapping_entity_code" implied="false" onDeleteCascade="false" schema="public" table="staging_metadata_mapping"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="entity_code" sequenceNumberInPK="1"/>
         <index name="PK_entity_code" unique="true">
            <column ascending="true" name="entity_code"/>
         </index>
      </table>
      <table name="feature_agency_xref" remarks="Maintains a mapping between FEATURES and AGENCIES that allow for features to be displayed or hidden as required." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="feature_agency_xref_guid" nullable="false" remarks="System generated unique key for a FEATURE_AGENCY_XREF ecord.  This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="feature_code" nullable="false" remarks="A human readable code used to identify a FEATURE that is controlled by the FEATURE_AGENCY_XREF table." size="10" type="varchar" typeCode="12">
            <parent column="feature_code" foreignKey="FK_featurecd" implied="false" onDeleteCascade="false" schema="public" table="feature_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="agency_code" nullable="false" remarks="A human readable code used to identify an AGENCY." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_agencycode" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the FEATURE should be rendered the for users in the given AGENCY" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the FEATURE / AGENCY mapping." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the FEATURE / AGENCY mapping was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the FEATURE / AGENCY mapping" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the FEATURE / AGENCY mapping was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="feature_agency_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_featagcyxr" unique="true">
            <column ascending="true" name="feature_agency_xref_guid"/>
         </index>
         <index name="UK_unique_feature_agency" unique="true">
            <column ascending="true" name="feature_code"/>
            <column ascending="true" name="agency_code"/>
         </index>
      </table>
      <table name="feature_code" remarks="A list of FEATUREs that can be enabled or disabled on a per agency basis." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="feature_code" nullable="false" remarks="A human readable code used to identify a FEATURE that is controlled by the FEATURE_AGENCY_XREF table." size="10" type="varchar" typeCode="12">
            <child column="feature_code" foreignKey="FK_featurecd" implied="false" onDeleteCascade="false" schema="public" table="feature_agency_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the FEATURE controlled by the flag." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the FEATURE controlled by the flag." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of  the FEATUREs should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the FEATURE is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the FEATURE." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the FEATURE was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the FEATURE" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the FEATURE was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="feature_code" sequenceNumberInPK="1"/>
         <index name="PK_featurecd" unique="true">
            <column ascending="true" name="feature_code"/>
         </index>
      </table>
      <table name="flyway_schema_history" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="installed_rank" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="version" nullable="true" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="description" nullable="false" remarks="" size="200" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="false" remarks="" size="20" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="script" nullable="false" remarks="" size="1000" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="checksum" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="installed_by" nullable="false" remarks="" size="100" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="7" name="installed_on" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="execution_time" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="success" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="installed_rank" sequenceNumberInPK="1"/>
         <index name="flyway_schema_history_pk" unique="true">
            <column ascending="true" name="installed_rank"/>
         </index>
         <index name="flyway_schema_history_s_idx" unique="false">
            <column ascending="true" name="success"/>
         </index>
      </table>
      <table name="geo_org_unit_structure" remarks="A geographical organization unit structure is a parent/child relationship between two geographical organization units." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="geo_org_unit_structure_guid" nullable="false" remarks="System generated unique key for a geographical organization unit structure. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="1" name="effective_date" nullable="false" remarks="The date the Geographical Organizational Unit Structure becomes effective as a valid relationship within the Ministry organizational structure." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="expiry_date" nullable="true" remarks="The date the Geographical Organizational Unit Structure is no longer recognized as a valid relationship within the Ministry organizational structure." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="create_user_id" nullable="false" remarks="The id of the user that created the geographical organization unit structure." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit structure was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="update_user_id" nullable="false" remarks="The id of the user that updated the geographical organization unit structure." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit structure was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="agency_code" nullable="true" remarks="A human readable code used to identify an agency.  The agency that defines the geographical organization unit structural relationship." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_gorgustrct_agencycode" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="parent_geo_org_unit_code" nullable="true" remarks="The geographical organization that contains the child geographical organization unit." size="10" type="varchar" typeCode="12">
            <parent column="geo_organization_unit_code" foreignKey="FK_gorgustrct_parent_geoorgutcd" implied="false" onDeleteCascade="false" schema="public" table="geo_organization_unit_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="child_geo_org_unit_code" nullable="true" remarks="The geographical organization that is contained by the parent geographical organization unit." size="10" type="varchar" typeCode="12">
            <parent column="geo_organization_unit_code" foreignKey="FK_gorgustrct_child_geoorgutcd" implied="false" onDeleteCascade="false" schema="public" table="geo_organization_unit_code"/>
         </column>
         <primaryKey column="geo_org_unit_structure_guid" sequenceNumberInPK="1"/>
         <index name="PK_gorgustrct" unique="true">
            <column ascending="true" name="geo_org_unit_structure_guid"/>
         </index>
         <index name="UQ_gorgustrct" unique="true">
            <column ascending="true" name="parent_geo_org_unit_code"/>
            <column ascending="true" name="child_geo_org_unit_code"/>
         </index>
      </table>
      <table name="geo_org_unit_structure_h" remarks="History table for geo_org_unit_structure table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_gorgustrct_guid" nullable="false" remarks="System generated unique key for geographic organization unit structure history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the geographic organization unit structure that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the geographic organization unit structure table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the geographic organization unit structure table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_gorgustrct_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_gorgustrct" unique="true">
            <column ascending="true" name="h_gorgustrct_guid"/>
         </index>
      </table>
      <table name="geo_org_unit_type_code" remarks="A geographical organization unit type describes the level of granularity for a given geographical organization unit. Supported geographical organization unit types are (ZONE = Zone; REGION = Region; OFFLOC = Office Location; AREA = Area)." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="geo_org_unit_type_code" nullable="false" remarks="A human readable code used to identify a geographical organization unit type." size="10" type="varchar" typeCode="12">
            <child column="geo_org_unit_type_code" foreignKey="FK_geoorgutnd_gorgtypecd" implied="false" onDeleteCascade="false" schema="public" table="geo_organization_unit_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the geographical organization unit type code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the geographical organization unit type code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the geographical organization unit type code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the geographical organization unit type code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the geographical organization unit type code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit type code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the geographical organization unit type code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit type code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="geo_org_unit_type_code" sequenceNumberInPK="1"/>
         <index name="PK_gorgtypecd" unique="true">
            <column ascending="true" name="geo_org_unit_type_code"/>
         </index>
      </table>
      <table name="geo_organization_unit_code" remarks="A geographical organization unit is a named geographical boundary that represents a physical location.   The level of granularity can vary with Regions being the highest level - for example Okanagan, and Areas being the lowest level - for example Big White" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="geo_organization_unit_code" nullable="false" remarks="A human readable code used to identify a geographical organization unit." size="10" type="varchar" typeCode="12">
            <child column="geo_organization_unit_code" foreignKey="FK_complaint_geoorgutnd" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
            <child column="child_geo_org_unit_code" foreignKey="FK_gorgustrct_child_geoorgutcd" implied="false" onDeleteCascade="false" schema="public" table="geo_org_unit_structure"/>
            <child column="parent_geo_org_unit_code" foreignKey="FK_gorgustrct_parent_geoorgutcd" implied="false" onDeleteCascade="false" schema="public" table="geo_org_unit_structure"/>
            <child column="geo_organization_unit_code" foreignKey="FK_office_geoorgutnd" implied="false" onDeleteCascade="false" schema="public" table="office"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="true" remarks="The short description of the geographical organization unit code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the geographical organization unit code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="effective_date" nullable="false" remarks="The date the Geographical Organizational Unit becomes effective as a boundaried physical location within the Ministry organizational structure." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="expiry_date" nullable="true" remarks="The date the Geographical Organizational Unit is no longer recognized as a valid physical location within the Ministry organizational structure." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the geographical organization unit code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the geographical organization unit code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the geographical organization unit code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="geo_org_unit_type_code" nullable="true" remarks="A human readable code used to identify a geographical organization unit type." size="10" type="varchar" typeCode="12">
            <parent column="geo_org_unit_type_code" foreignKey="FK_geoorgutnd_gorgtypecd" implied="false" onDeleteCascade="false" schema="public" table="geo_org_unit_type_code"/>
         </column>
         <column autoUpdated="false" defaultValue="false" digits="0" id="10" name="administrative_office_ind" nullable="false" remarks="Indicates if the unit is a COSHQ Office." size="1" type="bool" typeCode="-7"/>
         <primaryKey column="geo_organization_unit_code" sequenceNumberInPK="1"/>
         <index name="PK_geoorgutnd" unique="true">
            <column ascending="true" name="geo_organization_unit_code"/>
         </index>
      </table>
      <table name="geography_columns" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT current_database() AS f_table_catalog,&#10;    n.nspname AS f_table_schema,&#10;    c.relname AS f_table_name,&#10;    a.attname AS f_geography_column,&#10;    postgis_typmod_dims(a.atttypmod) AS coord_dimension,&#10;    postgis_typmod_srid(a.atttypmod) AS srid,&#10;    postgis_typmod_type(a.atttypmod) AS type&#10;   FROM pg_class c,&#10;    pg_attribute a,&#10;    pg_type t,&#10;    pg_namespace n&#10;  WHERE ((t.typname = 'geography'::name) AND (a.attisdropped = false) AND (a.atttypid = t.oid) AND (a.attrelid = c.oid) AND (c.relnamespace = n.oid) AND (c.relkind = ANY (ARRAY['r'::&quot;char&quot;, 'v'::&quot;char&quot;, 'm'::&quot;char&quot;, 'f'::&quot;char&quot;, 'p'::&quot;char&quot;])) AND (NOT pg_is_other_temp_schema(c.relnamespace)) AND has_table_privilege(c.oid, 'SELECT'::text));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="f_table_catalog" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="f_table_schema" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="f_table_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="f_geography_column" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="coord_dimension" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="srid" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="srid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="spatial_ref_sys"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
      </table>
      <table name="geometry_columns" numRows="0" remarks="" schema="public" type="VIEW" viewSql=" SELECT (current_database())::character varying(256) AS f_table_catalog,&#10;    n.nspname AS f_table_schema,&#10;    c.relname AS f_table_name,&#10;    a.attname AS f_geometry_column,&#10;    COALESCE(postgis_typmod_dims(a.atttypmod), sn.ndims, 2) AS coord_dimension,&#10;    COALESCE(NULLIF(postgis_typmod_srid(a.atttypmod), 0), sr.srid, 0) AS srid,&#10;    (replace(replace(COALESCE(NULLIF(upper(postgis_typmod_type(a.atttypmod)), 'GEOMETRY'::text), st.type, 'GEOMETRY'::text), 'ZM'::text, ''::text), 'Z'::text, ''::text))::character varying(30) AS type&#10;   FROM ((((((pg_class c&#10;     JOIN pg_attribute a ON (((a.attrelid = c.oid) AND (NOT a.attisdropped))))&#10;     JOIN pg_namespace n ON ((c.relnamespace = n.oid)))&#10;     JOIN pg_type t ON ((a.atttypid = t.oid)))&#10;     LEFT JOIN ( SELECT s.connamespace,&#10;            s.conrelid,&#10;            s.conkey,&#10;            replace(split_part(s.consrc, ''''::text, 2), ')'::text, ''::text) AS type&#10;           FROM ( SELECT pg_constraint.connamespace,&#10;                    pg_constraint.conrelid,&#10;                    pg_constraint.conkey,&#10;                    pg_get_constraintdef(pg_constraint.oid) AS consrc&#10;                   FROM pg_constraint) s&#10;          WHERE (s.consrc ~~* '%geometrytype(% = %'::text)) st ON (((st.connamespace = n.oid) AND (st.conrelid = c.oid) AND (a.attnum = ANY (st.conkey)))))&#10;     LEFT JOIN ( SELECT s.connamespace,&#10;            s.conrelid,&#10;            s.conkey,&#10;            (replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text))::integer AS ndims&#10;           FROM ( SELECT pg_constraint.connamespace,&#10;                    pg_constraint.conrelid,&#10;                    pg_constraint.conkey,&#10;                    pg_get_constraintdef(pg_constraint.oid) AS consrc&#10;                   FROM pg_constraint) s&#10;          WHERE (s.consrc ~~* '%ndims(% = %'::text)) sn ON (((sn.connamespace = n.oid) AND (sn.conrelid = c.oid) AND (a.attnum = ANY (sn.conkey)))))&#10;     LEFT JOIN ( SELECT s.connamespace,&#10;            s.conrelid,&#10;            s.conkey,&#10;            (replace(replace(split_part(s.consrc, ' = '::text, 2), ')'::text, ''::text), '('::text, ''::text))::integer AS srid&#10;           FROM ( SELECT pg_constraint.connamespace,&#10;                    pg_constraint.conrelid,&#10;                    pg_constraint.conkey,&#10;                    pg_get_constraintdef(pg_constraint.oid) AS consrc&#10;                   FROM pg_constraint) s&#10;          WHERE (s.consrc ~~* '%srid(% = %'::text)) sr ON (((sr.connamespace = n.oid) AND (sr.conrelid = c.oid) AND (a.attnum = ANY (sr.conkey)))))&#10;  WHERE ((c.relkind = ANY (ARRAY['r'::&quot;char&quot;, 'v'::&quot;char&quot;, 'm'::&quot;char&quot;, 'f'::&quot;char&quot;, 'p'::&quot;char&quot;])) AND (NOT (c.relname = 'raster_columns'::name)) AND (t.typname = 'geometry'::name) AND (NOT pg_is_other_temp_schema(c.relnamespace)) AND has_table_privilege(c.oid, 'SELECT'::text));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="f_table_catalog" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="f_table_schema" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="f_table_name" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="f_geometry_column" nullable="true" remarks="" size="2147483647" type="name" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="coord_dimension" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="srid" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="srid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="spatial_ref_sys"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="type" nullable="true" remarks="" size="30" type="varchar" typeCode="12"/>
      </table>
      <table name="gir_complaint" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="gir_complaint_guid" nullable="false" remarks="System generated unique key for a gir complaint. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="gir_type_code" nullable="true" remarks="A human readable code used to identify a type of GIR complaint." size="10" type="varchar" typeCode="12">
            <parent column="gir_type_code" foreignKey="FK_gircmplnt_cmpltgircd" implied="false" onDeleteCascade="false" schema="public" table="gir_type_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="create_user_id" nullable="false" remarks="The id of the user that created the GIR complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the GIR complaint was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="update_user_id" nullable="false" remarks="The id of the user that updated the GIR complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the GIR complaint was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="complaint_identifier" nullable="false" remarks="Natural key for a complaint generated by webEOC." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_gircmplnt_complaint" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <primaryKey column="gir_complaint_guid" sequenceNumberInPK="1"/>
         <index name="PK_gircmplnt" unique="true">
            <column ascending="true" name="gir_complaint_guid"/>
         </index>
         <index name="UQ_gircmplnt" unique="true">
            <column ascending="true" name="complaint_identifier"/>
         </index>
      </table>
      <table name="gir_complaint_h" remarks="History table for gir_complaint table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_gircmplt_guid" nullable="false" remarks="System generated unique key for GIR complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the GIR complaint that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the GIR complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the GIR complaint table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_gircmplt_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_gircmplt" unique="true">
            <column ascending="true" name="h_gircmplt_guid"/>
         </index>
      </table>
      <table name="gir_type_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="gir_type_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <child column="gir_type_code" foreignKey="FK_gircmplnt_cmpltgircd" implied="false" onDeleteCascade="false" schema="public" table="gir_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="true" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="gir_type_code" sequenceNumberInPK="1"/>
         <index name="PK_girtypecd" unique="true">
            <column ascending="true" name="gir_type_code"/>
         </index>
      </table>
      <table name="hwcr_complaint" remarks="A complaint that a caller believes could involve a conflict between Humans and Wildlife." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="hwcr_complaint_guid" nullable="false" remarks="System generated unique key for a hwcr complaint. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <child column="hwcr_complaint_guid" foreignKey="FK_attrhwcrx_hwcrcmplnt" implied="false" onDeleteCascade="false" schema="public" table="attractant_hwcr_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="other_attractants_text" nullable="true" remarks="Provides a more detailed description when the attractant of type &quot;OTHER&quot; is included." size="4000" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="create_user_id" nullable="false" remarks="The id of the user that created the HWCR complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the HWCR complaint was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="update_user_id" nullable="false" remarks="The id of the user that updated the HWCR complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the HWCR complaint was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="complaint_identifier" nullable="false" remarks="Natural key for a complaint generated by webEOC." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_hwcrcmplnt_complaint" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="species_code" nullable="false" remarks="A human readable code used to identify a wildlife species." size="10" type="varchar" typeCode="12">
            <parent column="species_code" foreignKey="FK_hwcrcmplnt_speciescd" implied="false" onDeleteCascade="false" schema="public" table="species_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="hwcr_complaint_nature_code" nullable="true" remarks="A human readable code used to identify the nature of the Human Wildlife Conflict." size="10" type="varchar" typeCode="12">
            <parent column="hwcr_complaint_nature_code" foreignKey="FK_hwcrcmplnt_cmpltntrcd" implied="false" onDeleteCascade="false" schema="public" table="hwcr_complaint_nature_code"/>
         </column>
         <primaryKey column="hwcr_complaint_guid" sequenceNumberInPK="1"/>
         <index name="PK_hwcrcmplnt" unique="true">
            <column ascending="true" name="hwcr_complaint_guid"/>
         </index>
         <index name="UQ_hwcrcmplnt" unique="true">
            <column ascending="true" name="complaint_identifier"/>
         </index>
      </table>
      <table name="hwcr_complaint_h" remarks="History table for hwcr_complaint table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_hwcrcmplt_guid" nullable="false" remarks="System generated unique key for HWCR complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the HWCR complaint that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the HWCR complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the HWCR complaint table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_hwcrcmplt_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_hwcrcmplt" unique="true">
            <column ascending="true" name="h_hwcrcmplt_guid"/>
         </index>
      </table>
      <table name="hwcr_complaint_nature_code" remarks="Modifier that further describes the nature of Human Wildlife Conflict complaints.   (E.g. DEADNV = Dead wildlife - no violation suspected; TRAP = Wildlife in trap)" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="hwcr_complaint_nature_code" nullable="false" remarks="A human readable code used to identify the nature of the Human Wildlife Conflict." size="10" type="varchar" typeCode="12">
            <child column="hwcr_complaint_nature_code" foreignKey="FK_hwcrcmplnt_cmpltntrcd" implied="false" onDeleteCascade="false" schema="public" table="hwcr_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the nature of the Human Wildlife Conflict code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the nature of the Human Wildlife Conflict code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the nature of the Human Wildlife Conflict code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the nature of the Human Wildlife Conflict code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the human wildlife conflict nature code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the human wildlife conflict nature code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the human wildlife conflict nature code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the human wildlife conflict nature code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="hwcr_complaint_nature_code" sequenceNumberInPK="1"/>
         <index name="PK_cmpltntrcd" unique="true">
            <column ascending="true" name="hwcr_complaint_nature_code"/>
         </index>
      </table>
      <table name="linked_complaint_xref" remarks="Provides the ability to link one COMPLAINT to another COMPLAINT.   The initial use case for this table is to identify duplicate complaints, however additional linkages maybe possible in the future." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="linked_complaint_xref_guid" nullable="false" remarks="A human readable code used to identify a complaint linkage." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="complaint_identifier" nullable="false" remarks="One half of a linked complaint pair.  If the type requires a context of hierarchy, the complaint that is higher in the hierarchy.  For example, in the case of duplicate complaints, this would be the complaint that would remain open and where the majority of the information should be contained." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_lnkcmplxref_complaint" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="linked_complaint_identifier" nullable="false" remarks="One half of a linked complaint pair.  If the type requires a context of hierarchy, the complaint that is lower in the hierarchy.  For example, in the case of duplicate complaints, this would be the complaint that would be closed as a duplicate of the parent." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_lnkcmplxref_linked_complaint" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="active_ind" nullable="false" remarks="Flag indicating if the linkage is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the complaint linkage." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the complaint linkage was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="true" remarks="The id of the user that updated the complaint linkage." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="true" remarks="The timestamp when the complaint linkage was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="linked_complaint_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_lnkcmplxref" unique="true">
            <column ascending="true" name="linked_complaint_xref_guid"/>
         </index>
         <index name="linked_complaint_xref_linked_complaint_identifier_active_in_idx" unique="true">
            <column ascending="true" name="linked_complaint_identifier"/>
            <column ascending="true" name="active_ind"/>
         </index>
         <checkConstraint constraint="(((complaint_identifier)::text &lt;&gt; (linked_complaint_identifier)::text))" name="NE_lnkcmplxref_no_self_link"/>
      </table>
      <table name="office" remarks="An office is a physical location that serves as a central organization point for groups of users of the system." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="office_guid" nullable="false" remarks="System generated unique key for an office. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <child column="office_guid" foreignKey="FK_officer_office" implied="false" onDeleteCascade="false" schema="public" table="officer"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="create_user_id" nullable="false" remarks="The id of the user that created the office." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="2" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the office was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="update_user_id" nullable="false" remarks="The id of the user that updated the office." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the office was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geo_organization_unit_code" nullable="true" remarks="A human readable code used to identify a geographical organization unit.  The geographical unit where the office is located.   This might not necessarily be the lowest level in the geographical organizational unit hierarchy." size="10" type="varchar" typeCode="12">
            <parent column="geo_organization_unit_code" foreignKey="FK_office_geoorgutnd" implied="false" onDeleteCascade="false" schema="public" table="geo_organization_unit_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="agency_code" nullable="true" remarks="A human readable code used to identify an agency.  The agency that owns the office." size="6" type="varchar" typeCode="12"/>
         <primaryKey column="office_guid" sequenceNumberInPK="1"/>
         <index name="PK_office" unique="true">
            <column ascending="true" name="office_guid"/>
         </index>
      </table>
      <table name="office_h" remarks="History table for office table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_office_guid" nullable="false" remarks="System generated unique key for office history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the office that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the office table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the office table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_office_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_office" unique="true">
            <column ascending="true" name="h_office_guid"/>
         </index>
      </table>
      <table name="officer" remarks="An officer is a subtype of a person who can be identified through their IDIR." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="officer_guid" nullable="false" remarks="System generated unique key for an officer. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <child column="officer_guid" foreignKey="officer_team_xref_officer_fk" implied="false" onDeleteCascade="false" schema="public" table="officer_team_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="user_id" nullable="false" remarks="The IDIR ID issued to the user by the Government of British Columbia as part of their employment." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="create_user_id" nullable="false" remarks="The id of the user that created the officer." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the officer was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="update_user_id" nullable="false" remarks="The id of the user that updated the officer." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the officer was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="person_guid" nullable="true" remarks="System generated unique key for an person." size="2147483647" type="uuid" typeCode="1111">
            <parent column="person_guid" foreignKey="FK_officer_person" implied="false" onDeleteCascade="false" schema="public" table="person"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="office_guid" nullable="true" remarks="System generated unique key for an office. The primary office an officer is assigned to." size="2147483647" type="uuid" typeCode="1111">
            <parent column="office_guid" foreignKey="FK_officer_office" implied="false" onDeleteCascade="false" schema="public" table="office"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="auth_user_guid" nullable="true" remarks="The SiteMinder guid returned to the application from KeyCloak.   Used to uniquely identify a user over the course of their lifecycle." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="9" name="coms_enrolled_ind" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="10" name="deactivate_ind" nullable="true" remarks="A boolean indicator representing if an officer has been deactivated" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="officer_guid" sequenceNumberInPK="1"/>
         <index name="PK_officer" unique="true">
            <column ascending="true" name="officer_guid"/>
         </index>
         <index name="UQ_officer" unique="true">
            <column ascending="true" name="person_guid"/>
         </index>
      </table>
      <table name="officer_h" remarks="History table for officer table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_officer_guid" nullable="false" remarks="System generated unique key for officer history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the officer that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the officer table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the officer table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_officer_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_officer" unique="true">
            <column ascending="true" name="h_officer_guid"/>
         </index>
      </table>
      <table name="officer_team_xref" remarks="Defines the teams an officer may be on" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="officer_team_xref_guid" nullable="false" remarks="System generated unique key for a OFFICER_TEAM_XREF record.  This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="officer_guid" nullable="false" remarks="Unique key for an officer. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <parent column="officer_guid" foreignKey="officer_team_xref_officer_fk" implied="false" onDeleteCascade="false" schema="public" table="officer"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="team_guid" nullable="false" remarks="Unique key for a team. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <parent column="team_guid" foreignKey="officer_team_xref_team_fk" implied="false" onDeleteCascade="false" schema="public" table="team"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="active_ind" nullable="false" remarks="Used to indicate if the users in the OFFICER_TEAM_XREF recrodis active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="true" remarks="The id of the user that created the OFFICER_TEAM_XREF." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the OFFICER_TEAM_XREF was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="true" remarks="The id of the user that updated the OFFICER_TEAM_XREF" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the OFFICER_TEAM_XREF was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="officer_team_xref_guid" sequenceNumberInPK="1"/>
         <index name="officer_team_xref_pk" unique="true">
            <column ascending="true" name="officer_team_xref_guid"/>
         </index>
      </table>
      <table name="officer_team_xref_h" remarks="History table for officer_team_xref table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_officer_team_xref_guid" nullable="false" remarks="System generated unique key for officer_team_xref history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the officer_team_xref that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the officer_team_xref table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the officer_team_xref table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_officer_team_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_officer_team_xref" unique="true">
            <column ascending="true" name="h_officer_team_xref_guid"/>
         </index>
      </table>
      <table name="person" remarks="A person is an individual that is being tracked explicitly within the system.  The criteria for being included as a trackable individual is the possession of a unique identifier that can be used for dealiasing.  For example an IDIR or a BC Drivers Licence." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="person_guid" nullable="false" remarks="System generated unique key for an person. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111">
            <child column="person_guid" foreignKey="FK_officer_person" implied="false" onDeleteCascade="false" schema="public" table="officer"/>
            <child column="person_guid" foreignKey="FK_person_complaint_xref__person_guid" implied="false" onDeleteCascade="false" schema="public" table="person_complaint_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="first_name" nullable="false" remarks="The first name of a person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="middle_name_1" nullable="true" remarks="The first middle name of a person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="middle_name_2" nullable="true" remarks="Any remaining middle names beyond the first of a person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="last_name" nullable="false" remarks="The last name of a person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the person was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the person." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the person was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="person_guid" sequenceNumberInPK="1"/>
         <index name="PK_person" unique="true">
            <column ascending="true" name="person_guid"/>
         </index>
      </table>
      <table name="person_complaint_xref" remarks="Used to create a relationship between a person and a complaint.   One person can play many roles on a complaint, and many people could be involved in a single complaint." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="person_complaint_xref_guid" nullable="false" remarks="System generated unique key for a relationship between a person and a complaint. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="person_guid" nullable="false" remarks="System generated unique key for an person." size="2147483647" type="uuid" typeCode="1111">
            <parent column="person_guid" foreignKey="FK_person_complaint_xref__person_guid" implied="false" onDeleteCascade="false" schema="public" table="person"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="complaint_identifier" nullable="false" remarks="Natural key for a complaint generated by webEOC.  Format is YY-###### where the number portion of the sequence resets to 0 on the new year." size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="FK_person_complaint_xref__complaint_identifier" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="person_complaint_xref_code" nullable="false" remarks="A human readable code used to identify a relationship type between a person and a complaint." size="10" type="varchar" typeCode="12">
            <parent column="person_complaint_xref_code" foreignKey="FK_person_complaint_xref__person_complaint_xref_code" implied="false" onDeleteCascade="false" schema="public" table="person_complaint_xref_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the relationship between a person and a complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the relationship between a person and a complaint  was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the relationship between a person and a complaint ." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the relationship between a person and a complaint  was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the relationship type between a person and a complaint code is active." size="1" type="bool" typeCode="-7"/>
         <primaryKey column="person_complaint_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_person_complaint_xref_guid" unique="true">
            <column ascending="true" name="person_complaint_xref_guid"/>
         </index>
         <index name="person_complaint_xref_complaint_identifier_active_ind_idx" unique="true">
            <column ascending="true" name="complaint_identifier"/>
            <column ascending="true" name="active_ind"/>
         </index>
      </table>
      <table name="person_complaint_xref_code" remarks="Used to track the relationship type between person and complaint.  For example: 'ASSIGNEE' = Assignee" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="person_complaint_xref_code" nullable="false" remarks="A human readable code used to identify a relationship type between a person and a complaint." size="10" type="varchar" typeCode="12">
            <child column="person_complaint_xref_code" foreignKey="FK_person_complaint_xref__person_complaint_xref_code" implied="false" onDeleteCascade="false" schema="public" table="person_complaint_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the relationship type between a person and a complaint." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the relationship type between a person and a complaint." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the relationship type between a person and a complaint code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="The id of the user that created the relationship type between a person and a complaint." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the relationship type between a person and a complaint  was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="The id of the user that updated the relationship type between a person and a complaint ." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the relationship type between a person and a complaint  was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="8" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="person_complaint_xref_code" sequenceNumberInPK="1"/>
         <index name="PK_person_complaint_xref_code" unique="true">
            <column ascending="true" name="person_complaint_xref_code"/>
         </index>
      </table>
      <table name="person_complaint_xref_h" remarks="History table for person_complaint_xref" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_person_complaint_xref_guid" nullable="false" remarks="System generated unique key for person assigned to complaint history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the person and complaint mapping that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in complaint table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_person_complaint_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_person_complaint_xref_guid" unique="true">
            <column ascending="true" name="h_person_complaint_xref_guid"/>
         </index>
      </table>
      <table name="person_h" remarks="History table for person table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_person_guid" nullable="false" remarks="System generated unique key for person history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the person that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the person table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the person table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_person_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_person" unique="true">
            <column ascending="true" name="h_person_guid"/>
         </index>
      </table>
      <table name="reported_by_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="reported_by_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <child column="reported_by_code" foreignKey="FK_complaint_reported_by_code" implied="false" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="reported_by_code" sequenceNumberInPK="1"/>
         <index name="PK_reportedbycode" unique="true">
            <column ascending="true" name="reported_by_code"/>
         </index>
      </table>
      <table name="spatial_ref_sys" numRows="8500" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="srid" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="srid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="geography_columns"/>
            <child column="srid" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="geometry_columns"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="auth_name" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="auth_srid" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="srtext" nullable="true" remarks="" size="2048" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="proj4text" nullable="true" remarks="" size="2048" type="varchar" typeCode="12"/>
         <primaryKey column="srid" sequenceNumberInPK="1"/>
         <index name="spatial_ref_sys_pkey" unique="true">
            <column ascending="true" name="srid"/>
         </index>
         <checkConstraint constraint="(((srid &gt; 0) AND (srid &lt;= 998999)))" name="spatial_ref_sys_srid_check"/>
      </table>
      <table name="species_code" remarks="The species involved in a Human Wildlife Conflict (E.g. BLKBEAR = Black Bear; WOLVERN = Wolverine)" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="species_code" nullable="false" remarks="A human readable code used to identify a wildlife species." size="10" type="varchar" typeCode="12">
            <child column="species_code" foreignKey="FK_hwcrcmplnt_speciescd" implied="false" onDeleteCascade="false" schema="public" table="hwcr_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the species code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the species code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the species code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the species code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="legacy_code" nullable="true" remarks="The code for the species from the CORS_SPECIES_CODE table in the COORS database." size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="create_user_id" nullable="true" remarks="The id of the user that created the species code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the species code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="update_user_id" nullable="true" remarks="The id of the user that updated the species code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="9" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the species code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="10" name="large_carnivore_ind" nullable="true" remarks="A boolean indicator representing if an officer has been enrolled in COMS" size="1" type="bool" typeCode="-7"/>
         <primaryKey column="species_code" sequenceNumberInPK="1"/>
         <index name="PK_speciescd" unique="true">
            <column ascending="true" name="species_code"/>
         </index>
      </table>
      <table name="staging_activity_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="staging_activity_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <child column="staging_activity_code" foreignKey="staging_complaint_staging_staging_activity_code" implied="false" onDeleteCascade="false" schema="public" table="staging_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="staging_activity_code" sequenceNumberInPK="1"/>
         <index name="PK_staging_activity_code" unique="true">
            <column ascending="true" name="staging_activity_code"/>
         </index>
      </table>
      <table name="staging_complaint" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="staging_complaint_guid" nullable="false" remarks="" size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="staging_status_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <parent column="staging_status_code" foreignKey="staging_complaint_staging_status_code" implied="false" onDeleteCascade="false" schema="public" table="staging_status_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="staging_activity_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <parent column="staging_activity_code" foreignKey="staging_complaint_staging_staging_activity_code" implied="false" onDeleteCascade="false" schema="public" table="staging_activity_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="complaint_identifier" nullable="false" remarks="" size="20" type="varchar" typeCode="12">
            <parent column="complaint_identifier" foreignKey="Implied Constraint" implied="true" onDeleteCascade="false" schema="public" table="complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="complaint_jsonb" nullable="false" remarks="" size="2147483647" type="jsonb" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="staging_complaint_guid" sequenceNumberInPK="1"/>
         <index name="PK_staging_complaint" unique="true">
            <column ascending="true" name="staging_complaint_guid"/>
         </index>
      </table>
      <table name="staging_metadata_mapping" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="staging_metadata_mapping_guid" nullable="false" remarks="" size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="entity_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <parent column="entity_code" foreignKey="staging_staging_metadata_mapping_entity_code" implied="false" onDeleteCascade="false" schema="public" table="entity_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="staged_data_value" nullable="false" remarks="" size="120" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="live_data_value" nullable="false" remarks="" size="10" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="staging_metadata_mapping_guid" sequenceNumberInPK="1"/>
         <index name="PK_staging_metadata_mapping_guid" unique="true">
            <column ascending="true" name="staging_metadata_mapping_guid"/>
         </index>
         <index name="staging_metadata_mapping_unique" unique="true">
            <column ascending="true" name="entity_code"/>
            <column ascending="true" name="staged_data_value"/>
            <column ascending="true" name="live_data_value"/>
         </index>
      </table>
      <table name="staging_status_code" remarks="" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="staging_status_code" nullable="false" remarks="" size="10" type="varchar" typeCode="12">
            <child column="staging_status_code" foreignKey="staging_complaint_staging_status_code" implied="false" onDeleteCascade="false" schema="public" table="staging_complaint"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="" size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="" size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="staging_status_code" sequenceNumberInPK="1"/>
         <index name="PK_staging_status_code" unique="true">
            <column ascending="true" name="staging_status_code"/>
         </index>
      </table>
      <table name="team" remarks="Contains a list of TEAM types" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="team_guid" nullable="false" remarks="A system generated guid to uniquely identify a TEAM" size="2147483647" type="uuid" typeCode="1111">
            <child column="team_guid" foreignKey="officer_team_xref_team_fk" implied="false" onDeleteCascade="false" schema="public" table="officer_team_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="team_code" nullable="false" remarks="A human readable code used to identify a TEAM" size="15" type="varchar" typeCode="12">
            <parent column="team_code" foreignKey="team_team_code_fk" implied="false" onDeleteCascade="false" schema="public" table="team_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="agency_code" nullable="false" remarks="" size="6" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="team_agency_code_fk" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="true" digits="0" id="3" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the TEAM is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="create_user_id" nullable="true" remarks="The id of the user that created the TEAM." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="5" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the TEAM was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="update_user_id" nullable="true" remarks="The id of the user that updated the TEAM" size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="7" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the TEAM was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="team_guid" sequenceNumberInPK="1"/>
         <index name="team_pk" unique="true">
            <column ascending="true" name="team_guid"/>
         </index>
         <index name="team_un" unique="true">
            <column ascending="true" name="team_code"/>
            <column ascending="true" name="agency_code"/>
         </index>
      </table>
      <table name="team_code" remarks="An team is an organized and named grouping of people that interacts in some way with the Ministry." schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="team_code" nullable="false" remarks="A human readable code used to identify an team." size="10" type="varchar" typeCode="12">
            <child column="team_code" foreignKey="team_team_code_fk" implied="false" onDeleteCascade="false" schema="public" table="team"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the team code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the team code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the team code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the team code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the team code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the team was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the team code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the team was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="team_code" sequenceNumberInPK="1"/>
         <index name="PK_teamcode" unique="true">
            <column ascending="true" name="team_code"/>
         </index>
      </table>
      <table name="team_h" remarks="History table for team table" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="h_team_guid" nullable="false" remarks="System generated unique key for team history. This key should never be exposed to users via any system utilizing the tables." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="target_row_id" nullable="false" remarks="The unique key for the team that has been created or modified." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="operation_type" nullable="false" remarks="The operation performed: I = Insert, U = Update, D = Delete" size="1" type="bpchar" typeCode="1"/>
         <column autoUpdated="false" defaultValue="CURRENT_USER" digits="0" id="3" name="operation_user_id" nullable="false" remarks="The id of the user that created or modified the data in the team table.  Defaults to the logged in user if not passed in by the application." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="operation_executed_at" nullable="false" remarks="The timestamp when the data in the team table was created or modified.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="data_after_executed_operation" nullable="true" remarks="A JSON representation of the row in the table after the operation was completed successfully.   This implies that the latest row in the audit table will always match with the current row in the live table." size="2147483647" type="jsonb" typeCode="1111"/>
         <primaryKey column="h_team_guid" sequenceNumberInPK="1"/>
         <index name="PK_h_team" unique="true">
            <column ascending="true" name="h_team_guid"/>
         </index>
      </table>
      <table name="violation_agency_xref" remarks="Used to track the relationship type between an agency and a violation code.  For example: violation code 'WASTE' is only used by EPO (CEEB) but 'WILDLIFE' is used by both COS and PARKS" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="uuid_generate_v4()" digits="0" id="0" name="violation_agency_xref_guid" nullable="false" remarks="A human readable code used to identify a relationship type between an agency and a violation code." size="2147483647" type="uuid" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="violation_code" nullable="false" remarks="A human readable code used to identify a violation." size="10" type="varchar" typeCode="12">
            <parent column="violation_code" foreignKey="FK_violation_agency_xref__violation_code" implied="false" onDeleteCascade="false" schema="public" table="violation_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="agency_code" nullable="false" remarks="A human readable code used to identify an agency." size="10" type="varchar" typeCode="12">
            <parent column="agency_code" foreignKey="FK_violation_agency_xref__agency_code" implied="false" onDeleteCascade="false" schema="public" table="agency_code"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="create_user_id" nullable="false" remarks="The id of the user that created the relationship between an agency and a violation code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="4" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the relationship between an agency and a violation code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="update_user_id" nullable="false" remarks="The id of the user that updated the relationship between an agency and a violation code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="now()" digits="6" id="6" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the relationship between an agency and a violation code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="7" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the relationship type between an agency and a violation code is active." size="1" type="bool" typeCode="-7"/>
         <primaryKey column="violation_agency_xref_guid" sequenceNumberInPK="1"/>
         <index name="PK_violation_agency_xref_guid" unique="true">
            <column ascending="true" name="violation_agency_xref_guid"/>
         </index>
      </table>
      <table name="violation_code" remarks="The alleged violation involved in the complaint.   (E.g. ORV = Off Road Vehicles; PESTICDE = Pesticide)" schema="public" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="violation_code" nullable="false" remarks="A human readable code used to identify a violation." size="10" type="varchar" typeCode="12">
            <child column="violation_code" foreignKey="FK_algtncmplt_violatncd" implied="false" onDeleteCascade="false" schema="public" table="allegation_complaint"/>
            <child column="violation_code" foreignKey="FK_violation_agency_xref__violation_code" implied="false" onDeleteCascade="false" schema="public" table="violation_agency_xref"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="short_description" nullable="false" remarks="The short description of the violation code." size="50" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="long_description" nullable="true" remarks="The long description of the violation code." size="250" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="display_order" nullable="false" remarks="The order in which the values of the violation code table should be displayed when presented to a user in a list." size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="active_ind" nullable="false" remarks="A boolean indicator to determine if the violation code is active." size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="create_user_id" nullable="false" remarks="The id of the user that created the violation code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="6" name="create_utc_timestamp" nullable="false" remarks="The timestamp when the violation code was created.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="update_user_id" nullable="false" remarks="The id of the user that updated the violation code." size="32" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="8" name="update_utc_timestamp" nullable="false" remarks="The timestamp when the violation code was updated.  The timestamp is stored in UTC with no Offset." size="29" type="timestamp" typeCode="93"/>
         <primaryKey column="violation_code" sequenceNumberInPK="1"/>
         <index name="PK_violatncd" unique="true">
            <column ascending="true" name="violation_code"/>
         </index>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="true" name="_postgis_deprecate(oldname text, newname text, version text)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
  curver_text text;
BEGIN
  --
  -- Raises a NOTICE if it was deprecated in this version,
  -- a WARNING if in a previous version (only up to minor version checked)
  --
	curver_text := '3.4.3';
	IF pg_catalog.split_part(curver_text,'.',1)::int > pg_catalog.split_part(version,'.',1)::int OR
	   ( pg_catalog.split_part(curver_text,'.',1) = pg_catalog.split_part(version,'.',1) AND
		 pg_catalog.split_part(curver_text,'.',2) != split_part(version,'.',2) )
	THEN
	  RAISE WARNING '% signature was deprecated in %. Please use %', oldname, version, newname;
	ELSE
	  RAISE DEBUG '% signature was deprecated in %. Please use %', oldname, version, newname;
	END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="oldname" type="text"/>
            <parameter mode="IN" name="newname" type="text"/>
            <parameter mode="IN" name="version" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_index_extent(tbl regclass, col text)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[_postgis_gserialized_index_extent]]></definition>
         <parameters>
            <parameter mode="IN" name="tbl" type="regclass"/>
            <parameter mode="IN" name="col" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_join_selectivity(regclass, text, regclass, text, text DEFAULT '2'::text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[_postgis_gserialized_joinsel]]></definition>
         <parameters>
            <parameter mode="IN" type="regclass"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="regclass"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_pgsql_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN pg_catalog.split_part(s,'.',1)::integer > 9 THEN pg_catalog.split_part(s,'.',1) || '0'
	ELSE pg_catalog.split_part(s,'.', 1) || pg_catalog.split_part(s,'.', 2) END AS v
	FROM pg_catalog.substring(version(), E'PostgreSQL ([0-9\\.]+)') AS s;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_postgis_scripts_pgsql_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT '160'::text AS version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_selectivity(tbl regclass, att_name text, geom geometry, mode text DEFAULT '2'::text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[_postgis_gserialized_sel]]></definition>
         <parameters>
            <parameter mode="IN" name="tbl" type="regclass"/>
            <parameter mode="IN" name="att_name" type="text"/>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="mode" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_postgis_stats(tbl regclass, att_name text, text DEFAULT '2'::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[_postgis_gserialized_stats]]></definition>
         <parameters>
            <parameter mode="IN" name="tbl" type="regclass"/>
            <parameter mode="IN" name="att_name" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dfullywithin3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3ddwithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dwithin3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_3dintersects(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_3DIntersects]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_asgml(integer, geometry, integer, integer, text, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asGML]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_asx3d(integer, geometry, integer, integer, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asX3D]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_bestsrid(geography)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_bestsrid]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_bestsrid(geography, geography)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_bestsrid]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_concavehull(param_inputgeom geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	vexhull public.geometry;
	var_resultgeom public.geometry;
	var_inputgeom public.geometry;
	vexring public.geometry;
	cavering public.geometry;
	cavept public.geometry[];
	seglength double precision;
	var_tempgeom public.geometry;
	scale_factor float := 1;
	i integer;
	BEGIN
		-- First compute the ConvexHull of the geometry
		vexhull := public.ST_ConvexHull(param_inputgeom);
		var_inputgeom := param_inputgeom;
		--A point really has no concave hull
		IF public.ST_GeometryType(vexhull) = 'ST_Point' OR public.ST_GeometryType(vexHull) = 'ST_LineString' THEN
			RETURN vexhull;
		END IF;

		-- convert the hull perimeter to a linestring so we can manipulate individual points
		vexring := CASE WHEN public.ST_GeometryType(vexhull) = 'ST_LineString' THEN vexhull ELSE public.ST_ExteriorRing(vexhull) END;
		IF abs(public.ST_X(public.ST_PointN(vexring,1))) < 1 THEN --scale the geometry to prevent stupid precision errors - not sure it works so make low for now
			scale_factor := 100;
			vexring := public.ST_Scale(vexring, scale_factor,scale_factor);
			var_inputgeom := public.ST_Scale(var_inputgeom, scale_factor, scale_factor);
			--RAISE NOTICE 'Scaling';
		END IF;
		seglength := public.ST_Length(vexring)/least(public.ST_NPoints(vexring)*2,1000) ;

		vexring := public.ST_Segmentize(vexring, seglength);
		-- find the point on the original geom that is closest to each point of the convex hull and make a new linestring out of it.
		cavering := public.ST_Collect(
			ARRAY(

				SELECT
					public.ST_ClosestPoint(var_inputgeom, pt ) As the_geom
					FROM (
						SELECT  public.ST_PointN(vexring, n ) As pt, n
							FROM
							generate_series(1, public.ST_NPoints(vexring) ) As n
						) As pt

				)
			)
		;

		var_resultgeom := public.ST_MakeLine(geom)
			FROM public.ST_Dump(cavering) As foo;

		IF public.ST_IsSimple(var_resultgeom) THEN
			var_resultgeom := public.ST_MakePolygon(var_resultgeom);
			--RAISE NOTICE 'is Simple: %', var_resultgeom;
		ELSE 
			--RAISE NOTICE 'is not Simple: %', var_resultgeom;
			var_resultgeom := public.ST_ConvexHull(var_resultgeom);
		END IF;

		IF scale_factor > 1 THEN -- scale the result back
			var_resultgeom := public.ST_Scale(var_resultgeom, 1/scale_factor, 1/scale_factor);
		END IF;

		-- make sure result covers original (#3638)
		-- Using ST_UnaryUnion since SFCGAL doesn't replace with its own implementation
		-- and SFCGAL one chokes for some reason
		var_resultgeom := public.ST_UnaryUnion(public.ST_Collect(param_inputgeom, var_resultgeom) );
		RETURN var_resultgeom;

	END;]]></definition>
         <parameters>
            <parameter mode="IN" name="param_inputgeom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_contains(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[contains]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_containsproperly(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[containsproperly]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_coveredby(geog1 geography, geog2 geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_coveredby]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_coveredby(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[coveredby]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_covers(geog1 geography, geog2 geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_covers]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_covers(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[covers]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_crosses(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[crosses]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dfullywithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dfullywithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distancetree(geography, geography)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_DistanceTree($1, $2, 0.0, true)]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distancetree(geography, geography, double precision, boolean)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_distance_tree]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distanceuncached(geography, geography)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_DistanceUnCached($1, $2, 0.0, true)]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distanceuncached(geography, geography, boolean)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_DistanceUnCached($1, $2, 0.0, $3)]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_distanceuncached(geography, geography, double precision, boolean)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_distance_uncached]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithin(geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_dwithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dwithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithinuncached(geography, geography, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $1 OPERATOR(public.&&) public._ST_Expand($2,$3) AND $2 OPERATOR(public.&&) public._ST_Expand($1,$3) AND public._ST_DWithinUnCached($1, $2, $3, true)]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_dwithinuncached(geography, geography, double precision, boolean)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_dwithin_uncached]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_equals(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Equals]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_expand(geography, double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_expand]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_geomfromgml(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom_from_gml]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_intersects(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Intersects]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_linecrossingdirection(line1 geometry, line2 geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_LineCrossingDirection]]></definition>
         <parameters>
            <parameter mode="IN" name="line1" type="geometry"/>
            <parameter mode="IN" name="line2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_longestline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_longestline2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_maxdistance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_maxdistance2d_linestring]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_orderingequals(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_same]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_overlaps(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[overlaps]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_pointoutside(geography)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_point_outside]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_sortablehash(geom geometry)" returnType="bigint" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[_ST_SortableHash]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_touches(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[touches]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_voronoi(g1 geometry, clip geometry DEFAULT NULL::geometry, tolerance double precision DEFAULT 0.0, return_polygons boolean DEFAULT true)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Voronoi]]></definition>
         <parameters>
            <parameter mode="IN" name="g1" type="geometry"/>
            <parameter mode="IN" name="clip" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="return_polygons" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_st_within(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_Contains($2,$1)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addauth(text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_token - Adds an authorization token to be used in the current transaction.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	lockid alias for $1;
	okay boolean;
	myrec record;
BEGIN
	-- check to see if table exists
	--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)
	okay := 'f';
	FOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP
		okay := 't';
	END LOOP;
	IF (okay <> 't') THEN
		CREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);
			-- this will only work from pgsql7.4 up
			-- ON COMMIT DELETE ROWS;
	END IF;

	--  INSERT INTO mylock VALUES ( $1)
--	EXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||
--		quote_literal(getTransactionID()) || ',' ||
--		quote_literal(lockid) ||')';

	INSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);

	RETURN true::boolean;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name "%(%)" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;

	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;

	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;

	-- Add geometry column to table
	IF use_typmod THEN
		 sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name)
			|| ' ADD COLUMN ' || quote_ident(column_name) ||
			' geometry(' || public.postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
		RAISE DEBUG '%', sql;
	ELSE
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name)
			|| ' ADD COLUMN ' || quote_ident(column_name) ||
			' geometry ';
		RAISE DEBUG '%', sql;
	END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
		-- Add table CHECKs
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name)
			|| ' ADD CONSTRAINT '
			|| quote_ident('enforce_srid_' || column_name)
			|| ' CHECK (st_srid(' || quote_ident(column_name) ||
			') = ' || new_srid::text || ')' ;
		RAISE DEBUG '%', sql;
		EXECUTE sql;

		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name)
			|| ' ADD CONSTRAINT '
			|| quote_ident('enforce_dims_' || column_name)
			|| ' CHECK (st_ndims(' || quote_ident(column_name) ||
			') = ' || new_dim::text || ')' ;
		RAISE DEBUG '%', sql;
		EXECUTE sql;

		IF ( NOT (new_type = 'GEOMETRY')) THEN
			sql := 'ALTER TABLE ' ||
				quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
				quote_ident('enforce_geotype_' || column_name) ||
				' CHECK (GeometryType(' ||
				quote_ident(column_name) || ')=' ||
				quote_literal(new_type) || ' OR (' ||
				quote_ident(column_name) || ') is null)';
			RAISE DEBUG '%', sql;
			EXECUTE sql;
		END IF;
	END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="catalog_name" type="character varying"/>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
            <parameter mode="IN" name="new_srid_in" type="integer"/>
            <parameter mode="IN" name="new_type" type="character varying"/>
            <parameter mode="IN" name="new_dim" type="integer"/>
            <parameter mode="IN" name="use_typmod" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret  text;
BEGIN
	SELECT public.AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
            <parameter mode="IN" name="new_srid" type="integer"/>
            <parameter mode="IN" name="new_type" type="character varying"/>
            <parameter mode="IN" name="new_dim" type="integer"/>
            <parameter mode="IN" name="use_typmod" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret  text;
BEGIN
	SELECT public.AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
            <parameter mode="IN" name="new_srid" type="integer"/>
            <parameter mode="IN" name="new_type" type="character varying"/>
            <parameter mode="IN" name="new_dim" type="integer"/>
            <parameter mode="IN" name="use_typmod" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="audit_history()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE

	target_history_table TEXT;
	target_pk TEXT;

  BEGIN
    target_history_table := TG_ARGV[0];
    target_pk := TG_ARGV[1];

    IF TG_OP ='INSERT' THEN 
        
      -- Don't trust the caller not to manipulate any of these fields
      NEW.create_utc_timestamp := current_timestamp; -- create timestamp must be the current time
      NEW.update_utc_timestamp := current_timestamp; -- update timestamp must be the current time
      NEW.update_user_id := NEW.create_user_id;  -- the update user must be the same as the create user

      EXECUTE
        format( 
            'INSERT INTO %I (target_row_id, operation_type, operation_user_id, data_after_executed_operation) VALUES ($1.%I,  ''I'', $1.create_user_id, to_jsonb($1))',  target_history_table, target_pk
        )
        USING NEW;
      RETURN NEW;

    ELSIF TG_OP = 'UPDATE' THEN 

      -- Don't trust the caller not to manipulate any of these fields
      NEW.update_utc_timestamp := current_timestamp;  -- update timestamp must be the current time
      NEW.create_user_id := OLD.create_user_id; -- create userId can't be altered
      NEW.create_utc_timestamp := OLD.create_utc_timestamp; -- update timestamp can't be altered

      EXECUTE
        format(
            'INSERT INTO %I (target_row_id, operation_type, operation_user_id, data_after_executed_operation) VALUES ($1.%I, ''U'', $1.update_user_id, to_jsonb($1))', target_history_table, target_pk
          )
        USING NEW;
      RETURN NEW;

    ELSIF TG_OP = 'DELETE' THEN

      EXECUTE
        format(
                'INSERT INTO %I (target_row_id, operation_type) VALUES ($1.%I, ''D'')', target_history_table, target_pk
        )
        USING OLD;
      RETURN OLD;

    END IF;
  END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box(box3d)" returnType="box" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_to_BOX]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box(geometry)" returnType="box" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_BOX]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d(box3d)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_to_BOX2D]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d(geometry)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a BOX2D representing the 2D extent of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_to_BOX2D]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d_in(cstring)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX2D_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2d_out(box2d)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX2D_out]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2df_in(cstring)" returnType="box2df" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[box2df_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box2df_out(box2df)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[box2df_out]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d(box2d)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX2D_to_BOX3D]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d(geometry)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a BOX3D representing the 3D extent of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_to_BOX3D]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d_in(cstring)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3d_out(box3d)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_out]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="box3dtobox(box3d)" returnType="box" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_to_BOX]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="bytea(geography)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="bytea(geometry)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="checkauth(text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.]]></comment>
         <definition language="sql"><![CDATA[SELECT CheckAuth('', $1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="checkauth(text, text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_schema_name, a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	schema text;
BEGIN
	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	if ( $1 != '' ) THEN
		schema = $1;
	ELSE
		SELECT current_schema() into schema;
	END IF;

	-- TODO: check for an already existing trigger ?

	EXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON '
		|| quote_ident(schema) || '.' || quote_ident($2)
		||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('
		|| quote_literal($3) || ')';

	RETURN 0;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="checkauthtrigger()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[check_authorization]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="contains_2d(box2df, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_box2df_box2df_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="contains_2d(box2df, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_box2df_geom_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="contains_2d(geometry, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $2 OPERATOR(public.@) $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="cos_geo_org_unit_flat_mvw_refresh()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN 
 	REFRESH MATERIALIZED VIEW cos_geo_org_unit_flat_mvw;
	RETURN NULL;
 END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="daitch_mokotoff(text)" returnType="text[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[daitch_mokotoff]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="difference(text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[difference]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="disablelongtransactions()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Disables long transaction support.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	rec RECORD;

BEGIN

	--
	-- Drop all triggers applied by CheckAuth()
	--
	FOR rec IN
		SELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p
		WHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid
	LOOP
		EXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||
			' ON ' || quote_ident(rec.relname);
	END LOOP;

	--
	-- Drop the authorization_table table
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP
		DROP TABLE authorization_table;
	END LOOP;

	--
	-- Drop the authorized_tables view
	--
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP
		DROP VIEW authorized_tables;
	END LOOP;

	RETURN 'Long transactions support disabled';
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dmetaphone(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[dmetaphone]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dmetaphone_alt(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[dmetaphone_alt]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name - Removes a geometry column from a spatial table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN

	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
	FOR myrec IN SELECT * from public.geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;]]></definition>
         <parameters>
            <parameter mode="IN" name="catalog_name" type="character varying"/>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name, column_name - Removes a geometry column from a spatial table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret text;
BEGIN
	SELECT public.DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrycolumn(table_name character varying, column_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: table_name, column_name - Removes a geometry column from a spatial table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret text;
BEGIN
	SELECT public.DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name - Drops a table and all its references in geometry_columns.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;]]></definition>
         <parameters>
            <parameter mode="IN" name="catalog_name" type="character varying"/>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrytable(schema_name character varying, table_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name - Drops a table and all its references in geometry_columns.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.DropGeometryTable('',$1,$2)]]></definition>
         <parameters>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="dropgeometrytable(table_name character varying)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: table_name - Drops a table and all its references in geometry_columns.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.DropGeometryTable('','',$1)]]></definition>
         <parameters>
            <parameter mode="IN" name="table_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="edit_complaint_using_webeoc_complaint(_complaint_identifier character varying)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    WEBEOC_USER_ID CONSTANT varchar(6) := 'webeoc';
    WEBEOC_UPDATE_TYPE_INSERT CONSTANT varchar(6) := 'INSERT';
    STAGING_STATUS_CODE_PENDING CONSTANT varchar(7) := 'PENDING';
    STAGING_STATUS_CODE_SUCCESS CONSTANT varchar(7) := 'SUCCESS' ;
    STAGING_STATUS_CODE_EDIT CONSTANT varchar(6) := 'EDIT' ;
    STAGING_STATUS_CODE_ERROR CONSTANT varchar(5) := 'ERROR';
   
	current_complaint_record PUBLIC.complaint; -- record being edited
	allegation_complaint_record PUBLIC.allegation_complaint;
	edit_complaint_data JSONB; -- the complaint data containing the edits from webeoc
    original_complaint_record JSONB; -- the complaint data before the edits, used to determine i
   
    -- Variable to hold the JSONB data from staging_complaint.  Used to edit a complaint
    _edit_report_type            VARCHAR(120);
    _edit_detail_text            VARCHAR(4000);
    _edit_caller_name            VARCHAR(120);
    _edit_caller_address         VARCHAR(120);
    _edit_address         		VARCHAR(120);
    _edit_caller_email           VARCHAR(120);
    _edit_caller_phone_1         VARCHAR(15);
    _edit_caller_phone_2         VARCHAR(15);
    _edit_caller_phone_3         VARCHAR(15);
    _edit_location_summary_text  VARCHAR(120);
    _edit_location_detailed_text VARCHAR(4000);
    _edit_incident_utc_datetime timestamp;
    _edit_create_utc_timestamp timestamp := (now() AT TIME zone 'UTC');
    _edit_update_utc_timestamp timestamp := (now() AT TIME zone 'UTC');
    _edit_create_userid              VARCHAR(200);
    _edit_update_userid              VARCHAR(200);
    _edit_geo_organization_unit_code VARCHAR(10);
    _edit_incident_reported_utc_timestmp timestamp;
    _edit_address_coordinates_lat VARCHAR(200);
    _edit_address_coordinates_long VARCHAR(200);
    _edit_location_geometry_point GEOMETRY;
    _edit_complaint_status_code VARCHAR(10);

    -- Variables for 'hwcr_complaint' table
    _edit_webeoc_species                    VARCHAR(200);
    _edit_webeoc_hwcr_complaint_nature_code VARCHAR(200);
    _edit_webeoc_cos_area_community         VARCHAR(200);
    _edit_webeoc_attracts_list              VARCHAR(1000);
    _edit_species_code                      VARCHAR(10);
    _edit_hwcr_complaint_nature_code        VARCHAR(10);
    _edit_other_attractants_text            VARCHAR(4000);
    _edit_reported_by_other_text            VARCHAR(4000);
    _edit_webeoc_reported_by_code           VARCHAR(200);
    _edit_cos_reffered_by_lst               VARCHAR(200);
    _edit_in_progress_ind                   VARCHAR(3);
    _edit_observed_ind                      VARCHAR(3);
    _edit_in_progress_ind_bool bool;
    _edit_observed_ind_bool bool;
    _edit_suspect_witnesss_dtl_text VARCHAR(4000);
    _edit_violation_code            VARCHAR(10);
    -- used to generate a uuid.  We use this to create the PK in hwcr_complaint, but
    -- we need to also use it when creating the attractants
    hwcr_uuid uuid;
    enforcement_uuid uuid;
    -- parsed attractants from the jsonb object
    attractants_array text[];
    attractant_item text;
    _attractant_code VARCHAR(10);


   
   
   _current_species_code VARCHAR(10);
   _current_violation_type_code VARCHAR(10);
   
   -- used to indicate if the update causes an edit to the complaint record
   update_edit_ind boolean = false;
   
   USERNAME_TXT CONSTANT varchar(8) = 'username';
  
  
   
BEGIN
   
   
    -- get the staged edit record.  There may be multiple for a given complaint, we just want the last one since that
    -- will contain all previous edits too
   select sc.complaint_jsonb
    into edit_complaint_data
    from PUBLIC.staging_complaint sc 
    where sc.complaint_identifier  = _complaint_identifier
    and sc.staging_activity_code  = STAGING_STATUS_CODE_EDIT
    and sc.staging_status_code  = STAGING_STATUS_CODE_PENDING
    order by sc.update_utc_timestamp desc
	limit 1;

    -- These fields are retrieved to potentially update an existing complaint record
	_edit_detail_text := edit_complaint_data ->> 'cos_call_details';
    _edit_caller_name := edit_complaint_data ->> 'cos_caller_name';
    _edit_caller_phone_1 := format_phone_number(edit_complaint_data ->> 'cos_primary_phone');
    _edit_caller_phone_2 := format_phone_number(edit_complaint_data ->> 'cos_alt_phone');
    _edit_caller_phone_3 := format_phone_number(edit_complaint_data ->> 'cos_alt_phone_2');
    _edit_caller_email := edit_complaint_data ->> 'cos_caller_email';
    _edit_caller_address := edit_complaint_data ->> 'caller_address';
    _edit_address := edit_complaint_data ->> 'address';
    _edit_webeoc_reported_by_code := edit_complaint_data ->> 'cos_reffered_by_lst';
    _edit_reported_by_other_text := edit_complaint_data ->> 'cos_reffered_by_txt';
    _edit_webeoc_species := edit_complaint_data ->> 'species';
    _edit_report_type := edit_complaint_data ->> 'report_type';
    _edit_update_userid := substring(edit_complaint_data ->> USERNAME_TXT from 1 for 32);
    _edit_complaint_status_code := UPPER(edit_complaint_data ->> 'status');
   
    _edit_location_detailed_text := edit_complaint_data ->> 'cos_location_description';
    _edit_incident_utc_datetime := ( edit_complaint_data ->> 'incident_datetime' ):: timestamp AT            TIME zone 'America/Los_Angeles';
    _edit_incident_reported_utc_timestmp := ( edit_complaint_data ->> 'created_by_datetime' ):: timestamp AT TIME zone 'America/Los_Angeles';
	_edit_address_coordinates_lat := validate_coordinate_field(edit_complaint_data ->> 'address_coordinates_lat');
    _edit_address_coordinates_long := validate_coordinate_field(edit_complaint_data ->> 'address_coordinates_long');
   
    -- Create a geometry point based on the latitude and longitude
    IF _edit_address_coordinates_lat IS NOT NULL AND _edit_address_coordinates_lat <> '' AND
       _edit_address_coordinates_long IS NOT NULL AND _edit_address_coordinates_long <> '' THEN
        _edit_location_geometry_point := ST_SetSRID(
            ST_MakePoint(
                CAST(_edit_address_coordinates_long AS NUMERIC),
                CAST(_edit_address_coordinates_lat AS NUMERIC)
            ),
            4326
        );
    ELSE
    	_edit_location_geometry_point := ST_SetSRID(ST_MakePoint(0, 0), 4326);
	END IF;



    -- Get the codes from our application (inserting if necessary) for the codes retrieved from WebEOC
    SELECT *
    INTO   _edit_cos_reffered_by_lst
    FROM   PUBLIC.insert_and_return_code(_edit_webeoc_reported_by_code, 'reprtdbycd');

   
    -- Get the current state of the complaint
    SELECT *
    INTO   current_complaint_record
    FROM   PUBLIC.complaint
    WHERE  complaint_identifier = _complaint_identifier;

      -- update the complaint data, if the incoming webeoc contains applicable updates
   if (COALESCE(_edit_detail_text, '') <> COALESCE(current_complaint_record.detail_text, '')) then
	    UPDATE complaint
	    SET detail_text  = _edit_detail_text
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
   
   -- update the complaint data, if the incoming webeoc contains applicable updates
   if (COALESCE(_edit_caller_name, '') <> COALESCE(current_complaint_record.caller_name, '')) then
	    UPDATE complaint
	    SET caller_name = _edit_caller_name
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _edit_caller_phone_1 := format_phone_number(_edit_caller_phone_1);
  if (COALESCE(_edit_caller_phone_1, '') <> COALESCE(current_complaint_record.caller_phone_1, '')) then
        
	    UPDATE complaint
	    SET caller_phone_1 = _edit_caller_phone_1
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _edit_caller_phone_2 := format_phone_number(_edit_caller_phone_2);
  if (COALESCE(_edit_caller_phone_2, '') <> COALESCE(current_complaint_record.caller_phone_2, '')) then
    	
	    UPDATE complaint
	    SET caller_phone_2 = _edit_caller_phone_2
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _edit_caller_phone_3 := format_phone_number(_edit_caller_phone_3);
  if (COALESCE(_edit_caller_phone_3, '') <> COALESCE(current_complaint_record.caller_phone_3, '')) then
    	
	    UPDATE complaint
	    SET caller_phone_3 = _edit_caller_phone_3
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
  
  if (COALESCE(_edit_caller_email, '') <> COALESCE(current_complaint_record.caller_email, '')) then 
		UPDATE complaint
		SET caller_email = _edit_caller_email
		WHERE complaint_identifier = _complaint_identifier;
		update_edit_ind = true;
  end if;
  
  if (COALESCE(_edit_caller_address, '') <> COALESCE(current_complaint_record.caller_address, '')) then 
	    UPDATE complaint
	    SET caller_address = _edit_caller_address
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
 
  if (COALESCE(_edit_address, '') <> COALESCE(current_complaint_record.location_summary_text, '')) then 
	    UPDATE complaint
	    SET location_summary_text  = _edit_address
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
  
  if (COALESCE(_edit_cos_reffered_by_lst, '') <> COALESCE(current_complaint_record.reported_by_code, '')) then 
	    UPDATE complaint
	    SET reported_by_code = _edit_cos_reffered_by_lst
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
   
  if (COALESCE(_edit_reported_by_other_text, '') <> COALESCE(current_complaint_record.reported_by_other_text, '')) then 
	    UPDATE complaint
	    SET reported_by_other_text = _edit_reported_by_other_text
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
 
  if (COALESCE(_edit_location_detailed_text, '') <> COALESCE(current_complaint_record.location_detailed_text, '')) then 
	    UPDATE complaint
	    SET location_detailed_text  = _edit_location_detailed_text
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
 
  if (_edit_incident_utc_datetime <> current_complaint_record.incident_utc_datetime) then 
	    UPDATE complaint
	    SET incident_utc_datetime  = _edit_incident_utc_datetime
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
 
  if (_edit_incident_reported_utc_timestmp <> current_complaint_record.incident_reported_utc_timestmp) then 
	    UPDATE complaint
	    SET incident_reported_utc_timestmp  = _edit_incident_reported_utc_timestmp
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;

  if NOT ST_Equals(_edit_location_geometry_point, current_complaint_record.location_geometry_point) then
	    UPDATE complaint
	    SET location_geometry_point  = _edit_location_geometry_point
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
   
  -- the update caused an edit, set the audit fields
  if (update_edit_ind) then
	update complaint
	set update_user_id = _edit_update_userid, update_utc_timestamp = _edit_update_utc_timestamp, comp_last_upd_utc_timestamp = _edit_update_utc_timestamp
	where complaint_identifier = _complaint_identifier;
  end if;
  
  if (_edit_report_type = 'HWCR') then
      update_edit_ind = false;
	  select hc.hwcr_complaint_guid 
	  into hwcr_uuid
	  from hwcr_complaint hc where complaint_identifier  = _complaint_identifier;
	 
	  update attractant_hwcr_xref
	  set active_ind = false
	  where hwcr_complaint_guid = hwcr_uuid;
	 
      -- Convert the comma-separated list into an array
      attractants_array := string_to_array( edit_complaint_data ->> 'attractants_list', ',' );
      -- Iterate over the array
      foreach attractant_item IN ARRAY attractants_array
      LOOP                                                -- Trim whitespace and check if the item is 'Not Applicable'
        IF trim(attractant_item) <> 'Not Applicable' THEN -- Your insertion logic here
          SELECT *
          FROM   PUBLIC.insert_and_return_code( trim(attractant_item), 'atractntcd' )
          INTO   _attractant_code;
          
          INSERT INTO PUBLIC.attractant_hwcr_xref
                      (
                                  attractant_code,
                                  hwcr_complaint_guid,
                                  create_user_id,
                                  create_utc_timestamp,
                                  update_user_id,
                                  update_utc_timestamp
                      )
                      VALUES
                      (
                                  _attractant_code,
                                  hwcr_uuid,
                                  WEBEOC_USER_ID,
                                  _edit_create_utc_timestamp,
                                  WEBEOC_USER_ID,
                                  _edit_update_utc_timestamp
                      );
        
        END IF;
      END LOOP;
    -- get the code based on the update from WebEOC
    SELECT *
    INTO   _edit_species_code
    FROM   PUBLIC.insert_and_return_code(_edit_webeoc_species, 'speciescd');
   
    -- get the current species code
   	SELECT hc.species_code 
   	INTO _current_species_code
	FROM hwcr_complaint hc 
	WHERE hc.complaint_identifier = _complaint_identifier;


    if (_edit_species_code <> _current_species_code) then 
    	update hwcr_complaint
    	set species_code = _edit_species_code
    	where complaint_identifier = _complaint_identifier;
    end if;
   
    -- the update caused an edit, set the audit fields
    if (update_edit_ind) then
		update hwcr_complaint 
		set update_user_id = _edit_update_userid, update_utc_timestamp = _edit_update_utc_timestamp
		where complaint_identifier = _complaint_identifier;
    end if;

  end if;
 
  if (_edit_report_type = 'ERS') then
	  update_edit_ind = false;
  	
  
      _edit_in_progress_ind := (edit_complaint_data->>'violation_in_progress');
      _edit_observed_ind := (edit_complaint_data->>'observe_violation');
      _edit_suspect_witnesss_dtl_text := edit_complaint_data->>'suspect_details';

      IF _edit_in_progress_ind = 'Yes' THEN
        _edit_in_progress_ind_bool := TRUE;
      ELSE
        _edit_in_progress_ind_bool := FALSE;
      END IF; 
      IF _edit_observed_ind = 'Yes' THEN
        _edit_observed_ind_bool := TRUE;
      ELSE
        _edit_observed_ind_bool := FALSE;
      END IF;
     
     -- Get the current state of the complaint
     SELECT *
     INTO   allegation_complaint_record
     FROM   PUBLIC.allegation_complaint ac
     WHERE  complaint_identifier = _complaint_identifier;

   

     if (_edit_observed_ind_bool != allegation_complaint_record.observed_ind) then 
	    UPDATE allegation_complaint
	    SET observed_ind  = _edit_observed_ind_bool
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
	 end if;
	
     if (_edit_in_progress_ind_bool != allegation_complaint_record.in_progress_ind) then 
	    UPDATE allegation_complaint
	    SET in_progress_ind  = _edit_in_progress_ind_bool
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
	 end if;
	
     if (_edit_suspect_witnesss_dtl_text <> allegation_complaint_record.suspect_witnesss_dtl_text) then 
	    UPDATE allegation_complaint
	    SET suspect_witnesss_dtl_text  = _edit_suspect_witnesss_dtl_text
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
	 end if;

  
	 SELECT *
	 FROM   PUBLIC.insert_and_return_code( edit_complaint_data->>'violation_type', 'violatncd' )
	 INTO   _edit_violation_code;
	 
     select ac.violation_code
     into _current_violation_type_code
     from allegation_complaint ac
     where ac.complaint_identifier = _complaint_identifier;

    if (_edit_violation_code <> _current_violation_type_code) then
	    if _edit_violation_code = 'WASTE' OR _edit_violation_code = 'PESTICDE' then
        UPDATE PUBLIC.complaint
        SET    owned_by_agency_code = 'EPO'
        WHERE  complaint_identifier = _complaint_identifier;
      else
        UPDATE PUBLIC.complaint
        SET    owned_by_agency_code = 'COS'
        WHERE  complaint_identifier = _complaint_identifier;
      end if;  
	    
      update allegation_complaint
      set violation_code  = _edit_violation_code
      where complaint_identifier = _complaint_identifier;
      update_edit_ind = true;
    end if;

    -- the update caused an edit, set the audit fields
    if (update_edit_ind) then
		update hwcr_complaint 
		set update_user_id = _edit_update_userid, update_utc_timestamp = _edit_update_utc_timestamp
		where complaint_identifier = _complaint_identifier;
    end if;
  end if;
 
    -- Update staging_complaint to mark the process as successful
   UPDATE staging_complaint
   SET    staging_status_code = STAGING_STATUS_CODE_SUCCESS
   WHERE  complaint_identifier = _complaint_identifier
   AND    staging_activity_code = STAGING_STATUS_CODE_EDIT
   and 	  staging_status_code = 'PENDING';

EXCEPTION
WHEN OTHERS THEN
    RAISE NOTICE 'An unexpected error occurred: %', SQLERRM;
    UPDATE staging_complaint
    SET    staging_status_code = STAGING_STATUS_CODE_ERROR
    WHERE  complaint_identifier = _complaint_identifier
    AND    staging_status_code = STAGING_STATUS_CODE_PENDING
    AND    staging_activity_code = STAGING_STATUS_CODE_EDIT;

END;]]></definition>
         <parameters>
            <parameter mode="IN" name="_complaint_identifier" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="enablelongtransactions()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Enables long transaction support.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	"query" text;
	exists bool;
	rec RECORD;

BEGIN

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists
	THEN
		"query" = 'CREATE TABLE authorization_table (
			toid oid, -- table oid
			rid text, -- row id
			expires timestamp,
			authid text
		)';
		EXECUTE "query";
	END IF;

	exists = 'f';
	FOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		exists = 't';
	END LOOP;

	IF NOT exists THEN
		"query" = 'CREATE VIEW authorized_tables AS ' ||
			'SELECT ' ||
			'n.nspname as schema, ' ||
			'c.relname as table, trim(' ||
			quote_literal(chr(92) || '000') ||
			' from t.tgargs) as id_column ' ||
			'FROM pg_trigger t, pg_class c, pg_proc p ' ||
			', pg_namespace n ' ||
			'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||
			' AND c.relnamespace = n.oid' ||
			' AND t.tgfoid = p.oid and t.tgrelid = c.oid';
		EXECUTE "query";
	END IF;

	RETURN 'Long transactions support enabled';
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="equals(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Equals]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="find_srid(character varying, character varying, character varying)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_schema_name, a_table_name, a_geomfield_name - Returns the SRID defined for a geometry column.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	schem varchar =  $1;
	tabl varchar = $2;
	sr int4;
BEGIN
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and strpos(tabl,'.') > 0 ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	END IF;

	select SRID into sr from public.geometry_columns where (f_table_schema = schem or schem = '') and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - could not find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase mismatch?';
	END IF;
	return sr;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="format_phone_number(phone_number text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    formatted_phone_number TEXT;
BEGIN
    -- Remove all non-digit characters
    formatted_phone_number := regexp_replace(phone_number, '[^0-9]', '', 'g');
    IF (formatted_phone_number IS NULL or (length(formatted_phone_number) = 0)) then
		return null;
    END IF;
    -- Check if the first character is '1'
    IF left(formatted_phone_number, 1) = '1' THEN
        -- Add '+' in front of the phone number
        RETURN '+' || left(formatted_phone_number, 14);
    ELSE
        -- Add '+1' in front of the phone number
        RETURN '+1' || left(formatted_phone_number,13);
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="phone_number" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geog_brin_inclusion_add_value(internal, internal, internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geog_brin_inclusion_add_value]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography(bytea)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_from_binary]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography(geography, integer, boolean)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_enforce_typmod]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography(geometry)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_from_geometry]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_analyze(internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_analyze_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_cmp(geography, geography)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_cmp]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_distance_knn(geography, geography)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_distance_knn]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_eq(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_eq]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_ge(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_ge]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_compress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_consistent(internal, geography, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_decompress(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_distance(internal, geography, integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_geog_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_penalty(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_picksplit(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_same(box2d, box2d, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_same]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
            <parameter mode="IN" type="box2d"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geography_gist_union(bytea, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_union]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_gt(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_gt]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_in(cstring, oid, integer)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_le(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_le]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_lt(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_lt]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_out(geography)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_out]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_overlaps(geography, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_recv(internal, oid, integer)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_recv]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_send(geography)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_send]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_choose_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_choose_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_compress_nd(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_compress_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_config_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_config_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_inner_consistent_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_inner_consistent_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_leaf_consistent_nd(internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_leaf_consistent_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_spgist_picksplit_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_picksplit_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_typmod_in(cstring[])" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_typmod_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geography_typmod_out(integer)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_typmod_out]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom2d_brin_inclusion_add_value(internal, internal, internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom2d_brin_inclusion_add_value]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom3d_brin_inclusion_add_value(internal, internal, internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom3d_brin_inclusion_add_value]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom4d_brin_inclusion_add_value(internal, internal, internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom4d_brin_inclusion_add_value]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(box2d)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX2D_to_LWGEOM]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(box3d)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_to_LWGEOM]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_bytea]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(geography)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_from_geography]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(geometry, integer, boolean)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_enforce_typmod]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(path)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[path_to_geometry]]></definition>
         <parameters>
            <parameter mode="IN" type="path"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(point)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[point_to_geometry]]></definition>
         <parameters>
            <parameter mode="IN" type="point"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(polygon)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[polygon_to_geometry]]></definition>
         <parameters>
            <parameter mode="IN" type="polygon"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[parse_WKT_lwgeom]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_above(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_above_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_analyze(internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_analyze_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_below(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_below_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_cmp(geom1 geometry, geom2 geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_cmp]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contained_3d(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contained_3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains_3d(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_contains_nd(geometry, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_box(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_distance_box_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_centroid(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Distance]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_centroid_nd(geometry, geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_distance_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_distance_cpa(geometry, geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_DistanceCPA]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_eq(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_eq]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_ge(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_ge]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_compress_2d(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_compress_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_compress_nd(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_compress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_consistent_2d(internal, geometry, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_consistent_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_consistent_nd(internal, geometry, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_consistent]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_decompress_2d(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_decompress_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_decompress_nd(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_decompress]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_distance_2d(internal, geometry, integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_distance_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_distance_nd(internal, geometry, integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_distance]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_penalty_2d(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_penalty_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_penalty_nd(internal, internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_penalty]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_picksplit_2d(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_picksplit_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_picksplit_nd(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_picksplit]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_same_2d(geom1 geometry, geom2 geometry, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_same_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_same_nd(geometry, geometry, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_same]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_sortsupport_2d(internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_sortsupport_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_union_2d(bytea, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_union_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geometry_gist_union_nd(bytea, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_union]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_gt(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_gt]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_hash(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_hash]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_in(cstring)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_le(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_le]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_left(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_left_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_lt(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_lt]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_out(geometry)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_out]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overabove(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overabove_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overbelow(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overbelow_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overlaps_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps_3d(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overlaps_3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overlaps_nd(geometry, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overleft(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overleft_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_overright(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overright_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_recv(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_recv]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_right(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_right_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_same_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same_3d(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_same_3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_same_nd(geometry, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_same]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_send(geometry)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_send]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_sortsupport(internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[lwgeom_sortsupport]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_2d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_choose_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_3d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_choose_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_choose_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_choose_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_2d(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_compress_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_3d(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_compress_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_compress_nd(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_compress_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_2d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_config_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_3d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_config_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_config_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_config_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_2d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_inner_consistent_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_3d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_inner_consistent_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_inner_consistent_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_inner_consistent_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_2d(internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_leaf_consistent_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_3d(internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_leaf_consistent_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_leaf_consistent_nd(internal, internal)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_leaf_consistent_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_2d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_picksplit_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_3d(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_picksplit_3d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_spgist_picksplit_nd(internal, internal)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_spgist_picksplit_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_typmod_in(cstring[])" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_typmod_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_typmod_out(integer)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_typmod_out]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_within(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_within_2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometry_within_nd(geometry, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_within]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometrytype(geography)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_getTYPE]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometrytype(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the type of a geometry as text.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_getTYPE]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geomfromewkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOMFromEWKB]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geomfromewkt(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[parse_WKT_lwgeom]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="get_proj4_from_srid(integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[BEGIN
	RETURN proj4text::text FROM public.spatial_ref_sys WHERE srid= $1;
	END;]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gettransactionid()" returnType="xid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[getTransactionID]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gidx_in(cstring)" returnType="gidx" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gidx_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="gidx_out(gidx)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gidx_out]]></definition>
         <parameters>
            <parameter mode="IN" type="gidx"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_joinsel_2d(internal, oid, internal, smallint)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_joinsel_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_joinsel_nd(internal, oid, internal, smallint)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_joinsel_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="smallint"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_sel_2d(internal, oid, internal, integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_sel_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gserialized_gist_sel_nd(internal, oid, internal, integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gist_sel_nd]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="oid"/>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="insert_and_return_code(webeoc_value character varying, code_table_type character varying)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    new_code VARCHAR(10);  -- used in case we're creating a new code
    truncated_code varchar(10); -- if we're creating a new code, base it off of the webeoc_value.  We'll truncate this and get rid of spaces, and possibly append a number to make it unique
    truncated_short_description varchar(50); -- if we're creating a new short description, truncate this to 50 characters just in case it is too long
    live_code_value VARCHAR;
    current_utc_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    target_code_table VARCHAR;
    column_name VARCHAR;
    code_exists BOOLEAN;
    suffix VARCHAR(10) := ''; -- Suffix for uniqueness
    counter INTEGER := 1; -- Counter for unique code generation
    new_display_order INTEGER; -- used for setting the display_order value of the new code
    webeoc_user_id CONSTANT varchar(6) := 'webeoc';
   
BEGIN
    -- Truncate and uppercase the webEOC value, get rid of spaces, and truncate to 9 characters to ensure we have room for adding a number for uniqueness
    truncated_code := UPPER(LEFT(regexp_replace(webeoc_value, '\s', '', 'g'), 10));
   
    -- Return null if truncated_code is empty or null
    IF truncated_code IS NULL OR truncated_code = '' THEN
        RETURN NULL;
    END IF;

    truncated_short_description := LEFT(webeoc_value, 50);

    -- Resolve the target code table and column name based on code_table_type
    CASE code_table_type
        WHEN 'reprtdbycd' THEN
            target_code_table := 'reported_by_code';
            column_name := 'reported_by_code';
        WHEN 'geoorgutcd' THEN
            target_code_table := 'geo_organization_unit_code';
            column_name := 'geo_organization_unit_code';
        WHEN 'speciescd' THEN
            target_code_table := 'species_code';
            column_name := 'species_code';
        WHEN 'cmpltntrcd' THEN
            target_code_table := 'hwcr_complaint_nature_code';
            column_name := 'hwcr_complaint_nature_code';
        WHEN 'atractntcd' THEN
            target_code_table := 'attractant_code';
            column_name := 'attractant_code';
        WHEN 'violatncd' THEN
            target_code_table := 'violation_code';
            column_name := 'violation_code';
        WHEN 'girtypecd' THEN
            target_code_table := 'gir_type_code';
            column_name := 'gir_type_code';

        ELSE RAISE EXCEPTION 'Invalid code_table_type provided: %', code_table_type;
    END CASE;
    
    -- Check if the code exists in staging_metadata_mapping
    SELECT live_data_value INTO live_code_value
    FROM staging_metadata_mapping
    WHERE staged_data_value = webEOC_value
    AND entity_code = code_table_type;
    
    -- If the code exists, return the live_data_value
    IF live_code_value IS NOT NULL THEN
        RETURN live_code_value;
    END IF;
   

    -- We're creating a new code because the webeoc code doesn't exist in staging_metadata_mapping.  We want to add this new code to our code tables, as well as the staging_meta_mapping table.
    -- Before we create new codes in our code tables, we want to make sure we're not creating a duplicate.  If the new code doesn't exist
    -- in staging_metamapping, and the code doesn't exist in the code table, then create the code in both tables.
    -- If the code doesn't exist in staging_meta_mapping, but does exist in the code table, then create a new unique code
    -- in both the staging_meta_mapping table and the code table.

    loop

	    -- if a suffix is required, truncate the code to 9 characters so that there's room for the suffix
	    IF suffix <> '' THEN
            truncated_code := LEFT(truncated_code, 9);
        END IF;

        -- Append a numeric suffix if necessary
        new_code := truncated_code || suffix;
        
        -- Check if the new_code exists in the specific code table
        EXECUTE format('SELECT EXISTS(SELECT 1 FROM %I WHERE %I = $1)', target_code_table, column_name)
        INTO code_exists
        USING new_code;
        
        IF NOT code_exists then
        
        	-- Determine the correct display_order for the new code
            EXECUTE format('SELECT COALESCE(MAX(display_order) + 1, 1) FROM %I WHERE %I < $1', target_code_table, column_name)
            INTO new_display_order
            USING new_code;
           
			-- Re-index the display_orders
            EXECUTE format('UPDATE %I SET display_order = display_order + 1 WHERE display_order >= $1', target_code_table)
            USING new_display_order;
           
            -- Insert new code into the specific code table
            EXECUTE format('INSERT INTO %I (%I, short_description, long_description, active_ind, create_user_id, create_utc_timestamp, update_user_id, update_utc_timestamp, display_order) VALUES ($1, $2, $3, ''Y'', $6, $4, $6, $4, $5)', target_code_table, column_name)
            USING new_code, truncated_short_description, webeoc_value, current_utc_timestamp, new_display_order, webeoc_user_id;

            -- Update configuration_value by 1 to nofity front-end to update
            UPDATE configuration
            SET    configuration_value = configuration_value::int + 1
            WHERE  configuration_code = 'CDTABLEVER';

            -- Insert into staging_metadata_mapping
            INSERT INTO staging_metadata_mapping (entity_code, staged_data_value, live_data_value, create_user_id, create_utc_timestamp, update_user_id, update_utc_timestamp)
            VALUES (code_table_type, webeoc_value, new_code, webeoc_user_id, current_utc_timestamp, webeoc_user_id, current_utc_timestamp);

            RETURN new_code; -- Return the new unique code
        ELSE
            -- If the code exists, increment the suffix and try again
            suffix := counter::text;
            counter := counter + 1;
        END IF;
    END LOOP;
   
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="webeoc_value" type="character varying"/>
            <parameter mode="IN" name="code_table_type" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="insert_complaint_from_staging(_complaint_identifier character varying)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    WEBEOC_USER_ID CONSTANT varchar(6) := 'webeoc';
    WEBEOC_UPDATE_TYPE_INSERT CONSTANT varchar(6) := 'INSERT';
    STAGING_STATUS_CODE_PENDING CONSTANT varchar(7) := 'PENDING';
    STAGING_STATUS_CODE_SUCCESS CONSTANT varchar(7) := 'SUCCESS' ;
    STAGING_STATUS_CODE_ERROR CONSTANT varchar(5) := 'ERROR';
    METHOD_OF_COMPLAINT_RAPP CONSTANT varchar(5) := 'RAPP';
    
    -- jsonb attribute names
    jsonb_cos_primary_phone CONSTANT text := 'cos_primary_phone';
    jsonb_cos_alt_phone CONSTANT text := 'cos_alt_phone';
    jsonb_cos_alt_phone_2 CONSTANT text := 'cos_alt_phone_2';

    complaint_data jsonb;
    -- Variable to hold the JSONB data from staging_complaint.  Used to create a new complaint
    -- Variables for 'complaint' table
    _report_type            VARCHAR(120);
    _detail_text            TEXT;
    _caller_name            VARCHAR(120);
    _caller_address         VARCHAR(120);
    _caller_email           VARCHAR(120);
    _caller_phone_1         VARCHAR(15);
    _caller_phone_2         VARCHAR(15);
    _caller_phone_3         VARCHAR(15);
    _location_summary_text  VARCHAR(120);
    _location_detailed_text VARCHAR(4000);
    _incident_utc_datetime timestamp;
    _create_utc_timestamp timestamp := (now() AT TIME zone 'UTC');
    _update_utc_timestamp timestamp := (now() AT TIME zone 'UTC');
    _create_userid              VARCHAR(200);
    _update_userid              VARCHAR(200);
    _geo_organization_unit_code VARCHAR(10);
    _incident_reported_utc_timestmp timestamp;
    _address_coordinates_lat VARCHAR(200);
    _address_coordinates_long VARCHAR(200);
    _location_geometry_point GEOMETRY;
    _complaint_status_code VARCHAR(10);
    _webeoc_identifier VARCHAR(20);

    -- Variables for 'hwcr_complaint' table
    _webeoc_species                    VARCHAR(200);
    _webeoc_hwcr_complaint_nature_code VARCHAR(200);
    _webeoc_cos_area_community         VARCHAR(200);
    _webeoc_attracts_list              VARCHAR(1000);
    _species_code                      VARCHAR(10);
    _hwcr_complaint_nature_code        VARCHAR(10);
    _other_attractants_text            VARCHAR(4000);
    _cos_reffered_by_txt               VARCHAR(4000);
    _webeoc_cos_reffered_by_lst        VARCHAR(200);
    _cos_reffered_by_lst               VARCHAR(200);
    _in_progress_ind                   VARCHAR(3);
    _observed_ind                      VARCHAR(3);
    _in_progress_ind_bool bool;
    _observed_ind_bool bool;
    _suspect_witnesss_dtl_text TEXT;
    _violation_code            VARCHAR(10);
    _gir_type_code             VARCHAR(10);
    _gir_type_description      VARCHAR(50);
    -- used to generate a uuid.  We use this to create the PK in hwcr_complaint, but
    -- we need to also use it when creating the attractants
    generated_uuid uuid;
    -- parsed attractants from the jsonb object
    attractants_array text[];
    attractant_item text;
    _attractant_code VARCHAR(10);
  BEGIN -- Fetch the JSONB data from complaint_staging using the provided identifier
    SELECT sc.complaint_jsonb
    INTO   complaint_data
    FROM   staging_complaint sc
    WHERE  sc.complaint_identifier = _complaint_identifier
    AND    sc.staging_status_code = STAGING_STATUS_CODE_PENDING -- meaning that this complaint hasn't yet been moved to the complaint table yet
    AND    sc.staging_activity_code = WEBEOC_UPDATE_TYPE_INSERT; -- this means that we're dealing with a new complaint from webeoc, not an update
    
    IF complaint_data IS NULL THEN
      RETURN;
    END IF;

    _report_type := complaint_data ->> 'report_type';
    -- to link actions-taken to a complaint the dataid needs to be used
    _webeoc_identifier := complaint_data ->> 'dataid'; 

    -- Extract and prepare data for 'complaint' table
    _detail_text := complaint_data ->> 'cos_call_details';
    _caller_name := left( complaint_data ->> 'cos_caller_name', 100 )
    ||
    CASE
    WHEN length( complaint_data ->> 'cos_caller_name' ) > 100 THEN
      ' DATA TRUNCATED'
    ELSE
      ''
    END;
    _caller_address := left( complaint_data ->> 'caller_address', 100 )
    ||
    CASE
    WHEN length( complaint_data ->> 'caller_address' ) > 100 THEN
      ' DATA TRUNCATED'
    ELSE
      ''
    END;
    _caller_email := left( complaint_data ->> 'cos_caller_email', 100 )
    ||
    CASE
    WHEN length( complaint_data ->> 'cos_caller_email' ) > 100 THEN
      ' DATA TRUNCATED'
    ELSE
      ''
    END;

    _detail_text := complaint_data ->> 'cos_call_details';
	
    -- phone numbers must be formatted as +1##########.  
    -- If the numbers from webeoc contain non-numeric characters, strip those and 
    -- add the + (or +1) prefix
   
	_caller_phone_1 := format_phone_number(complaint_data ->> jsonb_cos_primary_phone);
	_caller_phone_2 := format_phone_number(complaint_data ->> jsonb_cos_alt_phone);
	_caller_phone_3 := format_phone_number(complaint_data ->> jsonb_cos_alt_phone_2);
  _complaint_status_code := UPPER(complaint_data ->> 'status');
	   
    _location_summary_text := left(complaint_data ->> 'address', 100)
    ||
    CASE
    WHEN length(complaint_data ->> 'address') > 100 THEN
      ' DATA TRUNCATED'
    ELSE
      ''
    END;
    _location_detailed_text := complaint_data ->> 'cos_location_description';
    _incident_utc_datetime := ( complaint_data ->> 'incident_datetime' ):: timestamp AT            TIME zone 'America/Los_Angeles';
    _incident_reported_utc_timestmp := ( complaint_data ->> 'created_by_datetime' ):: timestamp AT TIME zone 'America/Los_Angeles';
	_address_coordinates_lat := validate_coordinate_field(complaint_data ->> 'address_coordinates_lat');
    _address_coordinates_long := validate_coordinate_field(complaint_data ->> 'address_coordinates_long');
   
    -- Create a geometry point based on the latitude and longitude
    IF _address_coordinates_lat IS NOT NULL AND _address_coordinates_lat <> '' AND
       _address_coordinates_long IS NOT NULL AND _address_coordinates_long <> '' THEN
        _location_geometry_point := ST_SetSRID(
            ST_MakePoint(
                CAST(_address_coordinates_long AS NUMERIC),
                CAST(_address_coordinates_lat AS NUMERIC)
            ),
            4326
        );
    ELSE
    	_location_geometry_point := ST_SetSRID(ST_MakePoint(0, 0), 4326);
	END IF;

    _create_userid := substring(complaint_data ->> 'username' from 1 for 32);
    _update_userid := _create_userid;
    _webeoc_cos_area_community := complaint_data ->> 'cos_area_community';
    _webeoc_cos_reffered_by_lst := complaint_data ->> 'cos_reffered_by_lst';
    _cos_reffered_by_txt := left(complaint_data ->> '_cos_reffered_by_txt',120);

    SELECT *
    FROM   PUBLIC.insert_and_return_code( _webeoc_cos_reffered_by_lst, 'reprtdbycd' )
    INTO   _cos_reffered_by_lst;
    
    SELECT *
    FROM   PUBLIC.insert_and_return_code( _webeoc_cos_area_community, 'geoorgutcd' )
    INTO   _geo_organization_unit_code;
    
    -- Insert data into 'complaint' table
    INSERT INTO PUBLIC.complaint
                (
                            complaint_identifier,
                            detail_text,
                            caller_name,
                            caller_address,
                            caller_email,
                            caller_phone_1,
                            caller_phone_2,
                            caller_phone_3,
                            location_summary_text,
                            location_detailed_text,
                            incident_utc_datetime,
                            incident_reported_utc_timestmp,
                            create_user_id,
                            create_utc_timestamp,
                            update_user_id,
                            update_utc_timestamp,
                            owned_by_agency_code,
                            complaint_status_code,
                            geo_organization_unit_code,
                            location_geometry_point,
                            reported_by_code,
                            reported_by_other_text,
                            webeoc_identifier
                )
                VALUES
                (
                            _complaint_identifier,
                            _detail_text,
                            _caller_name,
                            _caller_address,
                            _caller_email,
                            _caller_phone_1,
                            _caller_phone_2,
                            _caller_phone_3,
                            _location_summary_text,
                            _location_detailed_text,
                            _incident_utc_datetime,
                            _incident_reported_utc_timestmp,
                            _create_userid,
                            _create_utc_timestamp,
                            _update_userid,
                            _update_utc_timestamp,
                            'COS',
                            _complaint_status_code,
                            _geo_organization_unit_code,
                            _location_geometry_point,
                            _cos_reffered_by_lst,
                            _cos_reffered_by_txt,
                            _webeoc_identifier
                );
    
    IF _report_type = 'HWCR' then
    
      -- convert webeoc species to our species code
	  _webeoc_species := complaint_data ->> 'species';
	  SELECT *
	  FROM   PUBLIC.insert_and_return_code(_webeoc_species, 'speciescd')
	  INTO   _species_code;
	    
	  _webeoc_hwcr_complaint_nature_code := complaint_data ->> 'nature_of_complaint';
	  SELECT *
	  FROM   PUBLIC.insert_and_return_code( _webeoc_hwcr_complaint_nature_code, 'cmpltntrcd' )
	  INTO   _hwcr_complaint_nature_code;
    
      -- Prepare data for 'hwcr_complaint' table
      _other_attractants_text := complaint_data ->> 'attractant_other_text';
      SELECT uuid_generate_v4()
      INTO   generated_uuid;
      
      -- Insert data into 'hwcr_complaint' table
      INSERT INTO PUBLIC.hwcr_complaint
                  (
                              hwcr_complaint_guid,
                              other_attractants_text,
                              create_user_id,
                              create_utc_timestamp,
                              update_user_id,
                              update_utc_timestamp,
                              complaint_identifier,
                              species_code,
                              hwcr_complaint_nature_code
                  )
                  VALUES
                  (
                              generated_uuid,
                              _other_attractants_text,
                              _create_userid,
                              _create_utc_timestamp,
                              _create_userid,
                              _update_utc_timestamp,
                              _complaint_identifier,
                              _species_code,
                              _hwcr_complaint_nature_code
                  );
      
      -- Convert the comma-separated list into an array
      attractants_array := string_to_array( complaint_data ->> 'attractants_list', ',' );
      -- Iterate over the array
      foreach attractant_item IN ARRAY attractants_array
      LOOP                                                -- Trim whitespace and check if the item is 'Not Applicable'
        IF trim(attractant_item) <> 'Not Applicable' THEN -- Your insertion logic here
          SELECT *
          FROM   PUBLIC.insert_and_return_code( trim(attractant_item), 'atractntcd' )
          INTO   _attractant_code;
          
          INSERT INTO PUBLIC.attractant_hwcr_xref
                      (
                                  attractant_code,
                                  hwcr_complaint_guid,
                                  create_user_id,
                                  create_utc_timestamp,
                                  update_user_id,
                                  update_utc_timestamp
                      )
                      VALUES
                      (
                                  _attractant_code,
                                  generated_uuid,
                                  WEBEOC_USER_ID,
                                  _create_utc_timestamp,
                                  WEBEOC_USER_ID,
                                  _update_utc_timestamp
                      );
        
        END IF;
      END LOOP;

    ELSIF _report_type = 'GIR' then
    
      -- Prepare data for 'gir_complaint' table
      _gir_type_description := complaint_data ->> 'call_type_gir';
      SELECT *
      FROM   PUBLIC.insert_and_return_code( _gir_type_description, 'girtypecd' )
      INTO   _gir_type_code;
      -- Insert data into 'gir_complaint' table
      INSERT INTO PUBLIC.gir_complaint
                  (
                              gir_complaint_guid,
                              create_user_id,
                              create_utc_timestamp,
                              update_user_id,
                              update_utc_timestamp,
                              complaint_identifier,
                              gir_type_code
                  )
                  VALUES
                  (
                              uuid_generate_v4(),
                              _create_userid,
                              _create_utc_timestamp,
                              _create_userid,
                              _update_utc_timestamp,
                              _complaint_identifier,
                              _gir_type_code
                  );
      
    ELSIF _report_type = 'ERS' THEN
      -- Extract and prepare data for 'allegation_complaint' table
      _in_progress_ind := (complaint_data->>'violation_in_progress');
      _observed_ind := (complaint_data->>'observe_violation');
      _suspect_witnesss_dtl_text := complaint_data->>'suspect_details';
      SELECT *
      FROM   PUBLIC.insert_and_return_code( complaint_data->>'violation_type', 'violatncd' )
      INTO   _violation_code;
      
      IF _in_progress_ind = 'Yes' THEN
        _in_progress_ind_bool := TRUE;
      ELSE
        _in_progress_ind_bool := FALSE;
      END IF;
      IF _observed_ind = 'Yes' THEN
        _observed_ind_bool := TRUE;
      ELSE
        _observed_ind_bool := FALSE;
      END IF;

      IF _violation_code = 'WASTE' OR _violation_code = 'PESTICDE' THEN
        UPDATE PUBLIC.complaint
        SET    owned_by_agency_code = 'EPO', complaint_status_code = 'OPEN'
        WHERE  complaint_identifier = _complaint_identifier;
      END IF;

      -- Insert data into 'allegation_complaint' table
      INSERT INTO PUBLIC.allegation_complaint
                  (
                  			  allegation_complaint_guid,
                              in_progress_ind,
                              observed_ind,
                              suspect_witnesss_dtl_text,
                              create_user_id,
                              create_utc_timestamp,
                              update_user_id,
                              update_utc_timestamp,
                              complaint_identifier,
                              violation_code
                  )
                  VALUES
                  (
                  			  uuid_generate_v4(),
                              _in_progress_ind_bool,
                              _observed_ind_bool,
                              _suspect_witnesss_dtl_text,
                              _create_userid,
                              _create_utc_timestamp,
                              _update_userid,
                              _update_utc_timestamp,
                              _complaint_identifier,
                              _violation_code
                  );
    
    END IF;
   
    UPDATE public.complaint 
    SET comp_mthd_recv_cd_agcy_cd_xref_guid = (
        SELECT comp_mthd_recv_cd_agcy_cd_xref_guid 
        FROM comp_mthd_recv_cd_agcy_cd_xref cmrcacx 
        WHERE complaint_method_received_code = METHOD_OF_COMPLAINT_RAPP
        AND cmrcacx.agency_code = complaint.owned_by_agency_code
    )
    WHERE complaint_identifier = _complaint_identifier;
    UPDATE staging_complaint
    SET    staging_status_code = STAGING_STATUS_CODE_SUCCESS
    WHERE  complaint_identifier = _complaint_identifier
    AND    staging_activity_code = WEBEOC_UPDATE_TYPE_INSERT;
  
  EXCEPTION
  WHEN OTHERS THEN
    RAISE notice 'An unexpected error occurred: %', SQLERRM;
    UPDATE staging_complaint
    SET    staging_status_code = STAGING_STATUS_CODE_ERROR
    WHERE  complaint_identifier = _complaint_identifier
    and staging_status_code = STAGING_STATUS_CODE_PENDING
    AND    staging_activity_code = WEBEOC_UPDATE_TYPE_INSERT;
  
  END;]]></definition>
         <parameters>
            <parameter mode="IN" name="_complaint_identifier" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="insert_complaint_update_from_staging(_complaint_identifier character varying, _update_number integer)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
   
    -- Variable to hold the JSONB data from staging_complaint. Used to create a new complaint
    update_complaint_data JSONB;
    UPDATE_NUMBER_TXT CONSTANT varchar(13) = 'update_number';
    WEBEOC_USER_ID CONSTANT varchar(6) := 'webeoc';
    WEBEOC_UPDATE_TYPE_INSERT CONSTANT varchar(6) := 'INSERT';
    STAGING_STATUS_CODE_PENDING CONSTANT varchar(7) := 'PENDING';
    STAGING_STATUS_CODE_SUCCESS CONSTANT varchar(7) := 'SUCCESS' ;
    STAGING_STATUS_CODE_UPDATE CONSTANT varchar(6) := 'UPDATE' ;
    STAGING_STATUS_CODE_ERROR CONSTANT varchar(5) := 'ERROR';
   
   
    
BEGIN
    -- Fetch the JSONB data from complaint_staging using the provided identifier
    SELECT sc.complaint_jsonb
    INTO   update_complaint_data
    FROM   staging_complaint sc
    WHERE  sc.complaint_identifier = _complaint_identifier
    AND    (sc.complaint_jsonb ->> UPDATE_NUMBER_TXT)::INT = _update_number
    AND    sc.staging_status_code = STAGING_STATUS_CODE_PENDING -- meaning that this complaint hasn't yet been moved to the complaint table yet
    AND    sc.staging_activity_code = STAGING_STATUS_CODE_UPDATE;

    -- This means that we're dealing with a new complaint from WebEOC, not an update
    IF update_complaint_data IS NULL THEN
        RETURN;
    END IF;
   
   -- update complaint data based on the incoming webeoc update, if necessary
   perform PUBLIC.update_complaint_using_webeoc_update(_complaint_identifier, update_complaint_data);
   
   -- create an update record if required
   perform PUBLIC.log_complaint_update(_complaint_identifier, update_complaint_data);

   -- Update staging_complaint to mark the process as successful
   UPDATE staging_complaint
   SET    staging_status_code = STAGING_STATUS_CODE_SUCCESS
   WHERE  complaint_identifier = _complaint_identifier
   AND    (complaint_jsonb ->> UPDATE_NUMBER_TXT)::INT = _update_number
   AND    staging_activity_code = STAGING_STATUS_CODE_UPDATE;

EXCEPTION
WHEN OTHERS THEN
    RAISE NOTICE 'An unexpected error occurred: %', SQLERRM;
    UPDATE staging_complaint
    SET    staging_status_code = STAGING_STATUS_CODE_ERROR
    WHERE  complaint_identifier = _complaint_identifier
    AND    staging_status_code = STAGING_STATUS_CODE_PENDING
    AND    (complaint_jsonb ->> UPDATE_NUMBER_TXT)::INT = _update_number
    AND    staging_activity_code = STAGING_STATUS_CODE_UPDATE;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="_complaint_identifier" type="character varying"/>
            <parameter mode="IN" name="_update_number" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="is_contained_2d(box2df, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_box2df_box2df_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="is_contained_2d(box2df, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_within_box2df_geom_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="is_contained_2d(geometry, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $2 OPERATOR(public.~) $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="json(geometry)" returnType="json" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_to_json]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="jsonb(geometry)" returnType="jsonb" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_to_jsonb]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein(text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[levenshtein]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein(text, text, integer, integer, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[levenshtein_with_costs]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein_less_equal(text, text, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[levenshtein_less_equal]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="levenshtein_less_equal(text, text, integer, integer, integer, integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[levenshtein_less_equal_with_costs]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lockrow(text, text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_table_name, a_row_key, an_auth_token - Sets lock/authorization for a row in a table.]]></comment>
         <definition language="sql"><![CDATA[SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lockrow(text, text, text, text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00');]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lockrow(text, text, text, text, timestamp without time zone)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_schema_name, a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	myschema alias for $1;
	mytable alias for $2;
	myrid   alias for $3;
	authid alias for $4;
	expires alias for $5;
	ret int;
	mytoid oid;
	myrec RECORD;

BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table WHERE expires < now()';

	SELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n
		WHERE c.relname = mytable
		AND c.relnamespace = n.oid
		AND n.nspname = myschema;

	-- RAISE NOTICE 'toid: %', mytoid;

	FOR myrec IN SELECT * FROM authorization_table WHERE
		toid = mytoid AND rid = myrid
	LOOP
		IF myrec.authid != authid THEN
			RETURN 0;
		ELSE
			RETURN 1;
		END IF;
	END LOOP;

	EXECUTE 'INSERT INTO authorization_table VALUES ('||
		quote_literal(mytoid::text)||','||quote_literal(myrid)||
		','||quote_literal(expires::text)||
		','||quote_literal(authid) ||')';

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="timestamp without time zone"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="lockrow(text, text, text, timestamp without time zone)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.]]></comment>
         <definition language="sql"><![CDATA[SELECT LockRow(current_schema(), $1, $2, $3, $4);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="timestamp without time zone"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="log_complaint_update(_complaint_identifier character varying, update_complaint_data jsonb)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    -- Variables for the current complaint record and the previous update record
    current_complaint_record PUBLIC.complaint;
    prev_complaint_update_record PUBLIC.complaint_update;

    -- Variables for 'complaint_update' table
    _upd_detail_text TEXT;
    _upd_location_summary_text VARCHAR(120);
    _upd_location_detailed_text VARCHAR(4000);
    _update_address_coordinates_lat VARCHAR(200);
    _update_address_coordinates_long VARCHAR(200);
    _upd_location_geometry_point GEOMETRY;
    _create_utc_timestamp TIMESTAMP := (NOW() AT TIME ZONE 'UTC');
    _update_utc_timestamp TIMESTAMP := (NOW() AT TIME ZONE 'UTC');
    _create_userid VARCHAR(200);
    _update_userid VARCHAR(200);
    _update_number INT4 = (update_complaint_data ->> 'update_number') ::INT;
    _update_number_exists BOOLEAN:= false; -- is this an update for a complaint with an update_number that already exists?  if so, edit it
    
    -- Variables for storing the changes to be inserted
    insert_upd_detail_text TEXT;
    insert_upd_location_summary_text VARCHAR(120);
    insert_upd_location_detailed_text VARCHAR(4000);
    insert_upd_location_geometry_point GEOMETRY;
    
    -- Flag to indicate if there's any difference
    has_difference BOOLEAN := FALSE;
   
    USERNAME_TXT CONSTANT varchar(8) = 'username';

	_webeoc_identifier VARCHAR(20);

BEGIN
    -- Get the current state of the complaint
    SELECT *
    INTO current_complaint_record
    FROM PUBLIC.complaint
    WHERE complaint_identifier = _complaint_identifier;

    -- Get the previous update, if any
    SELECT *
    INTO prev_complaint_update_record
    FROM PUBLIC.complaint_update
    WHERE complaint_identifier = _complaint_identifier
    ORDER BY update_seq_number DESC
    LIMIT 1;
   
   select exists (
     select 1
     from PUBLIC.complaint_update cu
	 where complaint_identifier = _complaint_identifier and update_seq_number = _update_number
   ) into _update_number_exists;

    -- Extract and prepare data for 'complaint_update' table
    _upd_detail_text := update_complaint_data ->> 'update_call_details';
    _upd_location_summary_text := update_complaint_data ->> 'update_address';
    _upd_location_detailed_text := update_complaint_data ->> 'update_location_description';
    _update_address_coordinates_lat := update_complaint_data ->> 'update_address_coordinates_lat';
    _update_address_coordinates_long := update_complaint_data ->> 'update_address_coordinates_long';
    _create_userid := substring(update_complaint_data ->> USERNAME_TXT from 1 for 32);
    _update_userid := substring(update_complaint_data ->> USERNAME_TXT from 1 for 32);
	_webeoc_identifier := update_complaint_data ->> 'dataid'; 

    -- Create a geometry point based on the latitude and longitude
    IF _update_address_coordinates_lat IS NOT NULL AND _update_address_coordinates_lat <> '' AND
       _update_address_coordinates_long IS NOT NULL AND _update_address_coordinates_long <> '' THEN
        _upd_location_geometry_point := ST_SetSRID(
            ST_MakePoint(
                CAST(_update_address_coordinates_long AS NUMERIC),
                CAST(_update_address_coordinates_lat AS NUMERIC)
            ),
            4326
        );
    END IF;

    -- Compare update_complaint_data against current_complaint_record and prev_complaint_update_record
    IF (_upd_detail_text IS NOT NULL AND _upd_detail_text <> '' AND
        (_upd_detail_text IS DISTINCT FROM prev_complaint_update_record.upd_detail_text OR prev_complaint_update_record.upd_detail_text IS NULL) AND
        (_upd_detail_text IS DISTINCT FROM current_complaint_record.detail_text OR current_complaint_record.detail_text IS NULL)) THEN
        insert_upd_detail_text := _upd_detail_text;
        has_difference := TRUE;
    ELSE
        insert_upd_detail_text := NULL;
    END IF;

    IF (_upd_location_summary_text IS NOT NULL AND _upd_location_summary_text <> '' AND
        (_upd_location_summary_text IS DISTINCT FROM prev_complaint_update_record.upd_location_summary_text OR prev_complaint_update_record.upd_location_summary_text IS NULL) AND
        (_upd_location_summary_text IS DISTINCT FROM current_complaint_record.location_summary_text OR current_complaint_record.location_summary_text IS NULL)) THEN
        insert_upd_location_summary_text := _upd_location_summary_text;
        has_difference := TRUE;
    ELSE
        insert_upd_location_summary_text := NULL;
    END IF;

    IF (_upd_location_detailed_text IS NOT NULL AND _upd_location_detailed_text <> '' AND
        (_upd_location_detailed_text IS DISTINCT FROM prev_complaint_update_record.upd_location_detailed_text OR prev_complaint_update_record.upd_location_detailed_text IS NULL) AND
        (_upd_location_detailed_text IS DISTINCT FROM current_complaint_record.location_detailed_text OR current_complaint_record.location_detailed_text IS NULL)) THEN
        insert_upd_location_detailed_text := _upd_location_detailed_text;
        has_difference := TRUE;
    ELSE
        insert_upd_location_detailed_text := NULL;
    END IF;

    IF (_upd_location_geometry_point IS NOT NULL AND
        (_upd_location_geometry_point IS DISTINCT FROM prev_complaint_update_record.upd_location_geometry_point OR prev_complaint_update_record.upd_location_geometry_point IS NULL) AND
        (_upd_location_geometry_point IS DISTINCT FROM current_complaint_record.location_geometry_point OR current_complaint_record.location_geometry_point IS NULL)) THEN
        insert_upd_location_geometry_point := _upd_location_geometry_point;
        has_difference := TRUE;
    ELSE
        insert_upd_location_geometry_point := NULL;
    END IF;

    -- Insert the record if there are any differences, either log the complaint or update the previously existing complaint
    IF has_difference then
    	if _update_number_exists then
	    	UPDATE PUBLIC.complaint_update 
	    		set upd_detail_text = insert_upd_detail_text,
		            upd_location_summary_text = insert_upd_location_summary_text,
		            upd_location_detailed_text = insert_upd_location_detailed_text,
		            upd_location_geometry_point = insert_upd_location_geometry_point,
		            update_user_id = _update_userid,
		            update_utc_timestamp = _update_utc_timestamp
		   where complaint_identifier = _complaint_identifier and update_seq_number = _update_number;
    	else
    	
	        INSERT INTO PUBLIC.complaint_update (
	            complaint_identifier,
	            update_seq_number,
	            upd_detail_text,
	            upd_location_summary_text,
	            upd_location_detailed_text,
	            upd_location_geometry_point,
	            create_user_id,
	            create_utc_timestamp,
	            update_user_id,
	            update_utc_timestamp,
				webeoc_identifier
	        ) VALUES (
	            _complaint_identifier,
	            _update_number,
	            insert_upd_detail_text,
	            insert_upd_location_summary_text,
	            insert_upd_location_detailed_text,
	            insert_upd_location_geometry_point,
	            _create_userid,
	            _create_utc_timestamp,
	            _update_userid,
	            _update_utc_timestamp,
				_webeoc_identifier
	        );
       end if;
       
       -- Update timestamp to latest
       UPDATE PUBLIC.complaint
       SET    update_utc_timestamp = _update_utc_timestamp, update_user_id = _update_userid
       WHERE  complaint_identifier = _complaint_identifier;
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="_complaint_identifier" type="character varying"/>
            <parameter mode="IN" name="update_complaint_data" type="jsonb"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="longtransactionsenabled()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="metaphone(text, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[metaphone]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_2d(box2df, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_contains_box2df_box2df_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_2d(box2df, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_overlaps_box2df_geom_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="box2df"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_2d(geometry, box2df)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $2 OPERATOR(public.&&) $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="box2df"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_geog(geography, gidx)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $2 OPERATOR(public.&&) $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="gidx"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_geog(gidx, geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gidx_geog_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="gidx"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_geog(gidx, gidx)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gidx_gidx_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="gidx"/>
            <parameter mode="IN" type="gidx"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_nd(geometry, gidx)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT $2 OPERATOR(public.&&&) $1;]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="gidx"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_nd(gidx, geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gidx_geom_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="gidx"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="overlaps_nd(gidx, gidx)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[gserialized_gidx_gidx_overlaps]]></definition>
         <parameters>
            <parameter mode="IN" type="gidx"/>
            <parameter mode="IN" type="gidx"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="path(geometry)" returnType="path" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_to_path]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asflatgeobuf_finalfn(internal)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asflatgeobuf_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asflatgeobuf_transfn(internal, anyelement)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asflatgeobuf_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asflatgeobuf_transfn(internal, anyelement, boolean)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asflatgeobuf_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asflatgeobuf_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asgeobuf_finalfn(internal)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asgeobuf_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asgeobuf_transfn(internal, anyelement)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asgeobuf_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asgeobuf_transfn(internal, anyelement, text)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asgeobuf_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_combinefn(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_combinefn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_deserialfn(bytea, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_deserialfn]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_finalfn(internal)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_serialfn(internal)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_serialfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn(internal, anyelement)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn(internal, anyelement, text)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn(internal, anyelement, text, integer)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn(internal, anyelement, text, integer, text)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_asmvt_transfn(internal, anyelement, text, integer, text, text)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_asmvt_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_accum_transfn(internal, geometry)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_accum_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_accum_transfn(internal, geometry, double precision)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_accum_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_accum_transfn(internal, geometry, double precision, integer)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_accum_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_clusterintersecting_finalfn(internal)" returnType="geometry[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_clusterintersecting_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_clusterwithin_finalfn(internal)" returnType="geometry[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_clusterwithin_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_collect_finalfn(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_collect_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_coverageunion_finalfn(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_coverageunion_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_makeline_finalfn(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_makeline_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgis_geometry_polygonize_finalfn(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_polygonize_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_combinefn(internal, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_combinefn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_deserialfn(bytea, internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_deserialfn]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_finalfn(internal)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_finalfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_serialfn(internal)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_serialfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_transfn(internal, geometry)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgis_geometry_union_parallel_transfn(internal, geometry, double precision)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_geometry_union_parallel_transfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="point(geometry)" returnType="point" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_to_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="polygon(geometry)" returnType="polygon" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geometry_to_polygon]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="populate_geometry_columns(tbl_oid oid, use_typmod boolean DEFAULT true)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: relation_oid, use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	gcs		 RECORD;
	gc		  RECORD;
	gc_old	  RECORD;
	gsrid	   integer;
	gndims	  integer;
	gtype	   text;
	query	   text;
	gc_is_valid boolean;
	inserted	integer;
	constraint_successful boolean := false;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname, c.relkind
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind IN('r', 'f', 'p')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

		RAISE DEBUG 'Processing column %.%.%', gcs.nspname, gcs.relname, gcs.attname;

		gc_is_valid := true;
		-- Find the srid, coord_dimension, and type of current geometry
		-- in geometry_columns -- which is now a view

		SELECT type, srid, coord_dimension, gcs.relkind INTO gc_old
			FROM geometry_columns
			WHERE f_table_schema = gcs.nspname AND f_table_name = gcs.relname AND f_geometry_column = gcs.attname;

		IF upper(gc_old.type) = 'GEOMETRY' THEN
		-- This is an unconstrained geometry we need to do something
		-- We need to figure out what to set the type by inspecting the data
			EXECUTE 'SELECT public.ST_srid(' || quote_ident(gcs.attname) || ') As srid, public.GeometryType(' || quote_ident(gcs.attname) || ') As type, public.ST_NDims(' || quote_ident(gcs.attname) || ') As dims ' ||
					 ' FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||
					 ' WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1;'
				INTO gc;
			IF gc IS NULL THEN -- there is no data so we can not determine geometry type
				RAISE WARNING 'No data in table %.%, so no information to determine geometry type and srid', gcs.nspname, gcs.relname;
				RETURN 0;
			END IF;
			gsrid := gc.srid; gtype := gc.type; gndims := gc.dims;

			IF use_typmod THEN
				BEGIN
					EXECUTE 'ALTER TABLE ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || ' ALTER COLUMN ' || quote_ident(gcs.attname) ||
						' TYPE geometry(' || postgis_type_name(gtype, gndims, true) || ', ' || gsrid::text  || ') ';
					inserted := inserted + 1;
				EXCEPTION
						WHEN invalid_parameter_value OR feature_not_supported THEN
						RAISE WARNING 'Could not convert ''%'' in ''%.%'' to use typmod with srid %, type %: %', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), gsrid, postgis_type_name(gtype, gndims, true), SQLERRM;
							gc_is_valid := false;
				END;

			ELSE
				-- Try to apply srid check to column
				constraint_successful = false;
				IF (gsrid > 0 AND postgis_constraint_srid(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
					BEGIN
						EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||
								 ' ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) ||
								 ' CHECK (ST_srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
						constraint_successful := true;
					EXCEPTION
						WHEN check_violation THEN
							RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
							gc_is_valid := false;
					END;
				END IF;

				-- Try to apply ndims check to column
				IF (gndims IS NOT NULL AND postgis_constraint_dims(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
					BEGIN
						EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
								 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
								 CHECK (st_ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
						constraint_successful := true;
					EXCEPTION
						WHEN check_violation THEN
							RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
							gc_is_valid := false;
					END;
				END IF;

				-- Try to apply geometrytype check to column
				IF (gtype IS NOT NULL AND postgis_constraint_type(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN
					BEGIN
						EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
						CHECK (geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ')';
						constraint_successful := true;
					EXCEPTION
						WHEN check_violation THEN
							-- No geometry check can be applied. This column contains a number of geometry types.
							RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
					END;
				END IF;
				 --only count if we were successful in applying at least one constraint
				IF constraint_successful THEN
					inserted := inserted + 1;
				END IF;
			END IF;
		END IF;

	END LOOP;

	RETURN inserted;
END]]></definition>
         <parameters>
            <parameter mode="IN" name="tbl_oid" type="oid"/>
            <parameter mode="IN" name="use_typmod" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="populate_geometry_columns(use_typmod boolean DEFAULT true)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	inserted	integer;
	oldcount	integer;
	probed	  integer;
	stale	   integer;
	gcs		 RECORD;
	gc		  RECORD;
	gsrid	   integer;
	gndims	  integer;
	gtype	   text;
	query	   text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM public.geometry_columns;
	inserted := 0;

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE c.relkind IN('r','v','f', 'p')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind IN( 'r', 'f', 'p')
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns'
	LOOP

		inserted := inserted + public.populate_geometry_columns(gcs.oid, use_typmod);
	END LOOP;

	IF oldcount > inserted THEN
		stale = oldcount-inserted;
	ELSE
		stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted;
END]]></definition>
         <parameters>
            <parameter mode="IN" name="use_typmod" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_addbbox(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Add bounding box to the geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_addBBOX]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_cache_bbox()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[cache_bbox]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
			FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %';]]></definition>
         <parameters>
            <parameter mode="IN" name="geomschema" type="text"/>
            <parameter mode="IN" name="geomtable" type="text"/>
            <parameter mode="IN" name="geomcolumn" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
			FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %';]]></definition>
         <parameters>
            <parameter mode="IN" name="geomschema" type="text"/>
            <parameter mode="IN" name="geomtable" type="text"/>
            <parameter mode="IN" name="geomcolumn" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_constraint_type(geomschema text, geomtable text, geomcolumn text)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar
		 FROM pg_class c, pg_namespace n, pg_attribute a
		 , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc
			FROM pg_constraint) AS s
		 WHERE n.nspname = $1
		 AND c.relname = $2
		 AND a.attname = $3
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %';]]></definition>
         <parameters>
            <parameter mode="IN" name="geomschema" type="text"/>
            <parameter mode="IN" name="geomtable" type="text"/>
            <parameter mode="IN" name="geomcolumn" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_dropbbox(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Drop the bounding box cache from the geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dropBBOX]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_extensions_upgrade(target_version text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: target_version=null - Packages and upgrades PostGIS extensions (e.g. postgis_raster,postgis_topology, postgis_sfcgal) to given or latest version.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	rec record;
	sql text;
	var_schema text;
BEGIN

	FOR rec IN
		SELECT name, default_version, installed_version
		FROM pg_catalog.pg_available_extensions
		WHERE name IN (
			'postgis',
			'postgis_raster',
			'postgis_sfcgal',
			'postgis_topology',
			'postgis_tiger_geocoder'
		)
		ORDER BY length(name) -- this is to make sure 'postgis' is first !
	LOOP --{

		IF target_version IS NULL THEN
			target_version := rec.default_version;
		END IF;

		IF rec.installed_version IS NULL THEN --{
			-- If the support installed by available extension
			-- is found unpackaged, we package it
			IF --{
				 -- PostGIS is always available (this function is part of it)
				 rec.name = 'postgis'

				 -- PostGIS raster is available if type 'raster' exists
				 OR ( rec.name = 'postgis_raster' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_type
							WHERE typname = 'raster' ) )

				 -- PostGIS SFCGAL is availble if
				 -- 'postgis_sfcgal_version' function exists
				 OR ( rec.name = 'postgis_sfcgal' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_proc
							WHERE proname = 'postgis_sfcgal_version' ) )

				 -- PostGIS Topology is available if
				 -- 'topology.topology' table exists
				 -- NOTE: watch out for https://trac.osgeo.org/postgis/ticket/2503
				 OR ( rec.name = 'postgis_topology' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'topology' AND c.relname = 'topology') )

				 OR ( rec.name = 'postgis_tiger_geocoder' AND EXISTS (
							SELECT 1 FROM pg_catalog.pg_class c
							JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )
							WHERE n.nspname = 'tiger' AND c.relname = 'geocode_settings') )
			THEN --}{ -- the code is unpackaged
				-- Force install in same schema as postgis
				SELECT INTO var_schema n.nspname
				  FROM pg_namespace n, pg_proc p
				  WHERE p.proname = 'postgis_full_version'
					AND n.oid = p.pronamespace
				  LIMIT 1;
				IF rec.name NOT IN('postgis_topology', 'postgis_tiger_geocoder')
				THEN
					sql := format(
							  'CREATE EXTENSION %1$I SCHEMA %2$I VERSION unpackaged;'
							  'ALTER EXTENSION %1$I UPDATE TO %3$I',
							  rec.name, var_schema, target_version);
				ELSE
					sql := format(
							 'CREATE EXTENSION %1$I VERSION unpackaged;'
							 'ALTER EXTENSION %1$I UPDATE TO %2$I',
							 rec.name, target_version);
				END IF;
				RAISE NOTICE 'Packaging and updating %', rec.name;
				RAISE DEBUG '%', sql;
				EXECUTE sql;
			ELSE
				RAISE DEBUG 'Skipping % (not in use)', rec.name;
			END IF; --}
		ELSE -- The code is already packaged, upgrade it --}{
			sql = format(
				'ALTER EXTENSION %1$I UPDATE TO "ANY";'
				'ALTER EXTENSION %1$I UPDATE TO %2$I',
				rec.name, target_version
				);
			RAISE NOTICE 'Updating extension % %', rec.name, rec.installed_version;
			RAISE DEBUG '%', sql;
			EXECUTE sql;
		END IF; --}

	END LOOP; --}

	RETURN format(
		'Upgrade to version %s completed, run SELECT postgis_full_version(); for details',
		target_version
	);


END]]></definition>
         <parameters>
            <parameter mode="IN" name="target_version" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_full_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Reports full PostGIS version and build configuration infos.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	libver text;
	librev text;
	projver text;
	geosver text;
	geosver_compiled text;
	sfcgalver text;
	gdalver text := NULL;
	libxmlver text;
	liblwgeomver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text := NULL;
	rast_scr_ver text := NULL;
	topo_scr_ver text := NULL;
	json_lib_ver text;
	protobuf_lib_ver text;
	wagyu_lib_ver text;
	sfcgal_lib_ver text;
	sfcgal_scr_ver text;
	pgsql_scr_ver text;
	pgsql_ver text;
	core_is_extension bool;
BEGIN
	SELECT public.postgis_lib_version() INTO libver;
	SELECT public.postgis_proj_version() INTO projver;
	SELECT public.postgis_geos_version() INTO geosver;
	SELECT public.postgis_geos_compiled_version() INTO geosver_compiled;
	SELECT public.postgis_libjson_version() INTO json_lib_ver;
	SELECT public.postgis_libprotobuf_version() INTO protobuf_lib_ver;
	SELECT public.postgis_wagyu_version() INTO wagyu_lib_ver;
	SELECT public._postgis_scripts_pgsql_version() INTO pgsql_scr_ver;
	SELECT public._postgis_pgsql_version() INTO pgsql_ver;
	BEGIN
		SELECT public.postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	BEGIN
		SELECT public.postgis_sfcgal_full_version() INTO sfcgalver;
		BEGIN
			SELECT public.postgis_sfcgal_scripts_installed() INTO sfcgal_scr_ver;
		EXCEPTION
			WHEN undefined_function THEN
				sfcgal_scr_ver := 'missing';
		END;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_sfcgal_scripts_installed() not found. Is sfcgal support enabled and sfcgal.sql installed?';
	END;
	SELECT public.postgis_liblwgeom_version() INTO liblwgeomver;
	SELECT public.postgis_libxml_version() INTO libxmlver;
	SELECT public.postgis_scripts_installed() INTO dbproc;
	SELECT public.postgis_scripts_released() INTO relproc;
	SELECT public.postgis_lib_revision() INTO librev;
	BEGIN
		SELECT topology.postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function OR invalid_schema_name THEN
			RAISE DEBUG 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
		WHEN insufficient_privilege THEN
			RAISE NOTICE 'Topology support cannot be inspected. Is current user granted USAGE on schema "topology" ?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_topology_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	BEGIN
		SELECT public.postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			RAISE DEBUG 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
		WHEN OTHERS THEN
			RAISE NOTICE 'Function postgis_raster_lib_version() could not be called: % (%)', SQLERRM, SQLSTATE;
	END;

	fullver = 'POSTGIS="' || libver;

	IF  librev IS NOT NULL THEN
		fullver = fullver || ' ' || librev;
	END IF;

	fullver = fullver || '"';

	IF EXISTS (
		SELECT * FROM pg_catalog.pg_extension
		WHERE extname = 'postgis')
	THEN
			fullver = fullver || ' [EXTENSION]';
			core_is_extension := true;
	ELSE
			core_is_extension := false;
	END IF;

	IF liblwgeomver != relproc THEN
		fullver = fullver || ' (liblwgeom version mismatch: "' || liblwgeomver || '")';
	END IF;

	fullver = fullver || ' PGSQL="' || pgsql_scr_ver || '"';
	IF pgsql_scr_ver != pgsql_ver THEN
		fullver = fullver || ' (procs need upgrade for use with PostgreSQL "' || pgsql_ver || '")';
	END IF;

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS="' || geosver || '"';
		IF (string_to_array(geosver, '.'))[1:2] != (string_to_array(geosver_compiled, '.'))[1:2]
		THEN
			fullver = format('%s (compiled against GEOS %s)', fullver, geosver_compiled);
		END IF;
	END IF;

	IF  sfcgalver IS NOT NULL THEN
		fullver = fullver || ' SFCGAL="' || sfcgalver || '"';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ="' || projver || '"';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL="' || gdalver || '"';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML="' || libxmlver || '"';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON="' || json_lib_ver || '"';
	END IF;

	IF protobuf_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBPROTOBUF="' || protobuf_lib_ver || '"';
	END IF;

	IF wagyu_lib_ver IS NOT NULL THEN
		fullver = fullver || ' WAGYU="' || wagyu_lib_ver || '"';
	END IF;

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from "' || dbproc || '" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from "' || topo_scr_ver || '" need upgrade)';
		END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_topology')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from "' || rast_lib_ver || '" need upgrade)';
		END IF;
		IF core_is_extension AND NOT EXISTS (
			SELECT * FROM pg_catalog.pg_extension
			WHERE extname = 'postgis_raster')
		THEN
				fullver = fullver || ' [UNPACKAGED!]';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from "' || rast_scr_ver || '" need upgrade)';
	END IF;

	IF sfcgal_scr_ver IS NOT NULL AND sfcgal_scr_ver != relproc THEN
		fullver = fullver || ' (sfcgal procs from "' || sfcgal_scr_ver || '" need upgrade)';
	END IF;

	-- Check for the presence of deprecated functions
	IF EXISTS ( SELECT oid FROM pg_catalog.pg_proc WHERE proname LIKE '%_deprecated_by_postgis_%' )
	THEN
		fullver = fullver || ' (deprecated functions exist, upgrade is not complete)';
	END IF;

	RETURN fullver;
END]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_geos_compiled_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the GEOS library against which PostGIS was built.]]></comment>
         <definition language="c"><![CDATA[postgis_geos_compiled_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_geos_noop(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[GEOSnoop]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_geos_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the GEOS library.]]></comment>
         <definition language="c"><![CDATA[postgis_geos_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_getbbox(geometry)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_BOX2DF]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_hasbbox(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns TRUE if the bbox of this geometry is cached, FALSE otherwise.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_hasBBOX]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="postgis_index_supportfn(internal)" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_index_supportfn]]></definition>
         <parameters>
            <parameter mode="IN" type="internal"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_lib_build_date()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns build date of the PostGIS library.]]></comment>
         <definition language="c"><![CDATA[postgis_lib_build_date]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_lib_revision()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_lib_revision]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_lib_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the PostGIS library.]]></comment>
         <definition language="c"><![CDATA[postgis_lib_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libjson_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_libjson_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_liblwgeom_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the liblwgeom library. This should match the version of PostGIS.]]></comment>
         <definition language="c"><![CDATA[postgis_liblwgeom_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libprotobuf_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_libprotobuf_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_libxml_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the libxml2 library.]]></comment>
         <definition language="c"><![CDATA[postgis_libxml_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_noop(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_noop]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_proj_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the PROJ4 library.]]></comment>
         <definition language="c"><![CDATA[postgis_proj_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_build_date()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns build date of the PostGIS scripts.]]></comment>
         <definition language="sql"><![CDATA[SELECT '2024-09-11 18:11:28'::text AS version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_installed()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns version of the PostGIS scripts installed in this database.]]></comment>
         <definition language="sql"><![CDATA[SELECT trim('3.4.3'::text || $rev$ e365945 $rev$) AS version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_scripts_released()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the postgis.sql script released with the installed PostGIS lib.]]></comment>
         <definition language="c"><![CDATA[postgis_scripts_released]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_srs(auth_name text, auth_srid text)" returnType="TABLE(auth_name text, auth_srid text, srname text, srtext text, proj4text text, point_sw geometry, point_ne geometry)" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_name, auth_srid - Return a metadata record for the requested authority and srid.]]></comment>
         <definition language="c"><![CDATA[postgis_srs_entry]]></definition>
         <parameters>
            <parameter mode="IN" name="auth_name" type="text"/>
            <parameter mode="IN" name="auth_srid" type="text"/>
            <parameter mode="TABLE" name="auth_name" type="text"/>
            <parameter mode="TABLE" name="auth_srid" type="text"/>
            <parameter mode="TABLE" name="srname" type="text"/>
            <parameter mode="TABLE" name="srtext" type="text"/>
            <parameter mode="TABLE" name="proj4text" type="text"/>
            <parameter mode="TABLE" name="point_sw" type="geometry"/>
            <parameter mode="TABLE" name="point_ne" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_srs_all()" returnType="TABLE(auth_name text, auth_srid text, srname text, srtext text, proj4text text, point_sw geometry, point_ne geometry)" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Return metadata records for every spatial reference system in the underlying Proj database.]]></comment>
         <definition language="c"><![CDATA[postgis_srs_entry_all]]></definition>
         <parameters>
            <parameter mode="TABLE" name="auth_name" type="text"/>
            <parameter mode="TABLE" name="auth_srid" type="text"/>
            <parameter mode="TABLE" name="srname" type="text"/>
            <parameter mode="TABLE" name="srtext" type="text"/>
            <parameter mode="TABLE" name="proj4text" type="text"/>
            <parameter mode="TABLE" name="point_sw" type="geometry"/>
            <parameter mode="TABLE" name="point_ne" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_srs_codes(auth_name text)" returnType="SETOF text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_name - Return the list of SRS codes associated with the given authority.]]></comment>
         <definition language="c"><![CDATA[postgis_srs_codes]]></definition>
         <parameters>
            <parameter mode="IN" name="auth_name" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_srs_search(bounds geometry, authname text DEFAULT 'EPSG'::text)" returnType="TABLE(auth_name text, auth_srid text, srname text, srtext text, proj4text text, point_sw geometry, point_ne geometry)" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: bounds, auth_name=EPSG - Return metadata records for projected coordinate systems that have areas of useage that fully contain the bounds parameter.]]></comment>
         <definition language="c"><![CDATA[postgis_srs_search]]></definition>
         <parameters>
            <parameter mode="IN" name="bounds" type="geometry"/>
            <parameter mode="IN" name="authname" type="text"/>
            <parameter mode="TABLE" name="auth_name" type="text"/>
            <parameter mode="TABLE" name="auth_srid" type="text"/>
            <parameter mode="TABLE" name="srname" type="text"/>
            <parameter mode="TABLE" name="srtext" type="text"/>
            <parameter mode="TABLE" name="proj4text" type="text"/>
            <parameter mode="TABLE" name="point_sw" type="geometry"/>
            <parameter mode="TABLE" name="point_ne" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_svn_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._postgis_deprecate(
		'postgis_svn_version', 'postgis_lib_revision', '3.1.0');
	SELECT public.postgis_lib_revision();]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_transform_geometry(geom geometry, text, text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[transform_geom]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_transform_pipeline_geometry(geom geometry, pipeline text, forward boolean, to_srid integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[transform_pipeline_geom]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="pipeline" type="text"/>
            <parameter mode="IN" name="forward" type="boolean"/>
            <parameter mode="IN" name="to_srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname
	FROM
	( VALUES
			('GEOMETRY', 'Geometry', 2),
			('GEOMETRY', 'GeometryZ', 3),
			('GEOMETRYM', 'GeometryM', 3),
			('GEOMETRY', 'GeometryZM', 4),

			('GEOMETRYCOLLECTION', 'GeometryCollection', 2),
			('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3),
			('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3),
			('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4),

			('POINT', 'Point', 2),
			('POINT', 'PointZ', 3),
			('POINTM','PointM', 3),
			('POINT', 'PointZM', 4),

			('MULTIPOINT','MultiPoint', 2),
			('MULTIPOINT','MultiPointZ', 3),
			('MULTIPOINTM','MultiPointM', 3),
			('MULTIPOINT','MultiPointZM', 4),

			('POLYGON', 'Polygon', 2),
			('POLYGON', 'PolygonZ', 3),
			('POLYGONM', 'PolygonM', 3),
			('POLYGON', 'PolygonZM', 4),

			('MULTIPOLYGON', 'MultiPolygon', 2),
			('MULTIPOLYGON', 'MultiPolygonZ', 3),
			('MULTIPOLYGONM', 'MultiPolygonM', 3),
			('MULTIPOLYGON', 'MultiPolygonZM', 4),

			('MULTILINESTRING', 'MultiLineString', 2),
			('MULTILINESTRING', 'MultiLineStringZ', 3),
			('MULTILINESTRINGM', 'MultiLineStringM', 3),
			('MULTILINESTRING', 'MultiLineStringZM', 4),

			('LINESTRING', 'LineString', 2),
			('LINESTRING', 'LineStringZ', 3),
			('LINESTRINGM', 'LineStringM', 3),
			('LINESTRING', 'LineStringZM', 4),

			('CIRCULARSTRING', 'CircularString', 2),
			('CIRCULARSTRING', 'CircularStringZ', 3),
			('CIRCULARSTRINGM', 'CircularStringM' ,3),
			('CIRCULARSTRING', 'CircularStringZM', 4),

			('COMPOUNDCURVE', 'CompoundCurve', 2),
			('COMPOUNDCURVE', 'CompoundCurveZ', 3),
			('COMPOUNDCURVEM', 'CompoundCurveM', 3),
			('COMPOUNDCURVE', 'CompoundCurveZM', 4),

			('CURVEPOLYGON', 'CurvePolygon', 2),
			('CURVEPOLYGON', 'CurvePolygonZ', 3),
			('CURVEPOLYGONM', 'CurvePolygonM', 3),
			('CURVEPOLYGON', 'CurvePolygonZM', 4),

			('MULTICURVE', 'MultiCurve', 2),
			('MULTICURVE', 'MultiCurveZ', 3),
			('MULTICURVEM', 'MultiCurveM', 3),
			('MULTICURVE', 'MultiCurveZM', 4),

			('MULTISURFACE', 'MultiSurface', 2),
			('MULTISURFACE', 'MultiSurfaceZ', 3),
			('MULTISURFACEM', 'MultiSurfaceM', 3),
			('MULTISURFACE', 'MultiSurfaceZM', 4),

			('POLYHEDRALSURFACE', 'PolyhedralSurface', 2),
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ', 3),
			('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM', 3),
			('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM', 4),

			('TRIANGLE', 'Triangle', 2),
			('TRIANGLE', 'TriangleZ', 3),
			('TRIANGLEM', 'TriangleM', 3),
			('TRIANGLE', 'TriangleZM', 4),

			('TIN', 'Tin', 2),
			('TIN', 'TinZ', 3),
			('TINM', 'TinM', 3),
			('TIN', 'TinZM', 4) )
			 As g(old_name, new_name, coord_dimension)
	WHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))
		AND coord_dimension = $2;]]></definition>
         <parameters>
            <parameter mode="IN" name="geomname" type="character varying"/>
            <parameter mode="IN" name="coord_dimension" type="integer"/>
            <parameter mode="IN" name="use_new_name" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_dims(integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_typmod_dims]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_srid(integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_typmod_srid]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_typmod_type(integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[postgis_typmod_type]]></definition>
         <parameters>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns PostGIS version number and compile-time options.]]></comment>
         <definition language="c"><![CDATA[postgis_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="postgis_wagyu_version()" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[Returns the version number of the internal Wagyu library.]]></comment>
         <definition language="c"><![CDATA[postgis_wagyu_version]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="process_staging_activity_taken(staging_id uuid, action_taken_type character varying)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
  WEBEOC_USER_ID CONSTANT varchar(6) := 'webeoc'; 
  WEBEOC_ACTION_TIMESTAMP CONSTANT timestamp := NOW()::timestamp;

  STAGING_STATUS_CODE_PENDING CONSTANT varchar(7) := 'PENDING';
  STAGING_STATUS_CODE_SUCCESS CONSTANT varchar(7) := 'SUCCESS' ;
  STAGING_STATUS_CODE_ERROR CONSTANT varchar(5) := 'ERROR';
  
  -- select the stage object
  staged_data jsonb;

  _action_taken_id        UUID;
  _complaint_update_id    UUID;
  _complaint_id			  VARCHAR(20);
  _logged_by              VARCHAR(250);
  _action_timestamp       TIMESTAMP;
  _details                TEXT;
  _is_update              BOOL;
 
BEGIN

RAISE notice 'EXECUTING FUNCTION';

  SELECT sc.complaint_jsonb
  INTO   staged_data
  FROM   staging_complaint sc
  WHERE  sc.staging_complaint_guid = staging_id
  AND    sc.staging_status_code = STAGING_STATUS_CODE_PENDING 
  AND    sc.staging_activity_code = action_taken_type; 
    
  IF staged_data IS NULL THEN
	  -- RAISE notice 'NO COMPLAINT FOUND'; No complaint found is expected now for actions taken on complaints prior to Jan 1 2025
    RETURN;
  END IF;

  _action_taken_id := staged_data ->> 'actionTakenId';
  _complaint_id := staged_data ->> 'complaintId';
  _complaint_update_id := staged_data ->> 'complaintUpdateGuid';
  _logged_by := staged_data ->> 'loggedBy';
  _action_timestamp := (staged_data ->> 'actionTimestamp')::timestamp AT TIME ZONE 'America/Vancouver';
  _details := staged_data ->> 'details';
  _is_update := staged_data ->> 'isUpdate';

  -- insert new action-taken
  INSERT INTO public.action_taken (
    action_taken_guid, 
    complaint_identifier, 
    complaint_update_guid, 
    action_details_txt, 
    logged_by_txt, 
    action_utc_timestamp, create_user_id, create_utc_timestamp, update_user_id, update_utc_timestamp
  )
  VALUES (
    _action_taken_id, 
    _complaint_id, 
    _complaint_update_id, 
    _details, 
    _logged_by, 
    _action_timestamp, 
    WEBEOC_USER_ID, WEBEOC_ACTION_TIMESTAMP, WEBEOC_USER_ID, WEBEOC_ACTION_TIMESTAMP
  );

  -- update the staging table
  UPDATE staging_complaint
  SET    staging_status_code = STAGING_STATUS_CODE_SUCCESS
  WHERE  staging_complaint_guid = staging_id
  AND    staging_status_code = STAGING_STATUS_CODE_PENDING 
  AND    staging_activity_code = action_taken_type;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE notice 'An unexpected error occurred: %', SQLERRM;
    UPDATE staging_complaint
    SET    staging_status_code = STAGING_STATUS_CODE_ERROR
    WHERE  staging_complaint_guid = staging_id
    AND    staging_status_code = STAGING_STATUS_CODE_PENDING 
    AND    staging_activity_code = action_taken_type;
  

END;]]></definition>
         <parameters>
            <parameter mode="IN" name="staging_id" type="uuid"/>
            <parameter mode="IN" name="action_taken_type" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="soundex(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[soundex]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="spheroid_in(cstring)" returnType="spheroid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ellipsoid_in]]></definition>
         <parameters>
            <parameter mode="IN" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="spheroid_out(spheroid)" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ellipsoid_out]]></definition>
         <parameters>
            <parameter mode="IN" type="spheroid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dclosestpoint(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D point on g1 that is closest to g2. This is the first point of the 3D shortest line.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_closestpoint3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dfullywithin3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddistance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D cartesian minimum distance (based on spatial ref) between two geometries in projected units.]]></comment>
         <definition language="c"><![CDATA[ST_3DDistance]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3ddwithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dwithin3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dextent(geometry)" returnType="box3d" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - Aggregate function that returns the 3D bounding box of geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dintersects(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_3DIntersects]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlength(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_3dlinestring - Returns the 3D length of a linear geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_length_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlineinterpolatepoint(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction - Returns a point interpolated along a 3D line at a fractional location.]]></comment>
         <definition language="c"><![CDATA[ST_3DLineInterpolatePoint]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dlongestline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D longest line between two geometries]]></comment>
         <definition language="c"><![CDATA[LWGEOM_longestline3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dmakebox(geom1 geometry, geom2 geometry)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: point3DLowLeftBottom, point3DUpRightTop - Creates a BOX3D defined by two 3D point geometries.]]></comment>
         <definition language="c"><![CDATA[BOX3D_construct]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dmaxdistance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D cartesian maximum distance (based on spatial ref) between two geometries in projected units.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_maxdistance3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dperimeter(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the 3D perimeter of a polygonal geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_perimeter_poly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_3dshortestline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 3D shortest line between two geometries]]></comment>
         <definition language="c"><![CDATA[LWGEOM_shortestline3d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_addmeasure(geometry, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom_mline, measure_start, measure_end - Interpolates measures along a linear geometry.]]></comment>
         <definition language="c"><![CDATA[ST_AddMeasure]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_addpoint(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, point - Add a point to a LineString.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_addpoint]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_addpoint(geom1 geometry, geom2 geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, point, position = -1 - Add a point to a LineString.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_addpoint]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, a, b, d, e, xoff, yoff - Apply a 3D affine transformation to a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  $2, $3, 0,  $4, $5, 0,  0, 0, 1,  $6, $7, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_affine(geometry, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, a, b, c, d, e, f, g, h, i, xoff, yoff, zoff - Apply a 3D affine transformation to a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_affine]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_angle(line1 geometry, line2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line1, line2 - Returns the angle between two vectors defined by 3 or 4 points, or 2 lines.]]></comment>
         <definition language="sql"><![CDATA[SELECT ST_Angle(St_StartPoint($1), ST_EndPoint($1), St_StartPoint($2), ST_EndPoint($2))]]></definition>
         <parameters>
            <parameter mode="IN" name="line1" type="geometry"/>
            <parameter mode="IN" name="line2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_angle(pt1 geometry, pt2 geometry, pt3 geometry, pt4 geometry DEFAULT '0101000000000000000000F87F000000000000F87F'::geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: point1, point2, point3, point4 - Returns the angle between two vectors defined by 3 or 4 points, or 2 lines.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_angle]]></definition>
         <parameters>
            <parameter mode="IN" name="pt1" type="geometry"/>
            <parameter mode="IN" name="pt2" type="geometry"/>
            <parameter mode="IN" name="pt3" type="geometry"/>
            <parameter mode="IN" name="pt4" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area(geog geography, use_spheroid boolean DEFAULT true)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, use_spheroid = true - Returns the area of a polygonal geometry.]]></comment>
         <definition language="c"><![CDATA[geography_area]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the area of a polygonal geometry.]]></comment>
         <definition language="c"><![CDATA[ST_Area]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area(text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Area($1::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_area2d(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Area]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asbinary(geography)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asBinary]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asbinary(geography, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asBinary]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asbinary(geometry)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asBinary]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asbinary(geometry, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asBinary]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asencodedpolyline(geom geometry, nprecision integer DEFAULT 5)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asEncodedPolyline]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="nprecision" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkb(geometry)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[WKBFromLWGEOM]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkb(geometry, text)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[WKBFromLWGEOM]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt(geography)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asEWKT]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt(geography, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asEWKT]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asEWKT]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt(geometry, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asEWKT]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asewkt(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_AsEWKT($1::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asflatgeobuf(anyelement)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asflatgeobuf(anyelement, boolean)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asflatgeobuf(anyelement, boolean, text)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="boolean"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeobuf(anyelement)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeobuf(anyelement, text)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeojson(geog geography, maxdecimaldigits integer DEFAULT 9, options integer DEFAULT 0)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_as_geojson]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeojson(geom geometry, maxdecimaldigits integer DEFAULT 9, options integer DEFAULT 8)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asGeoJson]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_asgeojson(r record, geom_column text DEFAULT ''::text, maxdecimaldigits integer DEFAULT 9, pretty_bool boolean DEFAULT false)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_AsGeoJsonRow]]></definition>
         <parameters>
            <parameter mode="IN" name="r" type="record"/>
            <parameter mode="IN" name="geom_column" type="text"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="pretty_bool" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgeojson(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_AsGeoJson($1::public.geometry, 9, 0);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml(geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT 'gml'::text, id text DEFAULT ''::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_as_gml]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
            <parameter mode="IN" name="nprefix" type="text"/>
            <parameter mode="IN" name="id" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asGML]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_AsGML(2,$1::public.geometry,15,0, NULL, NULL);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml(version integer, geog geography, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT 'gml'::text, id text DEFAULT ''::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_as_gml]]></definition>
         <parameters>
            <parameter mode="IN" name="version" type="integer"/>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
            <parameter mode="IN" name="nprefix" type="text"/>
            <parameter mode="IN" name="id" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asgml(version integer, geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0, nprefix text DEFAULT NULL::text, id text DEFAULT NULL::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asGML]]></definition>
         <parameters>
            <parameter mode="IN" name="version" type="integer"/>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
            <parameter mode="IN" name="nprefix" type="text"/>
            <parameter mode="IN" name="id" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ashexewkb(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asHEXEWKB]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ashexewkb(geometry, text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asHEXEWKB]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_askml(geog geography, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT ''::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_as_kml]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="nprefix" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_askml(geom geometry, maxdecimaldigits integer DEFAULT 15, nprefix text DEFAULT ''::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asKML]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="nprefix" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_askml(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_AsKML($1::public.geometry, 15);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_aslatlontext(geom geometry, tmpl text DEFAULT ''::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_latlon]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tmpl" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmarc21(geom geometry, format text DEFAULT 'hdddmmss'::text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_AsMARC21]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="format" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt(anyelement)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt(anyelement, text)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt(anyelement, text, integer)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt(anyelement, text, integer, text)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvt(anyelement, text, integer, text, text)" returnType="bytea" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asmvtgeom(geom geometry, bounds box2d, extent integer DEFAULT 4096, buffer integer DEFAULT 256, clip_geom boolean DEFAULT true)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_AsMVTGeom]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="bounds" type="box2d"/>
            <parameter mode="IN" name="extent" type="integer"/>
            <parameter mode="IN" name="buffer" type="integer"/>
            <parameter mode="IN" name="clip_geom" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_assvg(geog geography, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_as_svg]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="rel" type="integer"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_assvg(geom geometry, rel integer DEFAULT 0, maxdecimaldigits integer DEFAULT 15)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asSVG]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="rel" type="integer"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_assvg(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_AsSVG($1::public.geometry,0,15);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext(geography)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asText]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext(geography, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asText]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asText]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext(geometry, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_asText]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astext(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_AsText($1::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astwkb(geom geometry, prec integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer, with_sizes boolean DEFAULT NULL::boolean, with_boxes boolean DEFAULT NULL::boolean)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[TWKBFromLWGEOM]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="prec" type="integer"/>
            <parameter mode="IN" name="prec_z" type="integer"/>
            <parameter mode="IN" name="prec_m" type="integer"/>
            <parameter mode="IN" name="with_sizes" type="boolean"/>
            <parameter mode="IN" name="with_boxes" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_astwkb(geom geometry[], ids bigint[], prec integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer, with_sizes boolean DEFAULT NULL::boolean, with_boxes boolean DEFAULT NULL::boolean)" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[TWKBFromLWGEOMArray]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry[]"/>
            <parameter mode="IN" name="ids" type="bigint[]"/>
            <parameter mode="IN" name="prec" type="integer"/>
            <parameter mode="IN" name="prec_z" type="integer"/>
            <parameter mode="IN" name="prec_m" type="integer"/>
            <parameter mode="IN" name="with_sizes" type="boolean"/>
            <parameter mode="IN" name="with_boxes" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_asx3d(geom geometry, maxdecimaldigits integer DEFAULT 15, options integer DEFAULT 0)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_AsX3D(3,$1,$2,$3,'');]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxdecimaldigits" type="integer"/>
            <parameter mode="IN" name="options" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_azimuth(geog1 geography, geog2 geography)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: origin, target - Returns the north-based azimuth of a line between two points.]]></comment>
         <definition language="c"><![CDATA[geography_azimuth]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_azimuth(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: origin, target - Returns the north-based azimuth of a line between two points.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_azimuth]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_bdmpolyfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := public.ST_Multi(public.ST_BuildArea(mline));

	RETURN geom;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_bdpolyfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline public.geometry;
	geom public.geometry;
BEGIN
	mline := public.ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := public.ST_BuildArea(mline);

	IF public.GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_boundary(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the boundary of a geometry.]]></comment>
         <definition language="c"><![CDATA[boundary]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_boundingdiagonal(geom geometry, fits boolean DEFAULT false)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, fits=false - Returns the diagonal of a geometrys bounding box.]]></comment>
         <definition language="c"><![CDATA[ST_BoundingDiagonal]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="fits" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_box2dfromgeohash(text, integer DEFAULT NULL::integer)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[box2d_from_geohash]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(geography, double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2), public.ST_SRID($1)))]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(geography, double precision, integer)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, radius_of_buffer, num_seg_quarter_circle - Computes a geometry covering all points within a given distance from a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2, $3), public.ST_SRID($1)))]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(geography, double precision, text)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, radius_of_buffer, buffer_style_parameters - Computes a geometry covering all points within a given distance from a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Buffer(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1)), $2, $3), public.ST_SRID($1)))]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(geom geometry, radius double precision, options text DEFAULT ''::text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, radius_of_buffer, buffer_style_parameters = ' - Computes a geometry covering all points within a given distance from a geometry.]]></comment>
         <definition language="c"><![CDATA[buffer]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="radius" type="double precision"/>
            <parameter mode="IN" name="options" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(geom geometry, radius double precision, quadsegs integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, radius_of_buffer, num_seg_quarter_circle - Computes a geometry covering all points within a given distance from a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Buffer($1, $2, CAST('quad_segs='||CAST($3 AS text) as text))]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="radius" type="double precision"/>
            <parameter mode="IN" name="quadsegs" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(text, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Buffer($1::public.geometry, $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(text, double precision, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Buffer($1::public.geometry, $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buffer(text, double precision, text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Buffer($1::public.geometry, $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_buildarea(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Creates a polygonal geometry formed by the linework of a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_BuildArea]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_centroid(geography, use_spheroid boolean DEFAULT true)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, use_spheroid = true - Returns the geometric center of a geometry.]]></comment>
         <definition language="c"><![CDATA[geography_centroid]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_centroid(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the geometric center of a geometry.]]></comment>
         <definition language="c"><![CDATA[centroid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_centroid(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Centroid($1::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_chaikinsmoothing(geometry, integer DEFAULT 1, boolean DEFAULT false)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, nIterations = 1, preserveEndPoints = false - Returns a smoothed version of a geometry, using the Chaikin algorithm]]></comment>
         <definition language="c"><![CDATA[LWGEOM_ChaikinSmoothing]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_cleangeometry(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_CleanGeometry]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clipbybox2d(geom geometry, box box2d)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, box - Computes the portion of a geometry falling within a rectangle.]]></comment>
         <definition language="c"><![CDATA[ST_ClipByBox2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="box" type="box2d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpoint(geography, geography, use_spheroid boolean DEFAULT true)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom1, geom2, use_spheroid = true - Returns the 2D point on g1 that is closest to g2. This is the first point of the shortest line from one geometry to the other.]]></comment>
         <definition language="c"><![CDATA[geography_closestpoint]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpoint(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom1, geom2 - Returns the 2D point on g1 that is closest to g2. This is the first point of the shortest line from one geometry to the other.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_closestpoint]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpoint(text, text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_ClosestPoint($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_closestpointofapproach(geometry, geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2 - Returns a measure at the closest point of approach of two trajectories.]]></comment>
         <definition language="c"><![CDATA[ST_ClosestPointOfApproach]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterdbscan(geometry, eps double precision, minpoints integer)" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, eps, minpoints - Window function that returns a cluster id for each input geometry using the DBSCAN algorithm.]]></comment>
         <definition language="c"><![CDATA[ST_ClusterDBSCAN]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="eps" type="double precision"/>
            <parameter mode="IN" name="minpoints" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterintersecting(geometry)" returnType="geometry[]" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g - Aggregate function that clusters input geometries into connected sets.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterintersecting(geometry[])" returnType="geometry[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[clusterintersecting_garray]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterintersectingwin(geometry)" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom - Window function that returns a cluster id for each input geometry, clustering input geometries into connected sets.]]></comment>
         <definition language="c"><![CDATA[ST_ClusterIntersectingWin]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_clusterkmeans(geom geometry, k integer, max_radius double precision DEFAULT NULL::double precision)" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, number_of_clusters, max_radius - Window function that returns a cluster id for each input geometry using the K-means algorithm.]]></comment>
         <definition language="c"><![CDATA[ST_ClusterKMeans]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="k" type="integer"/>
            <parameter mode="IN" name="max_radius" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterwithin(geometry, double precision)" returnType="geometry[]" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g, distance - Aggregate function that clusters geometries by separation distance.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterwithin(geometry[], double precision)" returnType="geometry[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[cluster_within_distance_garray]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_clusterwithinwin(geometry, distance double precision)" returnType="integer" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, distance - Window function that returns a cluster id for each input geometry, clustering using separation distance.]]></comment>
         <definition language="c"><![CDATA[ST_ClusterWithinWin]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="distance" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collect(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Creates a GeometryCollection or Multi* geometry from a set of geometries.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_collect]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collect(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g1field - Creates a GeometryCollection or Multi* geometry from a set of geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collect(geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1_array - Creates a GeometryCollection or Multi* geometry from a set of geometries.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_collect_garray]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collectionextract(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: collection - Given a geometry collection, returns a multi-geometry containing only elements of a specified type.]]></comment>
         <definition language="c"><![CDATA[ST_CollectionExtract]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collectionextract(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: collection, type - Given a geometry collection, returns a multi-geometry containing only elements of a specified type.]]></comment>
         <definition language="c"><![CDATA[ST_CollectionExtract]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_collectionhomogenize(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: collection - Returns the simplest representation of a geometry collection.]]></comment>
         <definition language="c"><![CDATA[ST_CollectionHomogenize]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_combinebbox(box2d, geometry)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX2D_combine]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_combinebbox(box3d, box3d)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_combine_BOX3D]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_combinebbox(box3d, geometry)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[BOX3D_combine]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_concavehull(param_geom geometry, param_pctconvex double precision, param_allow_holes boolean DEFAULT false)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: param_geom, param_pctconvex, param_allow_holes = false - Computes a possibly concave geometry that contains all input geometry vertices]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
		var_convhull public.geometry := public.ST_ForceSFS(public.ST_ConvexHull(param_geom));
		var_param_geom public.geometry := public.ST_ForceSFS(param_geom);
		var_initarea float := public.ST_Area(var_convhull);
		var_newarea float := var_initarea;
		var_div integer := 6; 
		var_tempgeom public.geometry;
		var_tempgeom2 public.geometry;
		var_cent public.geometry;
		var_geoms public.geometry[4]; 
		var_enline public.geometry;
		var_resultgeom public.geometry;
		var_atempgeoms public.geometry[];
		var_buf float := 1; 
	BEGIN
		-- We start with convex hull as our base
		var_resultgeom := var_convhull;

		IF param_pctconvex = 1 THEN
			-- this is the same as asking for the convex hull
			return var_resultgeom;
		ELSIF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN -- it is as concave as it is going to get
			IF param_allow_holes THEN -- leave the holes
				RETURN var_param_geom;
			ELSE -- remove the holes
				var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom));
				RETURN var_resultgeom;
			END IF;
		END IF;
		IF public.ST_Dimension(var_resultgeom) > 1 AND param_pctconvex BETWEEN 0 and 0.99 THEN
		-- get linestring that forms envelope of geometry
			var_enline := public.ST_Boundary(public.ST_Envelope(var_param_geom));
			var_buf := public.ST_Length(var_enline)/1000.0;
			IF public.ST_GeometryType(var_param_geom) = 'ST_MultiPoint' AND public.ST_NumGeometries(var_param_geom) BETWEEN 4 and 200 THEN
			-- we make polygons out of points since they are easier to cave in.
			-- Note we limit to between 4 and 200 points because this process is slow and gets quadratically slow
				var_buf := sqrt(public.ST_Area(var_convhull)*0.8/(public.ST_NumGeometries(var_param_geom)*public.ST_NumGeometries(var_param_geom)));
				var_atempgeoms := ARRAY(SELECT geom FROM public.ST_DumpPoints(var_param_geom));
				-- 5 and 10 and just fudge factors
				var_tempgeom := public.ST_Union(ARRAY(SELECT geom
						FROM (
						-- fuse near neighbors together
						SELECT DISTINCT ON (i) i,  public.ST_Distance(var_atempgeoms[i],var_atempgeoms[j]), public.ST_Buffer(public.ST_MakeLine(var_atempgeoms[i], var_atempgeoms[j]) , var_buf*5, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									INNER JOIN generate_series(1,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
								UNION ALL
						-- catch the ones with no near neighbors
								SELECT i, 0, public.ST_Buffer(var_atempgeoms[i] , var_buf*10, 'quad_segs=3') As geom
								FROM generate_series(1,array_upper(var_atempgeoms, 1)) As i
									LEFT JOIN generate_series(ceiling(array_upper(var_atempgeoms,1)/2)::integer,array_upper(var_atempgeoms, 1)) As j
										ON (
								 NOT public.ST_Intersects(var_atempgeoms[i],var_atempgeoms[j])
									AND public.ST_DWithin(var_atempgeoms[i],var_atempgeoms[j], var_buf*10)
									)
									WHERE j IS NULL
								ORDER BY 1, 2
							) As foo	) );
				IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
					var_tempgeom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
					IF param_allow_holes THEN
						var_param_geom := var_tempgeom;
					ELSIF public.ST_GeometryType(var_tempgeom) = 'ST_Polygon' THEN
						var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_tempgeom)));
					ELSE
						var_param_geom := public.ST_ForceSFS(public.ST_ConvexHull(var_param_geom));
					END IF;
					-- make sure result covers original (#3638)
					var_param_geom := public.ST_Union(param_geom, var_param_geom);
					return var_param_geom;
				ELSIF public.ST_IsValid(var_tempgeom) THEN
					var_param_geom := public.ST_ForceSFS(public.ST_Intersection(var_tempgeom, var_convhull));
				END IF;
			END IF;

			IF public.ST_GeometryType(var_param_geom) = 'ST_Polygon' THEN
				IF NOT param_allow_holes THEN
					var_param_geom := public.ST_ForceSFS(public.ST_MakePolygon(public.ST_ExteriorRing(var_param_geom)));
				END IF;
				-- make sure result covers original (#3638)
				--var_param_geom := public.ST_Union(param_geom, var_param_geom);
				return var_param_geom;
			END IF;
			var_cent := public.ST_Centroid(var_param_geom);
			IF (public.ST_XMax(var_enline) - public.ST_XMin(var_enline) ) > var_buf AND (public.ST_YMax(var_enline) - public.ST_YMin(var_enline) ) > var_buf THEN
					IF public.ST_Dwithin(public.ST_Centroid(var_convhull) , public.ST_Centroid(public.ST_Envelope(var_param_geom)), var_buf/2) THEN
				-- If the geometric dimension is > 1 and the object is symettric (cutting at centroid will not work -- offset a bit)
						var_cent := public.ST_Translate(var_cent, (public.ST_XMax(var_enline) - public.ST_XMin(var_enline))/1000,  (public.ST_YMAX(var_enline) - public.ST_YMin(var_enline))/1000);
					ELSE
						-- uses closest point on geometry to centroid. I can't explain why we are doing this
						var_cent := public.ST_ClosestPoint(var_param_geom,var_cent);
					END IF;
					IF public.ST_DWithin(var_cent, var_enline,var_buf) THEN
						var_cent := public.ST_centroid(public.ST_Envelope(var_param_geom));
					END IF;
					-- break envelope into 4 triangles about the centroid of the geometry and returned the clipped geometry in each quadrant
					FOR i in 1 .. 4 LOOP
					   var_geoms[i] := public.ST_MakePolygon(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
					   var_geoms[i] := public.ST_ForceSFS(public.ST_Intersection(var_param_geom, public.ST_Buffer(var_geoms[i],var_buf)));
					   IF public.ST_IsValid(var_geoms[i]) THEN

					   ELSE
							var_geoms[i] := public.ST_BuildArea(public.ST_MakeLine(ARRAY[public.ST_PointN(var_enline,i), public.ST_PointN(var_enline,i+1), var_cent, public.ST_PointN(var_enline,i)]));
					   END IF;
					END LOOP;
					var_tempgeom := public.ST_Union(ARRAY[public.ST_ConvexHull(var_geoms[1]), public.ST_ConvexHull(var_geoms[2]) , public.ST_ConvexHull(var_geoms[3]), public.ST_ConvexHull(var_geoms[4])]);
					--RAISE NOTICE 'Curr vex % ', public.ST_AsText(var_tempgeom);
					IF public.ST_Area(var_tempgeom) <= var_newarea AND public.ST_IsValid(var_tempgeom)  THEN --AND public.ST_GeometryType(var_tempgeom) ILIKE '%Polygon'

						var_tempgeom := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[1],least(param_pctconvex + param_pctconvex/var_div),true),var_buf, 'quad_segs=2');
						FOR i IN 1 .. 4 LOOP
							var_geoms[i] := public.ST_Buffer(public.ST_ConcaveHull(var_geoms[i],least(param_pctconvex + param_pctconvex/var_div),true), var_buf, 'quad_segs=2');
							IF public.ST_IsValid(var_geoms[i]) Then
								var_tempgeom := public.ST_Union(var_tempgeom, var_geoms[i]);
							ELSE
								RAISE NOTICE 'Not valid % %', i, public.ST_AsText(var_tempgeom);
								var_tempgeom := public.ST_Union(var_tempgeom, public.ST_ConvexHull(var_geoms[i]));
							END IF;
						END LOOP;

						--RAISE NOTICE 'Curr concave % ', public.ST_AsText(var_tempgeom);
						IF public.ST_IsValid(var_tempgeom) THEN
							var_resultgeom := var_tempgeom;
						END IF;
						var_newarea := public.ST_Area(var_resultgeom);
					ELSIF public.ST_IsValid(var_tempgeom) THEN
						var_resultgeom := var_tempgeom;
					END IF;

					IF public.ST_NumGeometries(var_resultgeom) > 1  THEN
						var_tempgeom := public._ST_ConcaveHull(var_resultgeom);
						IF public.ST_IsValid(var_tempgeom) AND public.ST_GeometryType(var_tempgeom) ILIKE 'ST_Polygon' THEN
							var_resultgeom := var_tempgeom;
						ELSE
							var_resultgeom := public.ST_Buffer(var_tempgeom,var_buf, 'quad_segs=2');
						END IF;
					END IF;
					IF param_allow_holes = false THEN
					-- only keep exterior ring since we do not want holes
						var_resultgeom := public.ST_MakePolygon(public.ST_ExteriorRing(var_resultgeom));
					END IF;
				ELSE
					var_resultgeom := public.ST_Buffer(var_resultgeom,var_buf);
				END IF;
				var_resultgeom := public.ST_ForceSFS(public.ST_Intersection(var_resultgeom, public.ST_ConvexHull(var_param_geom)));
			ELSE
				-- dimensions are too small to cut
				var_resultgeom := public._ST_ConcaveHull(var_param_geom);
			END IF;

			RETURN var_resultgeom;
	END;]]></definition>
         <parameters>
            <parameter mode="IN" name="param_geom" type="geometry"/>
            <parameter mode="IN" name="param_pctconvex" type="double precision"/>
            <parameter mode="IN" name="param_allow_holes" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_contains(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[contains]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_containsproperly(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[containsproperly]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_convexhull(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Computes the convex hull of a geometry.]]></comment>
         <definition language="c"><![CDATA[convexhull]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coorddim(geometry geometry)" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Return the coordinate dimension of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_ndims]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coverageinvalidedges(geom geometry, tolerance double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, tolerance = 0 - Window function that finds locations where polygons fail to form a valid coverage.]]></comment>
         <definition language="c"><![CDATA[ST_CoverageInvalidEdges]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coveragesimplify(geom geometry, tolerance double precision, simplifyboundary boolean DEFAULT true)" returnType="geometry" securityType="INVOKER" type="WINDOW">
         <comment><![CDATA[args: geom, tolerance, simplifyBoundary = true - Window function that simplifies the edges of a polygonal coverage.]]></comment>
         <definition language="c"><![CDATA[ST_CoverageSimplify]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="simplifyboundary" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coverageunion(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geom - Computes the union of a set of polygons forming a coverage by removing shared edges.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coverageunion(geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_CoverageUnion]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coveredby(geog1 geography, geog2 geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_coveredby]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coveredby(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[coveredby]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_coveredby(text, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_CoveredBy($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_covers(geog1 geography, geog2 geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_covers]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_covers(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[covers]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_covers(text, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Covers($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_cpawithin(geometry, geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2, dist - Tests if the closest point of approach of two trajectoriesis within the specified distance.]]></comment>
         <definition language="c"><![CDATA[ST_CPAWithin]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_crosses(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[crosses]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_curvetoline(geom geometry, tol double precision DEFAULT 32, toltype integer DEFAULT 0, flags integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: curveGeom, tolerance, tolerance_type, flags - Converts a geometry containing curves to a linear geometry.]]></comment>
         <definition language="c"><![CDATA[ST_CurveToLine]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tol" type="double precision"/>
            <parameter mode="IN" name="toltype" type="integer"/>
            <parameter mode="IN" name="flags" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_delaunaytriangles(g1 geometry, tolerance double precision DEFAULT 0.0, flags integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, tolerance = 0.0, flags = 0 - Returns the Delaunay triangulation of the vertices of a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_DelaunayTriangles]]></definition>
         <parameters>
            <parameter mode="IN" name="g1" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="flags" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dfullywithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dfullywithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_difference(geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1.0'::numeric)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, geomB, gridSize = -1 - Computes a geometry representing the part of geometry A that does not intersect geometry B.]]></comment>
         <definition language="c"><![CDATA[ST_Difference]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dimension(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the topological dimension of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dimension]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_disjoint(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[disjoint]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distance(geog1 geography, geog2 geography, use_spheroid boolean DEFAULT true)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog1, geog2, use_spheroid = true - Returns the distance between two geometry or geography values.]]></comment>
         <definition language="c"><![CDATA[geography_distance]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the distance between two geometry or geography values.]]></comment>
         <definition language="c"><![CDATA[ST_Distance]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distance(text, text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Distance($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancecpa(geometry, geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: track1, track2 - Returns the distance between the closest point of approach of two trajectories.]]></comment>
         <definition language="c"><![CDATA[ST_DistanceCPA]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancesphere(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[select public.ST_distance( public.geography($1), public.geography($2),false)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancesphere(geom1 geometry, geom2 geometry, radius double precision)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomlonlatA, geomlonlatB, radius=6371008 - Returns minimum distance in meters between two lon/lat geometries using a spherical earth model.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_distance_sphere]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="radius" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancespheroid(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_distance_ellipsoid]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_distancespheroid(geom1 geometry, geom2 geometry, spheroid)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomlonlatA, geomlonlatB, measurement_spheroid=WGS84 - Returns the minimum distance between two lon/lat geometries using a spheroidal earth model.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_distance_ellipsoid]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="spheroid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dump(geometry)" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns a set of geometry_dump rows for the components of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dump]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dumppoints(geometry)" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a set of geometry_dump rows for the coordinates in a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dumppoints]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dumprings(geometry)" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns a set of geometry_dump rows for the exterior and interior rings of a Polygon.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dump_rings]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dumpsegments(geometry)" returnType="SETOF geometry_dump" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a set of geometry_dump rows for the segments in a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_dumpsegments]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dwithin(geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_dwithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dwithin(geom1 geometry, geom2 geometry, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_dwithin]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_dwithin(text, text, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_DWithin($1::public.geometry, $2::public.geometry, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_endpoint(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the last point of a LineString or CircularLineString.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_endpoint_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_envelope(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns a geometry representing the bounding box of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_envelope]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_equals(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Equals]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_estimatedextent(text, text)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: table_name, geocolumn_name - Returns the estimated extent of a spatial table.]]></comment>
         <definition language="c"><![CDATA[gserialized_estimated_extent]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_estimatedextent(text, text, text)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name, geocolumn_name - Returns the estimated extent of a spatial table.]]></comment>
         <definition language="c"><![CDATA[gserialized_estimated_extent]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_estimatedextent(text, text, text, boolean)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name, geocolumn_name, parent_only - Returns the estimated extent of a spatial table.]]></comment>
         <definition language="c"><![CDATA[gserialized_estimated_extent]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(box box2d, dx double precision, dy double precision)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: box, dx, dy - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX2D_expand]]></definition>
         <parameters>
            <parameter mode="IN" name="box" type="box2d"/>
            <parameter mode="IN" name="dx" type="double precision"/>
            <parameter mode="IN" name="dy" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(box box3d, dx double precision, dy double precision, dz double precision DEFAULT 0)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: box, dx, dy, dz=0 - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_expand]]></definition>
         <parameters>
            <parameter mode="IN" name="box" type="box3d"/>
            <parameter mode="IN" name="dx" type="double precision"/>
            <parameter mode="IN" name="dy" type="double precision"/>
            <parameter mode="IN" name="dz" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(box2d, double precision)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: box, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX2D_expand]]></definition>
         <parameters>
            <parameter mode="IN" type="box2d"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(box3d, double precision)" returnType="box3d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: box, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_expand]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(geom geometry, dx double precision, dy double precision, dz double precision DEFAULT 0, dm double precision DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, dx, dy, dz=0, dm=0 - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_expand]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="dx" type="double precision"/>
            <parameter mode="IN" name="dy" type="double precision"/>
            <parameter mode="IN" name="dz" type="double precision"/>
            <parameter mode="IN" name="dm" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_expand(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, units_to_expand - Returns a bounding box expanded from another bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_expand]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_extent(geometry)" returnType="box2d" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - Aggregate function that returns the bounding box of geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_exteriorring(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns a LineString representing the exterior ring of a Polygon.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_exteriorring_polygon]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_filterbym(geometry, double precision, double precision DEFAULT NULL::double precision, boolean DEFAULT false)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, min, max = null, returnM = false - Removes vertices based on their M value]]></comment>
         <definition language="c"><![CDATA[LWGEOM_FilterByM]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_findextent(text, text)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT public.ST_Extent("' || columnname || '") As extent FROM "' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_findextent(text, text, text)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;
BEGIN
	FOR myrec IN EXECUTE 'SELECT public.ST_Extent("' || columnname || '") As extent FROM "' || schemaname || '"."' || tablename || '"' LOOP
		return myrec.extent;
	END LOOP;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_flipcoordinates(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a version of a geometry with X and Y axis flipped.]]></comment>
         <definition language="c"><![CDATA[ST_FlipCoordinates]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force2d(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries into a "2-dimensional mode".]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_2d]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3d(geom geometry, zvalue double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, Zvalue = 0.0 - Force the geometries into XYZ mode. This is an alias for ST_Force3DZ.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Force3DZ($1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="zvalue" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3dm(geom geometry, mvalue double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, Mvalue = 0.0 - Force the geometries into XYM mode.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_3dm]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="mvalue" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force3dz(geom geometry, zvalue double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, Zvalue = 0.0 - Force the geometries into XYZ mode.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_3dz]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="zvalue" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_force4d(geom geometry, zvalue double precision DEFAULT 0.0, mvalue double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, Zvalue = 0.0, Mvalue = 0.0 - Force the geometries into XYZM mode.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_4d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="zvalue" type="double precision"/>
            <parameter mode="IN" name="mvalue" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcecollection(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Convert the geometry into a GEOMETRYCOLLECTION.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_collection]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcecurve(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Upcast a geometry into its curved type, if applicable.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_curve]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcepolygonccw(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Orients all exterior rings counter-clockwise and all interior rings clockwise.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Reverse(public.ST_ForcePolygonCW($1))]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcepolygoncw(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Orients all exterior rings clockwise and all interior rings counter-clockwise.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_clockwise_poly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcerhr(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Force the orientation of the vertices in a polygon to follow the Right-Hand-Rule.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_clockwise_poly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcesfs(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Force the geometries to use SFS 1.1 geometry types only.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_sfs]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_forcesfs(geometry, version text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, version - Force the geometries to use SFS 1.1 geometry types only.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_sfs]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="version" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_frechetdistance(geom1 geometry, geom2 geometry, double precision DEFAULT '-1'::integer)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, densifyFrac = -1 - Returns the Frchet distance between two geometries.]]></comment>
         <definition language="c"><![CDATA[ST_FrechetDistance]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_fromflatgeobuf(anyelement, bytea)" returnType="SETOF anyelement" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_fromflatgeobuf]]></definition>
         <parameters>
            <parameter mode="IN" type="anyelement"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_fromflatgeobuftotable(text, text, bytea)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[pgis_tablefromflatgeobuf]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_generatepoints(area geometry, npoints integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, npoints - Generates random points contained in a Polygon or MultiPolygon.]]></comment>
         <definition language="c"><![CDATA[ST_GeneratePoints]]></definition>
         <parameters>
            <parameter mode="IN" name="area" type="geometry"/>
            <parameter mode="IN" name="npoints" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_generatepoints(area geometry, npoints integer, seed integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, npoints, seed = 0 - Generates random points contained in a Polygon or MultiPolygon.]]></comment>
         <definition language="c"><![CDATA[ST_GeneratePoints]]></definition>
         <parameters>
            <parameter mode="IN" name="area" type="geometry"/>
            <parameter mode="IN" name="npoints" type="integer"/>
            <parameter mode="IN" name="seed" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geogfromtext(text)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geogfromwkb(bytea)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_from_binary]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geographyfromtext(text)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geohash(geog geography, maxchars integer DEFAULT 0)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_GeoHash]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="maxchars" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geohash(geom geometry, maxchars integer DEFAULT 0)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_GeoHash]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxchars" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomcollfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'GEOMETRYCOLLECTION'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometricmedian(g geometry, tolerance double precision DEFAULT NULL::double precision, max_iter integer DEFAULT 10000, fail_if_not_converged boolean DEFAULT false)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance = NULL, max_iter = 10000, fail_if_not_converged = false - Returns the geometric median of a MultiPoint.]]></comment>
         <definition language="c"><![CDATA[ST_GeometricMedian]]></definition>
         <parameters>
            <parameter mode="IN" name="g" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="max_iter" type="integer"/>
            <parameter mode="IN" name="fail_if_not_converged" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometryfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometryfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometryn(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, n - Return an element of a geometry collection.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_geometryn_collection]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geometrytype(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the SQL-MM type of a geometry as text.]]></comment>
         <definition language="c"><![CDATA[geometry_geometrytype]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromewkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOMFromEWKB]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromewkt(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[parse_WKT_lwgeom]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeohash(text, integer DEFAULT NULL::integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CAST(public.ST_Box2dFromGeoHash($1, $2) AS geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeojson(json)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_GeomFromGeoJson($1::text)]]></definition>
         <parameters>
            <parameter mode="IN" type="json"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeojson(jsonb)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_GeomFromGeoJson($1::text)]]></definition>
         <parameters>
            <parameter mode="IN" type="jsonb"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgeojson(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom_from_geojson]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgml(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_GeomFromGML($1, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromgml(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom_from_gml]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromkml(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom_from_kml]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfrommarc21(marc21xml text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_GeomFromMARC21]]></definition>
         <parameters>
            <parameter mode="IN" name="marc21xml" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromtwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOMFromTWKB]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_WKB]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_geomfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_SetSRID(public.ST_GeomFromWKB($1), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_gmltosql(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public._ST_GeomFromGML($1, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_gmltosql(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geom_from_gml]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hasarc(geometry geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry contains a circular arc]]></comment>
         <definition language="c"><![CDATA[LWGEOM_has_arc]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hausdorffdistance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the Hausdorff distance between two geometries.]]></comment>
         <definition language="c"><![CDATA[hausdorffdistance]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hausdorffdistance(geom1 geometry, geom2 geometry, double precision)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, densifyFrac - Returns the Hausdorff distance between two geometries.]]></comment>
         <definition language="c"><![CDATA[hausdorffdistancedensify]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hexagon(size double precision, cell_i integer, cell_j integer, origin geometry DEFAULT '010100000000000000000000000000000000000000'::geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: size, cell_i, cell_j, origin - Returns a single hexagon, using the provided edge size and cell coordinate within the hexagon grid space.]]></comment>
         <definition language="c"><![CDATA[ST_Hexagon]]></definition>
         <parameters>
            <parameter mode="IN" name="size" type="double precision"/>
            <parameter mode="IN" name="cell_i" type="integer"/>
            <parameter mode="IN" name="cell_j" type="integer"/>
            <parameter mode="IN" name="origin" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_hexagongrid(size double precision, bounds geometry, OUT geom geometry, OUT i integer, OUT j integer)" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: size, bounds - Returns a set of hexagons and cell indices that completely cover the bounds of the geometry argument.]]></comment>
         <definition language="c"><![CDATA[ST_ShapeGrid]]></definition>
         <parameters>
            <parameter mode="IN" name="size" type="double precision"/>
            <parameter mode="IN" name="bounds" type="geometry"/>
            <parameter mode="OUT" name="geom" type="geometry"/>
            <parameter mode="OUT" name="i" type="integer"/>
            <parameter mode="OUT" name="j" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_interiorringn(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon, n - Returns the Nth interior ring (hole) of a Polygon.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_interiorringn_polygon]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_interpolatepoint(line geometry, point geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linear_geom_with_measure, point - Returns the interpolated measure of a geometry closest to a point.]]></comment>
         <definition language="c"><![CDATA[ST_InterpolatePoint]]></definition>
         <parameters>
            <parameter mode="IN" name="line" type="geometry"/>
            <parameter mode="IN" name="point" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersection(geography, geography)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geogA, geogB - Computes a geometry representing the shared portion of geometries A and B.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.geography(public.ST_Transform(public.ST_Intersection(public.ST_Transform(public.geometry($1), public._ST_BestSRID($1, $2)), public.ST_Transform(public.geometry($2), public._ST_BestSRID($1, $2))), public.ST_SRID($1)))]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersection(geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1'::integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, geomB, gridSize = -1 - Computes a geometry representing the shared portion of geometries A and B.]]></comment>
         <definition language="c"><![CDATA[ST_Intersection]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersection(text, text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Intersection($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersects(geog1 geography, geog2 geography)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[geography_intersects]]></definition>
         <parameters>
            <parameter mode="IN" name="geog1" type="geography"/>
            <parameter mode="IN" name="geog2" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersects(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_Intersects]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_intersects(text, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Intersects($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_inversetransformpipeline(geom geometry, pipeline text, to_srid integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, pipeline, to_srid - Return a new geometry with coordinates transformed to a different spatial reference system using the inverse of a defined coordinate transformation pipeline.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.postgis_transform_pipeline_geometry($1, $2, FALSE, $3)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="pipeline" type="text"/>
            <parameter mode="IN" name="to_srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isclosed(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a LineStringss start and end points are coincident. For a PolyhedralSurface tests if it is closed (volumetric).]]></comment>
         <definition language="c"><![CDATA[LWGEOM_isclosed]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_iscollection(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a geometry is a geometry collection type.]]></comment>
         <definition language="c"><![CDATA[ST_IsCollection]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isempty(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry is empty.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_isempty]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ispolygonccw(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Tests if Polygons have exterior rings oriented counter-clockwise and interior rings oriented clockwise.]]></comment>
         <definition language="c"><![CDATA[ST_IsPolygonCCW]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ispolygoncw(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Tests if Polygons have exterior rings oriented clockwise and interior rings oriented counter-clockwise.]]></comment>
         <definition language="c"><![CDATA[ST_IsPolygonCW]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isring(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a LineString is closed and simple.]]></comment>
         <definition language="c"><![CDATA[isring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_issimple(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Tests if a geometry has no points of self-intersection or self-tangency.]]></comment>
         <definition language="c"><![CDATA[issimple]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalid(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Tests if a geometry is well-formed in 2D.]]></comment>
         <definition language="c"><![CDATA[isvalid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalid(geometry, integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, flags - Tests if a geometry is well-formed in 2D.]]></comment>
         <definition language="sql"><![CDATA[SELECT (public.ST_isValidDetail($1, $2)).valid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvaliddetail(geom geometry, flags integer DEFAULT 0)" returnType="valid_detail" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, flags - Returns a valid_detail row stating if a geometry is valid or if not a reason and a location.]]></comment>
         <definition language="c"><![CDATA[isvaliddetail]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="flags" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalidreason(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns text stating if a geometry is valid, or a reason for invalidity.]]></comment>
         <definition language="c"><![CDATA[isvalidreason]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalidreason(geometry, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, flags - Returns text stating if a geometry is valid, or a reason for invalidity.]]></comment>
         <definition language="sql"><![CDATA[SELECT CASE WHEN valid THEN 'Valid Geometry' ELSE reason END FROM (
		SELECT (public.ST_isValidDetail($1, $2)).*
	) foo]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_isvalidtrajectory(geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line - Tests if the geometry is a valid trajectory.]]></comment>
         <definition language="c"><![CDATA[ST_IsValidTrajectory]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_largestemptycircle(geom geometry, tolerance double precision DEFAULT 0.0, boundary geometry DEFAULT '0101000000000000000000F87F000000000000F87F'::geometry, OUT center geometry, OUT nearest geometry, OUT radius double precision)" returnType="record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance=0.0, boundary=POINT EMPTY - Computes the largest circle not overlapping a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_LargestEmptyCircle]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="boundary" type="geometry"/>
            <parameter mode="OUT" name="center" type="geometry"/>
            <parameter mode="OUT" name="nearest" type="geometry"/>
            <parameter mode="OUT" name="radius" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length(geog geography, use_spheroid boolean DEFAULT true)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, use_spheroid = true - Returns the 2D length of a linear geometry.]]></comment>
         <definition language="c"><![CDATA[geography_length]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_2dlinestring - Returns the 2D length of a linear geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_length2d_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length(text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_Length($1::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length2d(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_2dlinestring - Returns the 2D length of a linear geometry. Alias for ST_Length]]></comment>
         <definition language="c"><![CDATA[LWGEOM_length2d_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_length2dspheroid(geometry, spheroid)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_length2d_ellipsoid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="spheroid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lengthspheroid(geometry, spheroid)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_geometry, a_spheroid - Returns the 2D or 3D length/perimeter of a lon/lat geometry on a spheroid.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_length_ellipsoid_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="spheroid"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_letters(letters text, font json DEFAULT NULL::json)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args:  letters,  font - Returns the input letters rendered as geometry with a default start position at the origin and default text height of 100.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
  letterarray text[];
  letter text;
  geom geometry;
  prevgeom geometry = NULL;
  adjustment float8 = 0.0;
  position float8 = 0.0;
  text_height float8 = 100.0;
  width float8;
  m_width float8;
  spacing float8;
  dist float8;
  wordarr geometry[];
  wordgeom geometry;
  -- geometry has been run through replace(encode(st_astwkb(geom),'base64'), E'\n', '')
  font_default_height float8 = 1000.0;
  font_default json = '{
  "!":"BgACAQhUrgsTFOQCABQAExELiwi5AgAJiggBYQmJCgAOAg4CDAIOBAoEDAYKBgoGCggICAgICAgGCgYKBgoGCgQMBAoECgQMAgoADAIKAAoADAEKAAwBCgMKAQwDCgMKAwoFCAUKBwgHBgcIBwYJBgkECwYJBAsCDQILAg0CDQANAQ0BCwELAwsDCwUJBQkFCQcHBwcHBwcFCQUJBQkFCQMLAwkDCQMLAQkACwEJAAkACwIJAAsCCQQJAgsECQQJBAkGBwYJCAcIBQgHCAUKBQoDDAUKAQwDDgEMAQ4BDg==",
  "&":"BgABAskBygP+BowEAACZAmcAANsCAw0FDwUNBQ0FDQcLBw0HCwcLCQsJCwkLCQkJCwsJCwkLCQ0HCwcNBw8HDQUPBQ8DDwMRAw8DEQERAREBEQERABcAFQIXAhUCEwQVBBMGEwYTBhEIEQgPChEKDwoPDA0MDQwNDgsOCRAJEAkQBxAHEgUSBRQFFAMUAxQBFgEWARgAigEAFAISABICEgQQAhAEEAQQBg4GEAoOCg4MDg4ODgwSDgsMCwoJDAcMBwwFDgUMAw4DDgEOARABDgEQARIBEAASAHgAIAQeBB4GHAgaChoMGA4WDhYQFBISEhISDhQQFAwWDBYKFgoYBhgIGAQYBBgCGgAaABgBGAMYAxYHFgUWCRYJFAsUCxIPEg0SERARDhMOFQwVDBcIGQYbBhsCHQIfAR+dAgAADAAKAQoBCgEIAwgFBgUGBQYHBAUEBwQHAgcCBwIHAAcABwAHAQcBBwMHAwUDBwUFBQUHBQUBBwMJAQkBCQAJAJcBAAUCBQAFAgUEBQIDBAUEAwQDBgMEAQYDBgEGAAgBBgAKSeECAJ8BFi84HUQDQCAAmAKNAQAvExMx",
  "\"":"BgACAQUmwguEAgAAkwSDAgAAlAQBBfACAIACAACTBP8BAACUBA==",
  "''":"BgABAQUmwguEAgAAkwSDAgAAlAQ=",
  "(":"BgABAUOQBNwLDScNKw0rCysLLwsxCTEJMwc1BzcHNwM7AzsDPwE/AEEANwI1AjMEMwIzBjEGLwYvCC0ILQgrCCkKKQonCicMJbkCAAkqCSoHLAksBywFLgcuBS4FMAMwAzADMgEwATQBMgA0ADwCOgI6BDoEOAY4BjYINgg2CjQKMgoyCjIMMAwwDi7AAgA=",
  ")":"BgABAUMQ3Au6AgAOLQwvDC8KMQoxCjEKMwg1CDUGNQY3BDcEOQI5AjkAOwAzATEBMQExAy8DLwMvBS8FLQctBS0HKwktBykJKwkpswIADCYKKAooCioIKggsCC4ILgYwBjAGMgQ0AjQCNAI2ADgAQgFAAz4DPAM8BzgHOAc2CTQJMgsyCzALLg0sDSoNKg==",
  "+":"BgABAQ3IBOwGALcBuAEAANUBtwEAALcB0wEAALgBtwEAANYBuAEAALgB1AEA",
  "/":"BgABAQVCAoIDwAuyAgCFA78LrQIA",
  "4":"BgABAhDkBr4EkgEAEREApwJ/AADxARIR5QIAEhIA9AHdAwAA7ALIA9AG6gIAEREA8QYFqwIAAIIDwwH/AgABxAEA",
  "v":"BgABASDmA5AEPu4CROwBExb6AgAZFdMC0wgUFaECABIU0wLWCBcW+AIAExVE6wEEFQQXBBUEFwQVBBUEFwQVBBUEFwQVBBUEFwQXBBUEFwYA",
  ",":"BgABAWMYpAEADgIOAgwCDgQMBAoGDAYKBgoICAgICAgICAoGCgYKBAoEDAQKBAoCDAIKAgwCCgAKAAwACgEMAQoBCgMMAwoDCgUKBQgFCgUIBwYJCAcGCQYJBAsGCQQLAg0CCwINAg0AAwABAAMAAwADAQMAAwADAAMBBQAFAQcBBwEHAwcBCQMJAQsDCwMLAw0FDQMNBQ8FDwURBxMFEwkTBxcJFwkXswEAIMgBCQYJBgkGBwYJCAcIBQgHCgUKBQoFDAEMAwwBDgEOABA=",
  "-":"BgABAQUq0AMArALEBAAAqwLDBAA=",
  ".":"BgABAWFOrAEADgIOAg4CDgQMBAoGDAYKBgoICAgKCAgIBgoGCgYKBgoEDAQKBAwECgIMAAwCDAAMAAwBCgAMAQoDDAMKAwoDCgUKBQgFCgUIBwgJBgcICQYJBgsGCQQLAg0CDQINAA0ADQENAQ0BCwMNAwkFCwUJBQkHBwcJBwUHBwkFCQUJBQkDCwMJAwsDCQELAAsBCwALAAsCCQALAgkECwQJBAkECQYJBgcGBwgJBgcKBQgHCgUKBQwFCgEOAwwBDgEOAA4=",
  "0":"BgABAoMB+APaCxwAHAEaARoDFgMYBRYFFAcUBxIJEgkQCRALEAsOCwwNDA0MDQoPCg0IDwgPBhEGDwYRBA8EEQIRAhMCEQITABMA4QUAEQETAREBEQMRAxEFEQURBREHDwkPBw8JDwsNCw0LDQ0NDQsNCw8JEQkRCREJEwcTBxUFFQUVAxUDFwEXARkAGQAZAhcCFwQXBBUGEwYTCBMIEQoRCg8KDwoPDA0MDQ4NDgsOCQ4JEAkQBxAHEAUSBRIDEgMSAxIDEgESARQAEgDiBQASAhQCEgISBBIEEgYSBhIGEggQChAIEAoQDBAMDgwODg4ODA4MEgwQChIKEggUCBQIFgYWBBYGGAQYAhgCGgILZIcDHTZBEkMRHTUA4QUeOUITRBIePADiBQ==",
  "2":"BgABAWpUwALUA44GAAoBCAEKAQgDBgMGBQYFBgUEBwQFBAUCBwIHAgUABwAHAAUBBwMFAQcFBQMHBQUHBQcFBwMJAwkBCQELAQsAC68CAAAUAhIAFAISBBQCEgQUBBIEEgYUCBIGEAgSChAKEAoQDBAMDg4ODgwQDBIMEgoSChQIFggWCBgGGAQaAhwCHAIWABQBFgEUARQDFAMSAxQFEgUSBxIHEAkQCRALDgsODQ4NDA8KDwwRCBMKEwgTBhUGFwQXBBcEGwAbABsAHQEftwPJBdIDAACpAhIPzwYAFBIArgI=",
  "1":"BgABARCsBLALAJ0LEhERADcA2QEANwATABQSAOYIpwEAALgCERKEBAASABER",
  "3":"BgABAZ0B/gbEC/sB0QQOAwwBDAMMAwwFCgMKBQoFCgUIBwoFCAcICQgJBgkICQYLCAsECwYLBA0GDwINBA8CDwQRAhECEQITABUCFQAVAH0AEQETAREBEQETAxEDEQURBREFDwcRBw8JDwkNCQ8LDQsNDQsNCw0LDwsPCREJEQcRBxMFFQUVBRUDFwEXARkAGQAZAhkCFwQVBBUEEwYTCBEIEQgRCg0MDwoNDA0OCw4LDgkQCRAHEAkQBRAFEgUSAxIDFAMSAxYBFAEWARYAFqQCAAALAgkCCQQHAgcGBwYHBgUIBQYDCAMIAwYDCAEIAQgACAAIAAgCCAIIAgYCCAQIBAgGBgYEBgQIBAoCCgAKAAwAvAEABgEIAAYBBgMGAwQDBgMEBQQDBAUCBQQFAgUABwIFAJkBAACmAaIB3ALbAgAREQDmAhIRggYA",
  "5":"BgABAaAB0APgBxIAFAESABIBEgMSARADEgMQAxIFEAcOBRAHDgkOCQ4JDgsMCwwLCgsKDQoPCA0IDwgPBhEEEwYTAhMEFwIXABcAiQIAEwETABEBEQMTAxEDDwMRBQ8FDwUPBw8JDQcNCQ0LDQsLCwsNCw0JDwkPCREHEQcTBxMFEwMVAxcDGQEZARkAFwAVAhUCFQQTBBMGEwYRCBEIDwoPCg8KDQwNDA0MCw4LDgkOCRAJEAcOBxAHEgUQBRIDEAMSAxIBEgEUARIAFLgCAAAFAgUABQIFBAUCBQQDBAUEAwYDBgMIAwgBCAEIAQoACAAIAgYACAQGAgQEBgQEBAQGBAQCBgIGAgYCBgIIAAYA4AEABgEIAAYBBgMGAQQDBgMEAwQFBAMCBQQFAgUABwIFAPkBAG+OAQCCBRESAgAAAuYFABMRAK8CjQMAAJ8BNgA=",
  "7":"BgABAQrQBsILhQOvCxQR7wIAEhK+AvYIiwMAAKgCERKwBgA=",
  "6":"BgABAsYBnAOqBxgGFgYYBBYEFgIWABQBFgEUAxQDFAUUBRIFEAcSCRAJEAkOCw4NDgsMDQoPCg8KDwgRCBEGEQYRBBMCEwITAhUAkwIBAAERAREBEQEPAxEFEQMPBREFDwcPBw8HDwkNCQ0LDQsNCwsNCw0LDQkPCQ8JDwcRBxEHEwUTAxMFFQEXAxcBGQAVABUCEwIVBBMEEQYTBhEIEQgPChEKDQoPDA0MDQwNDgsOCxALDgkQCRAHEgcQBxIFEgUSBRIBFAMSARIBFAASAOIFABACEgIQAhIEEAQQBhIGEAYQCBAKEAgOChAMDgwMDA4ODA4MDgwODBAKEAoQChIIEggSBhQGFgYUAhYCGAIYABoAGAEYARYBFgMUBRQFEgUSBxAHEAcQCQ4LDgkMCwwNDA0KDQgPCg0GEQgPBhEEEQQRBBMEEwITAhMCFQIVABWrAgAACgEIAQoBCAEGAwYDBgUGBQQFBAUEBQQFAgUABwIFAAUABwEFAAUBBQMFAwUDBQMFBQMFAwUBBQEHAQkBBwAJAJcBDUbpBDASFi4A4AETLC8SBQAvERUrAN8BFC0yEQQA",
  "8":"BgABA9gB6gPYCxYAFAEUARYBEgMUBRQFEgUSBxIHEAcSCQ4JEAkOCw4LDgsMDQwNCg0KDQoPCg8IDwgPBhEGEQQPBBMCEQIRABMAQwAxAA8BEQEPAREDDwMRAw8FEQUPBxEJDwkPCQ8NDw0PDQ8IBwYHCAcGBwgHBgkGBwYJBgcECQYJBAkGCQQJBAsECwQLBA0CCwINAg8CDwIPAA8AaQATAREBEwERAxEFEQURBREHEQcPBw8JDwkPCw8LDQsNDQ0LCw0LDwsNCQ8JDwcPBw8HEQURAxEFEQMRARMBEwFDABEAEwIRAhEEEQQRBg8GEQgPCA8KDwoPCg0MDQwNDAsOCw4LDgkQCRAJDgkQBxIHEAcSBRADEgMUAxIBFAEUABQAagAOAhAADgIOAg4EDAIOBAwEDAQMBgwECgYMBAoGCAYKBgoGCggKBgoICgYICAoICA0MCwwLDgsOCRAHEAcQBxIFEgUSAxIDEgMSARABEgASADIARAASAhICEgQSAhIGEAYSBhAIEAgQCBAKDgoODA4MDgwMDgwODA4KEAwQCBIKEggSCBQIFAYUBBQEFgQWAhYCGAANT78EFis0EwYANBIYLgC0ARcsMRQFADERGS0AswELogHtAhcuNxA3DRkvALMBGjE6ETYSGDIAtAE=",
  "9":"BgABAsYBpASeBBcFFQUXAxUDFQEVABMCFQITBBMEEwYRBhMGDwgRCg8KDwoNDA0OCwwNDgkQCRAJEAcSBxIFEgUSAxQBFAEUARYAlAICAAISAhICEgQSAhAGEgQQBhIGEAgSCA4IEAoOChAMDAwODAwODA4MEAoOChAKEAgSCBIIFAYUBBQGFgIYBBgCGgAWABYBFAEWAxQDEgUUBRIHEgcQCRIJEAkOCw4LDgsODQwNDA0MDwoPCg8IDwgRCBEGEQYRBhEEEQITAhECEwARAOEFAA8BEQEPAREDDwMPBREFDwUPBw8JDwcNCQ8LDQsLCw0NCw0LDQsNCw8JEQkPCREHEQcTBRMFEwUTARUBFQEXABkAFwIXAhcCFQQTBhMGEQYRCA8IDwgNCg8MCwoLDAsOCQ4JDgkQBxAHEAUQBRIFEgMSAxQDFAEUAxQAFgEWABamAgAACwIJAgkCCQIHBAcEBwYFBgUGAwYDBgMGAQgBBgEIAAgABgIIAgYCBgQGBAYEBgYGBgQIBAgECAIKAgoCCgAMAJgBDUXqBC8RFS0A3wEUKzARBgAwEhYsAOABEy4xEgMA",
  ":":"BgACAWE0rAEADgIOAg4CDgQMBAoGDAYKBgoICAgKCAgIBgoGCgYKBgoEDAQKBAwECgIMAAwCDAAMAAwBCgAMAQoDDAMKAwoDCgUKBQgFCgUIBwgJBgcICQYJBgsGCQQLAg0CDQINAA0ADQENAQ0BCwMNAwkFCwUJBQkHBwcJBwUHBwkFCQUJBQkDCwMJAwsDCQELAAsBCwALAAsCCQALAgkECwQJBAkECQYJBgcGBwgJBgcKBQgHCgUKBQwFCgEOAwwBDgEOAA4BYQDqBAAOAg4CDgIOBAwECgYMBgoGCggICAoICAgGCgYKBgoGCgQMBAoEDAQKAgwADAIMAAwADAEKAAwBCgMMAwoDCgMKBQoFCAUKBQgHCAkGBwgJBgkGCwYJBAsCDQINAg0ADQANAQ0BDQELAw0DCQULBQkFCQcHBwkHBQcHCQUJBQkFCQMLAwkDCwEJAwsACwELAAsACwIJAAsECQILBAkECQQJBgkGBwYHCAkGBwoFCAcKBQoFDAUKAQ4DDAEOAQ4ADg==",
  "x":"BgABARHmAoAJMIMBNLUBNrYBMIQB1AIA9QG/BI4CvwTVAgA5hgFBwAFFxwE1fdUCAI4CwATzAcAE1AIA",
  ";":"BgACAWEslgYADgIOAg4CDgQMBAoGDAYKBgoICAgKCAgIBgoGCgYKBgoEDAQKBAwECgIMAAwCDAAMAAwBCgAMAQoDDAMKAwoDCgUKBQgFCgUIBwgJBgcICQYJBgsGCQQLAg0CDQINAA0ADQENAQ0BCwMNAwkFCwUJBQkHBwcJBwUHBwkFCQUJBQkDCwMJAwsBCQMLAAsBCwALAAsCCQALBAkCCwQJBAkECQYJBgcGBwgJBgcKBQgHCgUKBQwFCgEOAwwBDgEOAA4BYwjxBAAOAg4CDAIOBAwECgYMBgoGCggICAgICAgICgYKBgoECgQMBAoECgIMAgoCDAIKAAoADAAKAQwBCgEKAwwDCgMKBQoFCAUKBQgHBgkIBwYJBgkECwYJBAsCDQILAg0CDQADAAEAAwADAAMBAwADAAMAAwEFAAUBBwEHAQcDBwEJAwkBCwMLAwsDDQUNAw0FDwUPBREHEwUTCRMHFwkXCRezAQAgyAEJBgkGCQYHBgkIBwgFCAcKBQoFCgUMAQwDDAEOAQ4AEA==",
  "=":"BgACAQUawAUA5gHEBAAA5QHDBAABBQC5AgDsAcQEAADrAcMEAA==",
  "B":"BgABA2e2BMQLFgAUARQBFAEUAxIDEgUSBRIFEAcQBxAJDgkOCQ4LDgsMCwwNDA0KDQgNCg0IDwYPBg8GDwQRBBEEEQIRAhMAEwAHAAkABwEHAAkBCQAHAQkBCQEHAQkBCQMJAwcDCQMJAwkFBwUJAwkHCQUHBQkHCQcJBwcHBwkHBwcJBwsHCQUQBQ4FDgcOCQ4JDAkMCwoNCg0IDwgRBhMEFQQXAhcCGwDJAQEvAysFJwklDSMPHREbFRkXFRsTHw8fCyUJJwcrAy0B6wMAEhIAoAsREuYDAAiRAYEElgEAKioSSA1EOR6JAQAA0wEJkAGPBSwSEiwAzAETKikSjwEAAMUCkAEA",
  "A":"BgABAg/KBfIBqQIAN98BEhHzAgAWEuwCngsREvwCABMR8gKdCxIR8QIAFBI54AEFlwGCBk3TA6ABAE3UAwMA",
  "?":"BgACAe4BsgaYCAAZABkBFwEXBRUDEwUTBxEHEQcPCQ8JDQkNCQ0LCwsLCwsLCQsJCwcNBwsHDQcLBQsFDQULAwkFCwMLAwkDCQMBAAABAQABAAEBAQABAAEAAQABAAABAQAAAQEAEwcBAQABAAMBAwADAAUABQAFAAcABwAFAAcABwAFAgcABQAHAAUAW7cCAABcABgBFgAUAhQAFAISAhACEAIQBA4EDgQMBgwGDAYMBgoICgYKCAgKCggICAgKBgoICgYMCAwGDAgOBg4GEAYQBgIAAgIEAAICBAACAgQCBAIKBAoGCAQKBggIBgYICAYIBggGCgQIBAoECAQKAggCCgIKAAgACgAKAAgBCAEKAwgDCAMIAwgFBgMIBQYHBAUGBQQFBAcCBQQHAgcCCQIHAgkCBwAJAgkACQAJAAkBCQAJAQsACQELAQsDCwELAwsDCwMLAwsDCwULAwsFCwMLBV2YAgYECAQKBAwGDAQMBhAIEAYSBhIIEgYUBhIEFgYUBBYEFgQWAhgCFgIYABYAGAAYARgBGAMWBRYHFgcWCRYLFA0IBQYDCAUIBwYFCAcGBwgHBgcICQYJCAkGCQYJCAsGCwYLBgsGDQYNBA0GDQQNBA8EDwQPAg8EEQIRAhEAEQITAWGpBesGAA4CDgIOAg4EDAQKBgwGCgYKCAgICggICAYKBgoGCgYKBAwECgQMBAoCDAAMAgwADAAMAQoADAEKAwwDCgMKAwoFCgUIBQoFCAcICQYHCAkGCQYLBgkECwINAg0CDQANAA0BDQENAQsDDQMJBQsFCQUJBwcHCQcFBwcJBQkFCQUJAwsDCQMLAwkBCwALAQsACwALAgkACwIJBAsECQQJBAkGCQYHBgcICQYHCgUIBwoFCgUMBQoBDgMMAQ4BDgAO",
  "C":"BgABAWmmA4ADAAUCBQAFAgUEBQIDBAUEAwQDBgMEAQYDBgEGAAgBBgDWAgAAwQLVAgATABMCEQITBBEEEQQRBhEIEQgPCA8KDwoNCg0MDQwNDAsOCw4LDgkOCxAHEAkQBxIHEgUSBRIDEgEUARIBFAAUAMIFABQCFAISBBQEEgQSBhIIEggSCBAKEAoQCg4MDgwODA4ODA4MDgwQDA4KEggQChIIEggSBhIGFAQSAhQCEgIUAMYCAADBAsUCAAUABwEFAAUBBQMDAQUDAwMDAwMFAQMDBQEFAAUBBwAFAMEF",
  "L":"BgABAQmcBhISEdkFABIQALQLwgIAAIEJ9AIAAK8C",
  "D":"BgABAkeyBMQLFAAUARIBFAESAxIDEgMSBRIFEAcQBxAHDgkOCQ4LDgsMCwwNDA0KDwoPCg8IDwgRCBEGEwQTBBMEEwIVAhUAFwDBBQAXARcBFwMTAxUDEwUTBxEHEQcPCQ8JDwkNCw0LCwsLDQsNCQ0JDQcPBw8HDwcRBREFEQMRAxEDEwERARMBEwDfAwASEgCgCxES4AMACT6BAxEuKxKLAQAAvwaMAQAsEhIsAMIF",
  "F":"BgABARGABoIJ2QIAAIECsgIAEhIA4QIRErECAACvBBIR5QIAEhIAsgucBQASEgDlAhES",
  "E":"BgABARRkxAuWBQAQEgDlAhES0QIAAP0BtgIAEhIA5wIRFLUCAAD/AfACABISAOUCERLDBQASEgCyCw==",
  "G":"BgABAZsBjgeIAgMNBQ8FDQUNBQ0HCwcNBwsHCwkLCQsJCwsJCwsLCQsJDQkLBw0HDwcNBw8FDwUPAw8DEQMPAxEBEQERARMBEQAXABUCFwIVAhMEFQQTBhMGEwYRCBEIDwoRCg8KDwwNDA0MDQ4LDgkQCRAJEAcQBxIFEgUUBRQDFAMUARYBFgEYAMoFABQCFAASBBQCEgQSBBIEEgYSBhAGEAgQCBAKDgoOCg4MDgwMDgwOChAKEAoSCBIIFAgUBhQEGAYWAhgEGAIaAOoCAAC3AukCAAcABwEFAQUBBQMFAwMFAwUDBQEFAQcBBQEFAQUABwAFAMUFAAUCBwIFAgUCBQQFBAMGBQYDBgUGAwgDBgMIAQgDCAEIAQoBCAEIAAgACgAIAAgCCAIIAggECgQGBAgECAYIBgC6AnEAAJwCmAMAAJcF",
  "H":"BgABARbSB7ILAQAAnwsSEeUCABISAOAE5QEAAN8EEhHlAgASEgCiCxEQ5gIAEREA/QPmAQAAgAQPEOYCABER",
  "I":"BgABAQmuA7ILAJ8LFBHtAgAUEgCgCxMS7gIAExE=",
  "J":"BgABAWuqB7ILALEIABEBEwERAREDEwMRAxEFEQURBw8HEQcPCQ0LDwsNCw0NDQ0LDwsPCxEJEQkTCRMJFQcVBxcFFwMZAxsBGwEbAB8AHQIbAhsEGQYXBhcGFQgTCBMKEwoRDA8KDwwNDA0OCw4LDgkQCRAJEAcQBRIFEgUSAxQDEgESARIBFAESABIAgAEREtoCABERAn8ACQIHBAcEBwYHBgUIBQoDCgMKAwoDDAEKAQwBCgEMAAwACgAMAgoCDAIKBAoECgYKBggGBgYGCAQGBAgCCgAIALIIERLmAgAREQ==",
  "M":"BgACAQRm1gsUABMAAAABE5wIAQDBCxIR5QIAEhIA6gIK5gLVAe0B1wHuAQztAgDhAhIR5QIAEhIAxAsUAPoDtwT4A7YEFgA=",
  "K":"BgABAVXMCRoLBQsDCQMLAwsDCwMLAwsBCwELAQsBCwELAQ0ACwELAAsADQALAg0ACwILAA0CCwILAgsCDQQLBAsECwYNBAsGCwYLCAsGCwgJCgsICQoJCgkMCQwJDAkOCRALEAkQCRKZAdICUQAAiwQSEecCABQSAKALExLoAgAREQC3BEIA+AG4BAEAERKCAwAREdkCzQXGAYUDCA0KDQgJCgkMBwoFDAUMAQwBDgAMAg4CDAQOBAwGDghmlQI=",
  "O":"BgABAoMBsATaCxwAHAEaARoDGgMYBRYFFgcWBxQJEgkSCRILEAsODQ4NDg0MDwoNDA8KDwgPCBEIDwYRBg8GEQQRAhMCEQITABMA0QUAEQETAREBEQMTBREFEQURBxEHDwcRCQ8LDQsPCw0NDQ0NDwsPCw8LEQkTCRMJEwkVBxUHFwUXAxkDGQEbARsAGwAZAhkCGQQXBhcGFQYVCBUIEwoRChEMEQoRDA8MDQ4NDg0OCxAJEAsQCRAHEgcSBxIFFAMSAxIDEgEUARIAEgDSBQASAhQCEgISBBIEEgYSBhIIEggQCBAKEgwODBAMEA4ODg4QDhIMEAwSChQKFAgUCBYIFgYYBBoGGgQcAh4CHgILggGLAylCWxZbFSlBANEFKklcGVwYKkwA0gU=",
  "N":"BgABAQ+YA/oEAOUEEhHVAgASEgC+CxQAwATnBQDIBRMS2AIAExEAzQsRAL8ElgU=",
  "P":"BgABAkqoB5AGABcBFQEVAxMDEwMTBREHEQcRBw8JDwkNCQ0LDQsNCwsNCw0JDQkNCQ8HDwcPBxEFEQURAxEDEQMTAREBEwETAH8AAIMDEhHlAgASEgCgCxES1AMAFAAUARIAFAESAxIDEgMSAxIFEAUQBRAHDgkOCQ4JDgsMCwwNDA0KDQoNCg8IDwgRCBEGEwQTBBUEFQIXAhkAGQCzAgnBAsoCESwrEn8AANUDgAEALBISLgDYAg==",
  "R":"BgABAj9msgsREvYDABQAFAESARQBEgESAxIDEgUSBRAFEAcQBw4JDgkOCQ4LDAsMDQwLCg0KDwoNCA8IDwgPBhEEEwYTAhMEFQIXABcAowIAEwEVARMDEwMTBRMFEQcTBxELEQsRDQ8PDREPEQ0VC8QB/QMSEfkCABQSiQGyA3EAALEDFBHnAgASEgCgCwnCAscFogEALhISLACqAhEsLRKhAQAApQM=",
  "Q":"BgABA4YBvAniAbkB8wGZAYABBQUFAwUFBQUHBQUDBwUFBQcFBQMHBQcDBwUJAwcDCQMJAwkDCQMJAQsDCwMLAQsDCwENAw0BDQEPAA8BDwAPABsAGwIZAhcEGQQXBBUGFQgVCBMIEQoTChEKDwwPDA8ODQ4NDgsQCxAJEAkQBxIHEgUSBRQFFAMUARQDFAEWABYAxgUAEgIUAhICEgQSBBIGEgYSCBIIEAgQChIMDgwQDBAODg4OEA4SDBAMEgoUChQIFAgWCBYGGAQaBhoEHAIeAh4CHAAcARoBGgMaAxgFFgUWBxYHFAkSCRIJEgsQCw4NDg0ODQwPCg0MDwoPCA8IEQgPBhEGDwYRBBECEwIRAhMAEwC7BdgBrwEImQSyAwC6AylAWxZbFSk/AP0BjAK7AQeLAoMCGEc4J0wHVBbvAaYBAEM=",
  "S":"BgABAYMC8gOEBxIFEgUQBxIFEgcSBxIJEgcSCRIJEAkQCRALEAsOCw4NDg0MDQ4PDA0KEQoPChEKEQgRCBMGFQQTBBcCFQAXABkBEwARAREBEQMPAQ8DDwMPAw0DDQUNAw0FCwULBwsFCwUJBwsFCQcHBQkHCQUHBwcHBwUHBwUFBQcHBwUHAwcFEQsRCxMJEwkTBxMFEwUVBRUDFQMVARMBFwEVABUAFQIVAhUCFQQVBBUEEwYVBhMIEwgTCBMIEwgRCBMKEQgRCmK6AgwFDgUMAw4FEAUOBRAFEAUQBRAFEAMSAw4DEAMQAxABEAEOAQ4AEAIMAg4CDgQMBAwGCggKCAoKBgwGDgYQBBACCgAMAAoBCAMKBQgFCAcIBwgJCAsGCQgLCA0IDQgNCA8IDQgPCA8IDwgPChEIDwgPCBEKDwoPDBEMDwwPDg8ODw4NEA0QCxALEgsSCRIHEgcUBRQFGAUYAxgBGgEcAR4CJAYkBiAIIAweDBwQHBAYEhgUFBYUFhQWEBoQGg4aDBwKHAoeBh4GIAQgAiACIgEiASIFIgUiBSAJIgkgCyINZ58CBwQJAgkECwQLAgsECwINBA0CDQQNAg0CDQALAg0ADQANAAsBCwELAQsDCwULBQkFCQcHBwcJBwkFCwMLAw0BDQENAAsCCwQLBAkGCQgJCAkKBwoJCgcMBQoHDAcMBQwF",
  "V":"BgABARG2BM4DXrYEbKwDERL0AgAVEesCnQsSEfsCABQS8QKeCxES8gIAExFuqwNgtQQEAA==",
  "T":"BgABAQskxAv0BgAAtQKVAgAA+wgSEeUCABISAPwImwIAALYC",
  "U":"BgABAW76B7ALAKMIABcBFwMXARUFFQUTBxMHEwkRCREJEQsPDQ0LDw0NDwsPCw8LEQkPCRMJEQcTBxMFEwUVBRUDEwMXARUBFQEXABUAEwIVAhMCFQQTBBUEEwYTBhMIEwgRChEIEQwRDA8MDw4PDg0OCxANEAsSCRIJEgcUBxQHFAMWBRYBGAEYARgApggBAREU9AIAExMAAgClCAALAgkECQQHBAcIBwgHCAUKBQoDCgMKAwwBCgEMAQwADAAMAgoCDAIKAgoECgQKBggGCAYICAYKBAgCCgIMAgwApggAARMU9AIAExM=",
  "X":"BgABARmsCBISEYkDABQSS54BWYICXYkCRZUBEhGJAwAUEtYCzgXVAtIFExKIAwATEVClAVj3AVb0AVKqAREShgMAERHXAtEF2ALNBQ==",
  "W":"BgABARuODcQLERHpAp8LFBHlAgASEnW8A2+7AxIR6wIAFBKNA6ALERKSAwATEdQB7wZigARZ8AIREugCAA8RaKsDYsMDXsoDaqYDExLqAgA=",
  "Y":"BgABARK4BcQLhgMAERHnAvMGAKsEEhHnAgAUEgCsBOkC9AYREoYDABERWOEBUJsCUqICVtwBERI=",
  "Z":"BgABAQmAB8QLnwOBCaADAADBAusGAMgDggmhAwAAwgLGBgA=",
  "`":"BgABAQfqAd4JkQHmAQAOlgJCiAGpAgALiwIA",
  "c":"BgABAW3UA84GBQAFAQUABQEFAwMBBQMDAwMDAwUBAwMFAQUABQEHAAUAnQMABQIFAAUCBQQFAgMEBQQDBAMGAwQBBgMGAQYABgEGAPABABoMAMsCGw7tAQATABMCEwARAhMEEQIPBBEEDwQPBg8IDwYNCA0KDQoNCgsMCwwLDAkOCRAHDgcQBxIFEgUUBRQDFAEWAxgBGAAYAKQDABQCFAISBBQCEgYSBhAGEggQCBAIEAoQCg4MDAwODAwODAwKDgwQCg4IEAgQCBAIEAYSBhIGEgQSAhQCFAIUAOABABwOAM0CGQzbAQA=",
  "a":"BgABApoB8AYCxwF+BwkHCQcJCQkHBwkHBwcJBQkFBwUJBQkFCQMHBQkDCQMJAwcDCQEHAQkBBwEJAQcABwAHAQcABQAHAAUBBQAFABMAEwITAhEEEwQPBBEGDwgPCA0IDwoLCg0KCwwLDAsMCQ4JDgkOBw4HEAcQBRAFEAUSAxADEgESAxIBFAESABQAFAISAhQCEgQSBBIEEgYSBhIIEAgQChAIDgwODA4MDg4MDgwODBAMEAoSCBIKEggUCBQGFgYWBBgEGAIaAhoAcgAADgEMAQoBCgEIAwgDBgUEBQQFBAcCBwIHAgkCCQAJAKsCABcPAMwCHAvCAgAUABYBEgAUARIDFAMQAxIDEAUSBQ4FEAcOCRAJDAkOCwwLDA0MCwoNCg8IDwgPCA8GEQYRBhMEEwIXAhUCFwAZAIMGFwAKmQLqA38ATxchQwgnGiMwD1AMUDYAdg==",
  "b":"BgABAkqmBIIJGAAYARYBFgEUAxQDEgUSBRIFEAcQCQ4HDgkOCw4LDAsMDQoNCg0KDQgPBg8GDwYRBBEEEQQTBBECEwIVAhMAFQD/AgAZARcBFwEXAxUDEwUTBREFEQcPBw8JDwkNCQ0LDQsLCwsNCQ0JDQcPBw8HDwURAxEDEQMTAxMBEwMVARUAFQHPAwAUEgCWCxEY5gIAERkAowKCAQAJOvECESwrEn8AAJsEgAEALBISLgCeAw==",
  "d":"BgABAkryBgDLAXAREQ8NEQ0PDREJDwkRBw8FDwURAw8DDwERAw8BEQEPACMCHwQfCB0MGw4bEhcUFxgVGhEeDSANJAkmBSgDKgEuAIADABYCFAIUAhQCFAQUBBIGEgYSBhAIEAgQCBAKDgoODAwMDAwMDgoOCg4KEAgQCBIGEgYSBhQEFgQWBBYCGAIYAHwAAKQCERrmAgARFwCnCxcADOsCugJGMgDmA3sAKxERLQCfAwolHBUmBSQKBAA=",
  "e":"BgABAqMBigP+AgAJAgkCCQQHBAcGBwYFCAUIBQgDCgMIAQoDCAEKAQoACgAKAAoCCAIKAggECgQIBAgGCAYGBgQIBAoECAIKAAyiAgAAGQEXARcBFwMVBRMFEwURBxEHDwcPCQ8LDQkNCwsNCw0LDQkNBw8JDwcPBQ8FEQURAxEDEwMTAxMBFQAVARcALwIrBCkIJwwlDiESHxQbGBkaFR4TIA0iCyQJKAMqASwAggMAFAIUABIEFAISBBIEEgQSBhIGEAgQCBAIEAoODA4MDgwODgwQDBAKEAoSChIIFAgUCBYGGAQYBhoCGgQcAh4ALgEqAygFJgkkDSANHhEaFRgXFBsSHQ4fDCUIJwQpAi0AGQEXAxcDFQcTBRMJEQkPCw8LDQ0PDQsNDQ8LEQsRCxEJEwkTCRMJEwcTBxUHFQUVBRUHFQUVBRUHFwcVBRUHCs4BkAMfOEUURxEfMwBvbBhAGBwaBiA=",
  "h":"BgABAUHYBJAGAAYBBgAGAQYDBgEEAwYDBAMEBQQDAgUEBQIFAAUCBQB1AAC5BhIT5wIAFhQAlAsRGOYCABEZAKMCeAAYABgBFgEWARQDFAMSBRIFEgUQBxAJDgcOCQ4LDgsMCwwNCg0KDQoNCA8GDwYPBhEEEQQRBBMEEQITAhUCEwAVAO0FFhPnAgAUEgD+BQ==",
  "g":"BgABArkBkAeACQCNCw8ZERkRFxEVExMVERUPFQ8XDRcLGQkZBxsFGwUdAR0BDQALAA0ADQINAAsCDQANAg0CDQILAg0EDQINBA0GDQQNBg0EDQYNCA0GDwgNCA0IDQgPCg0KDwwNDA8MDw4PDqIB7gEQDRALEAkQCQ4JEAcOBw4FDgUOAwwFDgMMAQwBDAEMAQwACgEKAAoACAIIAAgCCAIGAggCBgIGBAYCBgQEAgYEAqIBAQADAAEBAwADAAMABQADAAUAAwAFAAMABQAFAAMABQA3ABMAEwIRAhMCEQQRBBEEEQYRBg8IDwgPCA0KDQoNCg0MCwwLDgsOCQ4JDgkQBxAHEgcSBRIDFAMWAxQBFgEYABgA/gIAFgIWAhQEFgQUBBIGFAgSCBIIEAoSChAKDgwODA4MDg4MDgwODA4KEAgQCBAIEgYSBhIEEgYSBBQCEgIUAhQCOgAQABABDgEQAQ4BEAMOAw4FDgUOBQwFDgcMBQ4HDAkMB4oBUBgACbsCzQYAnAR/AC0RES0AnQMSKy4RgAEA",
  "f":"BgABAUH8A6QJBwAHAAUABwEFAQcBBQEFAwUDBQMDAwMDAwUDAwMFAQUAwQHCAQAWEgDZAhUUwQEAAOMEFhftAgAWFADKCQoSChIKEAoQCg4KDgwOCgwMDAoKDAwMCgwIDAgMCAwIDAYOCAwEDgYMBA4GDAIOBA4CDgQOAg4CDgAOAg4ADgC2AQAcDgDRAhkQowEA",
  "i":"BgACAQlQABISALoIERLqAgAREQC5CBIR6QIAAWELyAoADgIOAgwEDgIKBgwGCgYKCAoGCAgICggIBggGCgYKBAoECgQMBAoCDAIMAgwCDAAMAAwADAEMAQoBDAMKAwoDCgUKBQgFCgUIBwgHCAcICQgJBgkECwQJBA0CCwANAA0ADQELAQ0BCwMJBQsFCQUJBwkFBwcHBwcJBQcFCQUJBQkDCQMLAwkBCwELAQsACwALAAsCCwILAgkCCwIJBAkECQQJBgcGCQYHCAcIBwgHCgUKBQwFCgMMAQwBDgEMAA4=",
  "j":"BgACAWFKyAoADgIOAgwEDgIKBgwGCgYKCAoGCAgICggIBggGCgYKBAoECgQMBAoCDAIMAgwCDAAMAAwADAEMAQoBDAMKAwoDCgUKBQgFCgUIBwgHCAcICQgJBgkECwQJBA0CCwANAA0ADQELAQ0BCwMJBQsFCQUJBwkFBwcHBwcJBQcFCQUJBQkDCQMLAwkBCwELAQsACwALAAsCCwILAgkCCwIJBAkECQQJBgcGCQYHCAcIBwgHCgUKBQwFCgMMAQwBDgEMAA4BO+YCnwwJEQkRCQ8JDwsNCQ0LDQkLCwsJCQsLCQkLBwsHCwcLBwsFCwcNAwsFDQMLBQ0BDQMNAQ0DDQENAQ0ADQENAA0AVwAbDQDSAhoPQgAIAAgABgAIAgYCCAIGAgYEBgQGBAQEBAQEBgQEBAYCBgC4CRES6gIAEREAowo=",
  "k":"BgABARKoA/QFIAC0AYoD5gIAjwK5BJICwwTfAgDDAbIDFwAAnwMSEeUCABISAJILERLmAgAREQCvBQ==",
  "n":"BgABAW1yggmQAU8GBAgEBgQGBgYCCAQGBAYEBgQIAgYECAQGAggEBgIIBAgCCAQIAggCCAIIAgoACAIKAAgCCgAKAgoADAAKAgwAFgAWARQAFAEUAxQDFAMSAxIFEgUQBRIHEAkOBxAJDgsOCwwLDA0MDQoPCA8IEQgRBhEGEwYVBBUEFQIXAhkCGQDtBRQR5QIAFBAA/AUACAEIAQYBCAMGBQQFBgUEBwQFBAcCBwIHAgcCCQIHAAcACQAHAQcABwMHAQUDBwMFAwUFBQUDBQEFAwcBBwAHAPkFEhHjAgASEgDwCBAA",
  "m":"BgABAZoBfoIJigFbDAwMCg4KDggOCA4IDgYQBhAGEAQQBBAEEAISAhACEgAmASQDJAciCyANHhEcFRwXDg4QDBAKEAwQCBAKEggSBhIGEgYSBBQEEgIUAhICFAAUABQBEgEUARIDEgMSAxIFEgUQBxAHEAcQBw4JDgkOCw4LDAsMDQoNCg8KDwgPCBEIEQYRBBMEEwQTAhMCFQAVAP0FEhHlAgASEgCCBgAIAQgBBgEGAwYFBgUEBQQHBAUEBwIHAgcCBwIJAAcABwAJAAcBBwEHAQUBBwMFAwUDBQMDBQMFAwUBBQEHAQcAgQYSEeUCABISAIIGAAgBCAEGAQYDBgUGBQQFBAcEBQQHAgcCBwIHAgkABwAHAAkABwEHAQcBBQEHAwUDBQMFAwMFAwUDBQEFAQcBBwCBBhIR5QIAEhIA8AgYAA==",
  "l":"BgABAQnAAwDrAgASFgDWCxEa6gIAERkA0wsUFw==",
  "y":"BgABAZ8BogeNAg8ZERkRFxEVExMVERUPFQ8XDRcLGQkZBxsFGwUdAR0BDQALAA0ADQINAAsCDQANAg0CDQILAg0EDQINBA0GDQQNBg0EDQYNCA0GDwgNCA0IDQgPCg0KDwwNDA8MDw4PDqIB7gEQDRALEAkQCQ4JEAcOBw4FDgUOAwwFDgMMAQwBDAEMAQwACgEKAAoACAIIAAgCCAIGAggCBgIGBAYCBgQEAgYEAqIBAQADAAEBAwADAAMABQADAAUAAwAFAAMABQAFAAMABQA3ABMAEwIRABECEwQRAg8EEQQPBBEGDwgNCA8IDQgNCg0MDQwLDAkOCw4JDgcQBxAHEgUSBRQFFAMWARgDGAEaABwA9AUTEuQCABEPAP8FAAUCBQAFAgUEBQIDBAUEAwQDBgMEAQYDBgEGAAgBBgCAAQAAvAYREuICABMPAP0K",
  "q":"BgABAmj0A4YJFgAWARQAEgESAxADEAMOAw4FDgUMBQ4HDgcOBwwJDgmeAU4A2QwWGesCABYaAN4DAwADAAMBAwADAAUAAwADAAMABQAFAAUABwAHAQcACQAVABUCFQATAhUCEwQRAhMEEQQRBhEGDwgPCA8IDQoNDA0MCwwLDgkOCRAJEAkQBxIHEgUUBRYDFgMYARoBGgAcAP4CABYCFgIWBBYEFAQSBhQIEggSCBAKEgoQDA4MDgwODg4ODBAMDgwQChIIEAoSCBIGEgYUBhQEFAQWAhYCFgIWAApbkQYSKy4ReAAAjARTEjkRHykJMwDvAg==",
  "p":"BgABAmiCBIYJFgAWARYBFAEWAxQDEgUUBRIFEgcSBxAJEAkQCQ4LDgsOCwwNDA0KDwoPCg8IEQgRCBEGEwQTBhMCFQQVAhUAFQD9AgAbARkBFwMXAxcDEwUTBxMHEQcRCQ8JDQsNCw0LCw0LDQkPCQ0JDwURBxEFEQURAxMDEQMTARUBEwEVARUBFQAJAAcABwAFAAcABQAFAAMAAwADAAUAAwIDAAMAAwIDAADdAxYZ6wIAFhoA2gyeAU0OCgwIDgoMCA4GDgYMBg4GDgQQBBAEEgQUAhQCFgIWAApcoQMJNB8qNxJVEQCLBHgALhISLADwAg==",
  "o":"BgABAoMB8gOICRYAFgEWARQBFgMUAxIDFAUSBRIHEgcQBxAJEAkOCw4LDgsMDQwNCg8KDwoPCg8IEQgRBhMGEwQTBBMCFQIVABcAiwMAFwEVARUDEwMTAxMFEwcRBxEHDwkPCQ8LDQsNCw0NCw0LDwkNCw8HEQkPBxEHEQcRBRMFEwMTAxUDFQEVABUAFQAVAhUCFQITBBMEEwYTBhEGEQgRCA8KDwoPCg0KDQwNDAsOCw4JDgkQCRAJEgcSBxIFFAUUAxQDFgEWARYAFgCMAwAYAhYCFgQUBBQEFAYUCBIIEggQChAKEAwODA4MDg4MDgwQCg4KEgoQChIIEggSBhQGEgYUBBYEFAIWAhYCFgALYv0CHTZBFEMRHTcAjwMcNUITQhIiOACQAw==",
  "r":"BgACAQRigAkQAA8AAAABShAAhAFXDAwODAwKDgoOCBAIDgYQBhAEEAQQBBAEEAISABACEAAQAA4BEAAQARADEAEQAxADEAUSBRIHFAcUCxQLFA0WDVJFsQHzAQsMDQwLCgkICwgLCAkGCQYJBAkGBwIJBAcCBwQHAAcCBwAFAgcABQAHAQUABQEFAQUBBQEDAQUBAwMDAQMDAwEAmwYSEeMCABISAO4IEAA=",
  "u":"BgABAV2KBwGPAVANCQsHDQcNBw0FCwUNBQ0FDQMPAw8DEQMTARMBFQEVABUAFQITABMEEwITBBMEEQQRBhEGDwYRCA8KDQgPCg0MDQwLDAsOCRALDgcQBxIHEgUUBRQFFAMWAxgBGAEYARoA7gUTEuYCABMPAPsFAAcCBwIFBAcCBQYDBgUGAwgDBgMIAQgBCAEIAQoBCAAIAAoACAIIAggCCAIGBAgEBgQGBgYGBAYCBgQIAggACAD6BRES5AIAEREA7wgPAA==",
  "s":"BgABAasC/gLwBQoDCgMMBQ4DDgUOBRAFEAUSBRAHEgcQCRIJEAkSCxALEAsQDRANDg0ODw4PDA8MDwoRChEIEwYTBBcCFQIXABkBGQEXAxcFFQUTBRMHEwcRCREJDwkNCQ8LDQ0LCwsNCw0JDQkPBw8HDwUPBREDEQMRAREDEQETABEBEwARABMADwIRABECEQIRBBMCEwQVBBUEFQYVBhMIFwgVChUKFQxgsAIIAwYDCAMKAQgDCAMKAQoDCgEKAwoBCgMKAQwDCgEKAwoBDAMKAQoBCgEMAQoACgEKAAoBCgAKAQgACgAIAQgABgoECAIKAgoCCgAMAQoBDAUEBwIHBAcEBwIHBAkECQQJBAkECQYLBAkGCwYJBgsGCwYJCAsGCwgJBgsICQgLCAkICwgJCgkKCQoJCgcKCQwHDAcMBwwFDAcMAw4FDAMOAw4BDgMQARAAEAESABIAEgIQAg4CDgIOBA4CDgQMBAwEDAQMBgoECgYKBgoGCgYIBggGCAgIBggGBgYIBgYGBgYGBgYGBAgGBgQIBAYECAQQChIIEggSBhIEEgQSBBQCFAISABQAEgASABIAEgESARIBEAEQAxIDDgMQAxADDgUOBQwDDAMMAwoDCAMIAQYBe6cCAwIDAgUAAwIFAgUCBwIFAgcCBQIHAgUCBwIHAAUCBwIHAgUABwIHAgcABQIHAAcCBwAFAgUABQIFAAUABQIDAAEAAQABAQEAAQEBAQEBAQEBAQEDAQEAAwEBAQMAAwEDAAMBAwADAQMAAwABAQMAAwADAAEAAwIBAAMCAQQDAgE=",
  "t":"BgABAUe8BLACWAAaEADRAhsOaQANAA0ADwINAA0CDQANAg0CDQINBA0CCwYNBA0GCwYNBgsIDQgLCAsKCwgJDAsKCQwJDAkOCQ4HEAcSBxIHEgUUAOAEawAVEQDWAhYTbAAAygIVFOYCABUXAMUCogEAFhQA1QIVEqEBAADzAwIFBAMEBQQDBAMEAwYDBgMGAwYBCAEGAQgBBgEIAAgA",
  "w":"BgABARz8BsAEINYCKNgBERLuAgARD+8B3QgSEc0CABQSW7YCV7UCFBHJAgASEpMC3AgREvACABERmAHxBDDaAVeYAxES7gIAEREo1QE81wIIAA==",
  "z":"BgABAQ6cA9AGuQIAFw8AzAIaC9QFAAAr9wKjBuACABYQAMsCGQyZBgCaA9AG"
   }';
BEGIN

  IF font IS NULL THEN
    font := font_default;
  END IF;

  -- For character spacing, use m as guide size
  geom := ST_GeomFromTWKB(decode(font->>'m', 'base64'));
  m_width := ST_XMax(geom) - ST_XMin(geom);
  spacing := m_width / 12;

  letterarray := regexp_split_to_array(replace(letters, ' ', E'\t'), E'');
  FOREACH letter IN ARRAY letterarray
  LOOP
    geom := ST_GeomFromTWKB(decode(font->>(letter), 'base64'));
    -- Chars are not already zeroed out, so do it now
    geom := ST_Translate(geom, -1 * ST_XMin(geom), 0.0);
    -- unknown characters are treated as spaces
    IF geom IS NULL THEN
      -- spaces are a "quarter m" in width
      width := m_width / 3.5;
    ELSE
      width := (ST_XMax(geom) - ST_XMin(geom));
    END IF;
    geom := ST_Translate(geom, position, 0.0);
    -- Tighten up spacing when characters have a large gap
    -- between them like Yo or To
    adjustment := 0.0;
    IF prevgeom IS NOT NULL AND geom IS NOT NULL THEN
      dist = ST_Distance(prevgeom, geom);
      IF dist > spacing THEN
        adjustment = spacing - dist;
        geom := ST_Translate(geom, adjustment, 0.0);
      END IF;
    END IF;
    prevgeom := geom;
    position := position + width + spacing + adjustment;
    wordarr := array_append(wordarr, geom);
  END LOOP;
  -- apply the start point and scaling options
  wordgeom := ST_CollectionExtract(ST_Collect(wordarr));
  wordgeom := ST_Scale(wordgeom,
                text_height/font_default_height,
                text_height/font_default_height);
  return wordgeom;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="letters" type="text"/>
            <parameter mode="IN" name="font" type="json"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linecrossingdirection(line1 geometry, line2 geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_LineCrossingDirection]]></definition>
         <parameters>
            <parameter mode="IN" name="line1" type="geometry"/>
            <parameter mode="IN" name="line2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineextend(geom geometry, distance_forward double precision, distance_backward double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line, distance_forward, distance_backward=0.0 - Returns a line with the last and first segments extended the specified distance(s).]]></comment>
         <definition language="c"><![CDATA[geometry_line_extend]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="distance_forward" type="double precision"/>
            <parameter mode="IN" name="distance_backward" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromencodedpolyline(txtin text, nprecision integer DEFAULT 5)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[line_from_encoded_polyline]]></definition>
         <parameters>
            <parameter mode="IN" name="txtin" type="text"/>
            <parameter mode="IN" name="nprecision" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefrommultipoint(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aMultiPoint - Creates a LineString from a MultiPoint geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_from_mpoint]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'LINESTRING'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'LINESTRING'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linefromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoint(geography, double precision, use_spheroid boolean DEFAULT true)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction, use_spheroid = true - Returns a point interpolated along a line at a fractional location.]]></comment>
         <definition language="c"><![CDATA[geography_line_interpolate_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoint(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction - Returns a point interpolated along a line at a fractional location.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_interpolate_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoint(text, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_LineInterpolatePoint($1::public.geometry, $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoints(geography, double precision, use_spheroid boolean DEFAULT true, repeat boolean DEFAULT true)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction, use_spheroid = true, repeat = true - Returns points interpolated along a line at a fractional interval.]]></comment>
         <definition language="c"><![CDATA[geography_line_interpolate_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
            <parameter mode="IN" name="repeat" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoints(geometry, double precision, repeat boolean DEFAULT true)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_fraction, repeat - Returns points interpolated along a line at a fractional interval.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_interpolate_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" name="repeat" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_lineinterpolatepoints(text, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_LineInterpolatePoints($1::public.geometry, $2);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linelocatepoint(geography, geography, use_spheroid boolean DEFAULT true)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_point, use_spheroid = true - Returns the fractional location of the closest point on a line to a point.]]></comment>
         <definition language="c"><![CDATA[geography_line_locate_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linelocatepoint(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, a_point - Returns the fractional location of the closest point on a line to a point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_locate_point]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linelocatepoint(text, text)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_LineLocatePoint($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linemerge(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: amultilinestring - Return the lines formed by sewing together a MultiLineString.]]></comment>
         <definition language="c"><![CDATA[linemerge]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linemerge(geometry, boolean)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: amultilinestring, directed - Return the lines formed by sewing together a MultiLineString.]]></comment>
         <definition language="c"><![CDATA[linemerge]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linestringfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linestringfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'LINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linesubstring(geography, double precision, double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, startfraction, endfraction - Returns the part of a line between two fractional locations.]]></comment>
         <definition language="c"><![CDATA[geography_line_substring]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linesubstring(geometry, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, startfraction, endfraction - Returns the part of a line between two fractional locations.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_substring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linesubstring(text, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_LineSubstring($1::public.geometry, $2, $3);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_linetocurve(geometry geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomANoncircular - Converts a linear geometry to a curved geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_line_desegmentize]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatealong(geometry geometry, measure double precision, leftrightoffset double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom_with_measure, measure, offset = 0 - Returns the point(s) on a geometry that match a measure value.]]></comment>
         <definition language="c"><![CDATA[ST_LocateAlong]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
            <parameter mode="IN" name="measure" type="double precision"/>
            <parameter mode="IN" name="leftrightoffset" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatebetween(geometry geometry, frommeasure double precision, tomeasure double precision, leftrightoffset double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, measure_start, measure_end, offset = 0 - Returns the portions of a geometry that match a measure range.]]></comment>
         <definition language="c"><![CDATA[ST_LocateBetween]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
            <parameter mode="IN" name="frommeasure" type="double precision"/>
            <parameter mode="IN" name="tomeasure" type="double precision"/>
            <parameter mode="IN" name="leftrightoffset" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_locatebetweenelevations(geometry geometry, fromelevation double precision, toelevation double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, elevation_start, elevation_end - Returns the portions of a geometry that lie in an elevation (Z) range.]]></comment>
         <definition language="c"><![CDATA[ST_LocateBetweenElevations]]></definition>
         <parameters>
            <parameter mode="IN" name="geometry" type="geometry"/>
            <parameter mode="IN" name="fromelevation" type="double precision"/>
            <parameter mode="IN" name="toelevation" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_longestline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D longest line between two geometries.]]></comment>
         <definition language="sql"><![CDATA[SELECT public._ST_LongestLine(public.ST_ConvexHull($1), public.ST_ConvexHull($2))]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_m(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the M coordinate of a Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_m_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makebox2d(geom1 geometry, geom2 geometry)" returnType="box2d" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: pointLowLeft, pointUpRight - Creates a BOX2D defined by two 2D point geometries.]]></comment>
         <definition language="c"><![CDATA[BOX2D_construct]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeenvelope(double precision, double precision, double precision, double precision, integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: xmin, ymin, xmax, ymax, srid=unknown - Creates a rectangular Polygon from minimum and maximum coordinates.]]></comment>
         <definition language="c"><![CDATA[ST_MakeEnvelope]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom1, geom2 - Creates a LineString from Point, MultiPoint, or LineString geometries.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makeline]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeline(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geoms - Creates a LineString from Point, MultiPoint, or LineString geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makeline(geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geoms_array - Creates a LineString from Point, MultiPoint, or LineString geometries.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makeline_garray]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepoint(double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y - Creates a 2D, 3DZ or 4D Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoint]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepoint(double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, z - Creates a 2D, 3DZ or 4D Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoint]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepoint(double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, z, m - Creates a 2D, 3DZ or 4D Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoint]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepointm(double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, m - Creates a Point from X, Y and M values.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoint3dm]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepolygon(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring - Creates a Polygon from a shell and optional list of holes.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makepolygon(geometry, geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: outerlinestring, interiorlinestrings - Creates a Polygon from a shell and optional list of holes.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makevalid(geom geometry, params text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input, params - Attempts to make an invalid geometry valid without losing vertices.]]></comment>
         <definition language="c"><![CDATA[ST_MakeValid]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="params" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_makevalid(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input - Attempts to make an invalid geometry valid without losing vertices.]]></comment>
         <definition language="c"><![CDATA[ST_MakeValid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_maxdistance(geom1 geometry, geom2 geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Returns the 2D largest distance between two geometries in projected units.]]></comment>
         <definition language="sql"><![CDATA[SELECT public._ST_MaxDistance(public.ST_ConvexHull($1), public.ST_ConvexHull($2))]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_maximuminscribedcircle(geometry, OUT center geometry, OUT nearest geometry, OUT radius double precision)" returnType="record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Computes the largest circle contained within a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_MaximumInscribedCircle]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="OUT" name="center" type="geometry"/>
            <parameter mode="OUT" name="nearest" type="geometry"/>
            <parameter mode="OUT" name="radius" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memcollect(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment/>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memsize(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the amount of memory space a geometry takes.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_mem_size]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_memunion(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - Aggregate function which unions geometries in a memory-efficent but slower way]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumboundingcircle(inputgeom geometry, segs_per_quarter integer DEFAULT 48)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, num_segs_per_qt_circ=48 - Returns the smallest circle polygon that contains a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_MinimumBoundingCircle]]></definition>
         <parameters>
            <parameter mode="IN" name="inputgeom" type="geometry"/>
            <parameter mode="IN" name="segs_per_quarter" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumboundingradius(geometry, OUT center geometry, OUT radius double precision)" returnType="record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns the center point and radius of the smallest circle that contains a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_MinimumBoundingRadius]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="OUT" name="center" type="geometry"/>
            <parameter mode="OUT" name="radius" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumclearance(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the minimum clearance of a geometry, a measure of a geometrys robustness.]]></comment>
         <definition language="c"><![CDATA[ST_MinimumClearance]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_minimumclearanceline(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns the two-point LineString spanning a geometrys minimum clearance.]]></comment>
         <definition language="c"><![CDATA[ST_MinimumClearanceLine]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE
	WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mlinefromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTIPOINT'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOINT'
	THEN ST_GeomFromText($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpointfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromText($1,$2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_mpolyfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multi(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Return the geometry as a MULTI* geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_force_multi]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multilinefromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTILINESTRING'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multilinestringfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_MLineFromText($1)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multilinestringfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_MLineFromText($1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipointfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_MPointFromText($1)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipointfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipointfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'MULTIPOINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolyfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolyfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'MULTIPOLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolygonfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_MPolyFromText($1)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_multipolygonfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_MPolyFromText($1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ndims(geometry)" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the coordinate dimension of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_ndims]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_node(g geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Nodes a collection of lines.]]></comment>
         <definition language="c"><![CDATA[ST_Node]]></definition>
         <parameters>
            <parameter mode="IN" name="g" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_normalize(geom geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Return the geometry in its canonical form.]]></comment>
         <definition language="c"><![CDATA[ST_Normalize]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_npoints(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the number of points (vertices) in a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_npoints]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_nrings(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the number of rings in a polygonal geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_nrings]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numgeometries(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns the number of elements in a geometry collection.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_numgeometries_collection]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numinteriorring(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns the number of interior rings (holes) of a Polygon. Aias for ST_NumInteriorRings]]></comment>
         <definition language="c"><![CDATA[LWGEOM_numinteriorrings_polygon]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numinteriorrings(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_polygon - Returns the number of interior rings (holes) of a Polygon.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_numinteriorrings_polygon]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numpatches(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Return the number of faces on a Polyhedral Surface. Will return null for non-polyhedral geometries.]]></comment>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN public.ST_NumGeometries($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_numpoints(geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the number of points in a LineString or CircularString.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_numpoints_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_offsetcurve(line geometry, distance double precision, params text DEFAULT ''::text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: line, signed_distance, style_parameters=' - Returns an offset line at a given distance and side from an input line.]]></comment>
         <definition language="c"><![CDATA[ST_OffsetCurve]]></definition>
         <parameters>
            <parameter mode="IN" name="line" type="geometry"/>
            <parameter mode="IN" name="distance" type="double precision"/>
            <parameter mode="IN" name="params" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_orderingequals(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_same]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_orientedenvelope(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a minimum-area rectangle containing a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_OrientedEnvelope]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_overlaps(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[overlaps]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_patchn(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, n - Returns the Nth geometry (face) of a PolyhedralSurface.]]></comment>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.ST_GeometryType($1) = 'ST_PolyhedralSurface'
	THEN public.ST_GeometryN($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_perimeter(geog geography, use_spheroid boolean DEFAULT true)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, use_spheroid = true - Returns the length of the boundary of a polygonal geometry or geography.]]></comment>
         <definition language="c"><![CDATA[geography_perimeter]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_perimeter(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the length of the boundary of a polygonal geometry or geography.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_perimeter2d_poly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_perimeter2d(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the 2D perimeter of a polygonal geometry. Alias for ST_Perimeter.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_perimeter2d_poly]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_point(double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y - Creates a Point with X, Y and SRID values.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_makepoint]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_point(double precision, double precision, srid integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, srid=unknown - Creates a Point with X, Y and SRID values.]]></comment>
         <definition language="c"><![CDATA[ST_Point]]></definition>
         <parameters>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromgeohash(text, integer DEFAULT NULL::integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[point_from_geohash]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POINT'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'POINT'
	THEN public.ST_GeomFromText($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POINT'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POINT'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointinsidecircle(geometry, double precision, double precision, double precision)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_inside_circle_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointm(xcoordinate double precision, ycoordinate double precision, mcoordinate double precision, srid integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, m, srid=unknown - Creates a Point with X, Y, M and SRID values.]]></comment>
         <definition language="c"><![CDATA[ST_PointM]]></definition>
         <parameters>
            <parameter mode="IN" name="xcoordinate" type="double precision"/>
            <parameter mode="IN" name="ycoordinate" type="double precision"/>
            <parameter mode="IN" name="mcoordinate" type="double precision"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointn(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_linestring, n - Returns the Nth point in the first LineString or circular LineString in a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_pointn_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointonsurface(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Computes a point guaranteed to lie in a polygon, or on a geometry.]]></comment>
         <definition language="c"><![CDATA[pointonsurface]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_points(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Returns a MultiPoint containing the coordinates of a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_Points]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointz(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, srid integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, z, srid=unknown - Creates a Point with X, Y, Z and SRID values.]]></comment>
         <definition language="c"><![CDATA[ST_PointZ]]></definition>
         <parameters>
            <parameter mode="IN" name="xcoordinate" type="double precision"/>
            <parameter mode="IN" name="ycoordinate" type="double precision"/>
            <parameter mode="IN" name="zcoordinate" type="double precision"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_pointzm(xcoordinate double precision, ycoordinate double precision, zcoordinate double precision, mcoordinate double precision, srid integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: x, y, z, m, srid=unknown - Creates a Point with X, Y, Z, M and SRID values.]]></comment>
         <definition language="c"><![CDATA[ST_PointZM]]></definition>
         <parameters>
            <parameter mode="IN" name="xcoordinate" type="double precision"/>
            <parameter mode="IN" name="ycoordinate" type="double precision"/>
            <parameter mode="IN" name="zcoordinate" type="double precision"/>
            <parameter mode="IN" name="mcoordinate" type="double precision"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1)) = 'POLYGON'
	THEN public.ST_GeomFromText($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromText($1, $2)) = 'POLYGON'
	THEN public.ST_GeomFromText($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polyfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1, $2)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygon(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: lineString, srid - Creates a Polygon from a LineString with a specified SRID.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_SetSRID(public.ST_MakePolygon($1), $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromtext(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_PolyFromText($1)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromtext(text, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_PolyFromText($1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromwkb(bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonfromwkb(bytea, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT CASE WHEN public.geometrytype(public.ST_GeomFromWKB($1,$2)) = 'POLYGON'
	THEN public.ST_GeomFromWKB($1, $2)
	ELSE NULL END]]></definition>
         <parameters>
            <parameter mode="IN" type="bytea"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonize(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: geomfield - Computes a collection of polygons formed from the linework of a set of geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_polygonize(geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom_array - Computes a collection of polygons formed from the linework of a set of geometries.]]></comment>
         <definition language="c"><![CDATA[polygonize_garray]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_project(geog geography, distance double precision, azimuth double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, distance, azimuth - Returns a point projected from a start point by a distance and bearing (azimuth).]]></comment>
         <definition language="c"><![CDATA[geography_project]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="distance" type="double precision"/>
            <parameter mode="IN" name="azimuth" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_project(geog_from geography, geog_to geography, distance double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, distance - Returns a point projected from a start point by a distance and bearing (azimuth).]]></comment>
         <definition language="c"><![CDATA[geography_project_geography]]></definition>
         <parameters>
            <parameter mode="IN" name="geog_from" type="geography"/>
            <parameter mode="IN" name="geog_to" type="geography"/>
            <parameter mode="IN" name="distance" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_project(geom1 geometry, distance double precision, azimuth double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, distance, azimuth - Returns a point projected from a start point by a distance and bearing (azimuth).]]></comment>
         <definition language="c"><![CDATA[geometry_project_direction]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="distance" type="double precision"/>
            <parameter mode="IN" name="azimuth" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_project(geom1 geometry, geom2 geometry, distance double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, distance - Returns a point projected from a start point by a distance and bearing (azimuth).]]></comment>
         <definition language="c"><![CDATA[geometry_project_geometry]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="distance" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_quantizecoordinates(g geometry, prec_x integer, prec_y integer DEFAULT NULL::integer, prec_z integer DEFAULT NULL::integer, prec_m integer DEFAULT NULL::integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, prec_x, prec_y, prec_z, prec_m - Sets least significant bits of coordinates to zero]]></comment>
         <definition language="c"><![CDATA[ST_QuantizeCoordinates]]></definition>
         <parameters>
            <parameter mode="IN" name="g" type="geometry"/>
            <parameter mode="IN" name="prec_x" type="integer"/>
            <parameter mode="IN" name="prec_y" type="integer"/>
            <parameter mode="IN" name="prec_z" type="integer"/>
            <parameter mode="IN" name="prec_m" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_reduceprecision(geom geometry, gridsize double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g, gridsize - Returns a valid geometry with points rounded to a grid tolerance.]]></comment>
         <definition language="c"><![CDATA[ST_ReducePrecision]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relate(geom1 geometry, geom2 geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[relate_full]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relate(geom1 geometry, geom2 geometry, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[relate_full]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relate(geom1 geometry, geom2 geometry, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[relate_pattern]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_relatematch(text, text)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[ST_RelateMatch]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_removepoint(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, offset - Remove a point from a linestring.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_removepoint]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_removerepeatedpoints(geom geometry, tolerance double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance - Returns a version of a geometry with duplicate points removed.]]></comment>
         <definition language="c"><![CDATA[ST_RemoveRepeatedPoints]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_reverse(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Return the geometry with vertex order reversed.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_reverse]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotate(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about an origin point.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2), cos($2), 0,  0, 0, 1,  0, 0, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotate(geometry, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians, x0, y0 - Rotates a geometry about an origin point.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1,	$3 - cos($2) * $3 + sin($2) * $4, $4 - sin($2) * $3 - cos($2) * $4, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotate(geometry, double precision, geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians, pointOrigin - Rotates a geometry about an origin point.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  cos($2), -sin($2), 0,  sin($2),  cos($2), 0, 0, 0, 1, public.ST_X($3) - cos($2) * public.ST_X($3) + sin($2) * public.ST_Y($3), public.ST_Y($3) - sin($2) * public.ST_X($3) - cos($2) * public.ST_Y($3), 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatex(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the X axis.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1, 1, 0, 0, 0, cos($2), -sin($2), 0, sin($2), cos($2), 0, 0, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatey(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the Y axis.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  cos($2), 0, sin($2),  0, 1, 0,  -sin($2), 0, cos($2), 0,  0, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_rotatez(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, rotRadians - Rotates a geometry about the Z axis.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Rotate($1, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scale(geometry, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, XFactor, YFactor - Scales a geometry by given factors.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Scale($1, $2, $3, 1)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scale(geometry, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, XFactor, YFactor, ZFactor - Scales a geometry by given factors.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Scale($1, public.ST_MakePoint($2, $3, $4))]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scale(geometry, geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, factor - Scales a geometry by given factors.]]></comment>
         <definition language="c"><![CDATA[ST_Scale]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scale(geometry, geometry, origin geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, factor, origin - Scales a geometry by given factors.]]></comment>
         <definition language="c"><![CDATA[ST_Scale]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="origin" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_scroll(geometry, geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, point - Change start point of a closed LineString.]]></comment>
         <definition language="c"><![CDATA[ST_Scroll]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_segmentize(geog geography, max_segment_length double precision)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geog, max_segment_length - Returns a modified geometry/geography having no segment longer than a given distance.]]></comment>
         <definition language="c"><![CDATA[geography_segmentize]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="max_segment_length" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_segmentize(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, max_segment_length - Returns a modified geometry/geography having no segment longer than a given distance.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_segmentize2d]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_seteffectivearea(geometry, double precision DEFAULT '-1'::integer, integer DEFAULT 1)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, threshold = 0, set_area = 1 - Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_SetEffectiveArea]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_setpoint(geometry, integer, geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: linestring, zerobasedposition, point - Replace point of a linestring with a given point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_setpoint_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_setsrid(geog geography, srid integer)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_set_srid]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_setsrid(geom geometry, srid integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, srid - Set the SRID on a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_set_srid]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_sharedpaths(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: lineal1, lineal2 - Returns a collection containing paths shared by the two input linestrings/multilinestrings.]]></comment>
         <definition language="c"><![CDATA[ST_SharedPaths]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shiftlongitude(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Shifts the longitude coordinates of a geometry between -180..180 and 0..360.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_longitude_shift]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shortestline(geography, geography, use_spheroid boolean DEFAULT true)" returnType="geography" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom1, geom2, use_spheroid = true - Returns the 2D shortest line between two geometries]]></comment>
         <definition language="c"><![CDATA[geography_shortestline]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" type="geography"/>
            <parameter mode="IN" name="use_spheroid" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shortestline(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom1, geom2 - Returns the 2D shortest line between two geometries]]></comment>
         <definition language="c"><![CDATA[LWGEOM_shortestline2d]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_shortestline(text, text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT public.ST_ShortestLine($1::public.geometry, $2::public.geometry);]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplify(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance - Returns a simplified version of a geometry, using the Douglas-Peucker algorithm.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_simplify2d]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplify(geometry, double precision, boolean)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance, preserveCollapsed - Returns a simplified version of a geometry, using the Douglas-Peucker algorithm.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_simplify2d]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplifypolygonhull(geom geometry, vertex_fraction double precision, is_outer boolean DEFAULT true)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: param_geom, vertex_fraction, is_outer = true - Computes a simplifed topology-preserving outer or inner hull of a polygonal geometry.]]></comment>
         <definition language="c"><![CDATA[ST_SimplifyPolygonHull]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="vertex_fraction" type="double precision"/>
            <parameter mode="IN" name="is_outer" type="boolean"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplifypreservetopology(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance - Returns a simplified and valid version of a geometry, using the Douglas-Peucker algorithm.]]></comment>
         <definition language="c"><![CDATA[topologypreservesimplify]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_simplifyvw(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, tolerance - Returns a simplified version of a geometry, using the Visvalingam-Whyatt algorithm]]></comment>
         <definition language="c"><![CDATA[LWGEOM_SetEffectiveArea]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snap(geom1 geometry, geom2 geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input, reference, tolerance - Snap segments and vertices of input geometry to vertices of a reference geometry.]]></comment>
         <definition language="c"><![CDATA[ST_Snap]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snaptogrid(geom1 geometry, geom2 geometry, double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, pointOrigin, sizeX, sizeY, sizeZ, sizeM - Snap all points of the input geometry to a regular grid.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_snaptogrid_pointoff]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snaptogrid(geometry, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, size - Snap all points of the input geometry to a regular grid.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_SnapToGrid($1, 0, 0, $2, $2)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snaptogrid(geometry, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, sizeX, sizeY - Snap all points of the input geometry to a regular grid.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_SnapToGrid($1, 0, 0, $2, $3)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_snaptogrid(geometry, double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, originX, originY, sizeX, sizeY - Snap all points of the input geometry to a regular grid.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_snaptogrid]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_split(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: input, blade - Returns a collection of geometries created by splitting a geometry by another geometry.]]></comment>
         <definition language="c"><![CDATA[ST_Split]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_square(size double precision, cell_i integer, cell_j integer, origin geometry DEFAULT '010100000000000000000000000000000000000000'::geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: size, cell_i, cell_j, origin - Returns a single square, using the provided edge size and cell coordinate within the square grid space.]]></comment>
         <definition language="c"><![CDATA[ST_Square]]></definition>
         <parameters>
            <parameter mode="IN" name="size" type="double precision"/>
            <parameter mode="IN" name="cell_i" type="integer"/>
            <parameter mode="IN" name="cell_j" type="integer"/>
            <parameter mode="IN" name="origin" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_squaregrid(size double precision, bounds geometry, OUT geom geometry, OUT i integer, OUT j integer)" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: size, bounds - Returns a set of grid squares and cell indices that completely cover the bounds of the geometry argument.]]></comment>
         <definition language="c"><![CDATA[ST_ShapeGrid]]></definition>
         <parameters>
            <parameter mode="IN" name="size" type="double precision"/>
            <parameter mode="IN" name="bounds" type="geometry"/>
            <parameter mode="OUT" name="geom" type="geometry"/>
            <parameter mode="OUT" name="i" type="integer"/>
            <parameter mode="OUT" name="j" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_srid(geog geography)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_get_srid]]></definition>
         <parameters>
            <parameter mode="IN" name="geog" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_srid(geom geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1 - Returns the spatial reference identifier for a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_get_srid]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_startpoint(geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns the first point of a LineString.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_startpoint_linestring]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_subdivide(geom geometry, maxvertices integer DEFAULT 256, gridsize double precision DEFAULT '-1.0'::numeric)" returnType="SETOF geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, max_vertices=256, gridSize = -1 - Computes a rectilinear subdivision of a geometry.]]></comment>
         <definition language="c"><![CDATA[ST_Subdivide]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="maxvertices" type="integer"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_summary(geography)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns a text summary of the contents of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_summary]]></definition>
         <parameters>
            <parameter mode="IN" type="geography"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_summary(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g - Returns a text summary of the contents of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_summary]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_swapordinates(geom geometry, ords cstring)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, ords - Returns a version of the given geometry with given ordinate values swapped.]]></comment>
         <definition language="c"><![CDATA[ST_SwapOrdinates]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="ords" type="cstring"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_symdifference(geom1 geometry, geom2 geometry, gridsize double precision DEFAULT '-1.0'::numeric)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, geomB, gridSize = -1 - Computes a geometry representing the portions of geometries A and B that do not intersect.]]></comment>
         <definition language="c"><![CDATA[ST_SymDifference]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="st_symmetricdifference(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[SELECT ST_SymDifference(geom1, geom2, -1.0);]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_tileenvelope(zoom integer, x integer, y integer, bounds geometry DEFAULT '0102000020110F00000200000093107C45F81B73C193107C45F81B73C193107C45F81B734193107C45F81B7341'::geometry, margin double precision DEFAULT 0.0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: tileZoom, tileX, tileY, bounds=SRID=3857;LINESTRING(-20037508.342789 -20037508.342789,20037508.342789 20037508.342789), margin=0.0 - Creates a rectangular Polygon in Web Mercator (SRID:3857) using the XYZ tile system.]]></comment>
         <definition language="c"><![CDATA[ST_TileEnvelope]]></definition>
         <parameters>
            <parameter mode="IN" name="zoom" type="integer"/>
            <parameter mode="IN" name="x" type="integer"/>
            <parameter mode="IN" name="y" type="integer"/>
            <parameter mode="IN" name="bounds" type="geometry"/>
            <parameter mode="IN" name="margin" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_touches(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[touches]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transform(geom geometry, from_proj text, to_proj text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, from_proj, to_proj - Return a new geometry with coordinates transformed to a different spatial reference system.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.postgis_transform_geometry($1, $2, $3, 0)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="from_proj" type="text"/>
            <parameter mode="IN" name="to_proj" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transform(geom geometry, from_proj text, to_srid integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, from_proj, to_srid - Return a new geometry with coordinates transformed to a different spatial reference system.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.postgis_transform_geometry($1, $2, proj4text, $3)
	FROM spatial_ref_sys WHERE srid=$3;]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="from_proj" type="text"/>
            <parameter mode="IN" name="to_srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transform(geom geometry, to_proj text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, to_proj - Return a new geometry with coordinates transformed to a different spatial reference system.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.postgis_transform_geometry($1, proj4text, $2, 0)
	FROM spatial_ref_sys WHERE srid=public.ST_SRID($1);]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="to_proj" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transform(geometry, integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, srid - Return a new geometry with coordinates transformed to a different spatial reference system.]]></comment>
         <definition language="c"><![CDATA[transform]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transformpipeline(geom geometry, pipeline text, to_srid integer DEFAULT 0)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, pipeline, to_srid - Return a new geometry with coordinates transformed to a different spatial reference system using a defined coordinate transformation pipeline.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.postgis_transform_pipeline_geometry($1, $2, TRUE, $3)]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="pipeline" type="text"/>
            <parameter mode="IN" name="to_srid" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_translate(geometry, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, deltax, deltay - Translates a geometry by given offsets.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Translate($1, $2, $3, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_translate(geometry, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, deltax, deltay, deltaz - Translates a geometry by given offsets.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1, 1, 0, 0, 0, 1, 0, 0, 0, 1, $2, $3, $4)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_transscale(geometry, double precision, double precision, double precision, double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA, deltaX, deltaY, XFactor, YFactor - Translates and scales a geometry by given offsets and factors.]]></comment>
         <definition language="sql"><![CDATA[SELECT public.ST_Affine($1,  $4, 0, 0,  0, $5, 0,
		0, 0, 1,  $2 * $4, $3 * $5, 0)]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
            <parameter mode="IN" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_triangulatepolygon(g1 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom - Computes the constrained Delaunay triangulation of polygons]]></comment>
         <definition language="c"><![CDATA[ST_TriangulatePolygon]]></definition>
         <parameters>
            <parameter mode="IN" name="g1" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_unaryunion(geometry, gridsize double precision DEFAULT '-1.0'::numeric)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, gridSize = -1 - Computes the union of the components of a single geometry.]]></comment>
         <definition language="c"><![CDATA[ST_UnaryUnion]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union(geom1 geometry, geom2 geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2 - Computes a geometry representing the point-set union of the input geometries.]]></comment>
         <definition language="c"><![CDATA[ST_Union]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union(geom1 geometry, geom2 geometry, gridsize double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1, g2, gridSize - Computes a geometry representing the point-set union of the input geometries.]]></comment>
         <definition language="c"><![CDATA[ST_Union]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union(geometry)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g1field - Computes a geometry representing the point-set union of the input geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union(geometry, gridsize double precision)" returnType="geometry" securityType="INVOKER" type="AGGREGATE">
         <comment><![CDATA[args: g1field, gridSize - Computes a geometry representing the point-set union of the input geometries.]]></comment>
         <definition language="internal"><![CDATA[aggregate_dummy]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
            <parameter mode="IN" name="gridsize" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_union(geometry[])" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: g1_array - Computes a geometry representing the point-set union of the input geometries.]]></comment>
         <definition language="c"><![CDATA[pgis_union_geometry_array]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_voronoilines(g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance = 0.0, extend_to = NULL - Returns the boundaries of the Voronoi diagram of the vertices of a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public._ST_Voronoi(g1, extend_to, tolerance, false)]]></definition>
         <parameters>
            <parameter mode="IN" name="g1" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="extend_to" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_voronoipolygons(g1 geometry, tolerance double precision DEFAULT 0.0, extend_to geometry DEFAULT NULL::geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, tolerance = 0.0, extend_to = NULL - Returns the cells of the Voronoi diagram of the vertices of a geometry.]]></comment>
         <definition language="sql"><![CDATA[SELECT public._ST_Voronoi(g1, extend_to, tolerance, true)]]></definition>
         <parameters>
            <parameter mode="IN" name="g1" type="geometry"/>
            <parameter mode="IN" name="tolerance" type="double precision"/>
            <parameter mode="IN" name="extend_to" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_within(geom1 geometry, geom2 geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[within]]></definition>
         <parameters>
            <parameter mode="IN" name="geom1" type="geometry"/>
            <parameter mode="IN" name="geom2" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wkbtosql(wkb bytea)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_WKB]]></definition>
         <parameters>
            <parameter mode="IN" name="wkb" type="bytea"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wkttosql(text)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_from_text]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_wrapx(geom geometry, wrap double precision, move double precision)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geom, wrap, move - Wrap a geometry around an X value.]]></comment>
         <definition language="c"><![CDATA[ST_WrapX]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
            <parameter mode="IN" name="wrap" type="double precision"/>
            <parameter mode="IN" name="move" type="double precision"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_x(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the X coordinate of a Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_x_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_xmax(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the X maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_xmax]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_xmin(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the X minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_xmin]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_y(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the Y coordinate of a Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_y_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ymax(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Y maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_ymax]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_ymin(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Y minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_ymin]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_z(geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: a_point - Returns the Z coordinate of a Point.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_z_point]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmax(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Z maxima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_zmax]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmflag(geometry)" returnType="smallint" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: geomA - Returns a code indicating the ZM coordinate dimension of a geometry.]]></comment>
         <definition language="c"><![CDATA[LWGEOM_zmflag]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="st_zmin(box3d)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: aGeomorBox2DorBox3D - Returns the Z minima of a 2D or 3D bounding box or a geometry.]]></comment>
         <definition language="c"><![CDATA[BOX3D_zmin]]></definition>
         <parameters>
            <parameter mode="IN" type="box3d"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="text(geometry)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[LWGEOM_to_text]]></definition>
         <parameters>
            <parameter mode="IN" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="text_soundex(text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[soundex]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unlockrows(text)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: auth_token - Removes all locks held by an authorization token.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret int;
BEGIN

	IF NOT LongTransactionsEnabled() THEN
		RAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';
	END IF;

	EXECUTE 'DELETE FROM authorization_table where authid = ' ||
		quote_literal($1);

	GET DIAGNOSTICS ret = ROW_COUNT;

	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="update_complaint_using_webeoc_update(_complaint_identifier character varying, update_complaint_data jsonb)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
	current_complaint_record PUBLIC.complaint;
    -- Variables from webeoc that may be used to update a record in the COMPLAINT table
    -- used to determine if a webeoc update is actually an update.  WebEOC's API will unfortunately default to
    -- the original value of a field if another field is updated.  So, we ignore these as part of updates.  This
    -- means that WebEOC will not be able to update a value to the original value, but that's something the project
    -- team has decided to risk.
    original_complaint_record JSONB;
    _update_caller_name VARCHAR(120);
    _update_caller_phone_1 VARCHAR(15);
    _update_caller_phone_2 VARCHAR(15);
    _update_caller_phone_3 VARCHAR(15);
    _update_caller_email VARCHAR(120);
    _update_caller_address VARCHAR(120);
    _update_reported_by_code VARCHAR(10);
    _update_webeoc_reported_by_code VARCHAR(200);
    _update_reported_by_other_text VARCHAR(120);
    _update_webeoc_species VARCHAR(200); -- species code from WebEOC
    _update_species_code VARCHAR(10); -- our species code, based on the code from WebEOC
    _parent_report_type VARCHAR(10); -- used to differentiate between HWCR and ERS complaints.  ignore anything else
    _update_violation_code            VARCHAR(10);
    _create_userid VARCHAR(200);
    _update_userid VARCHAR(200);
    _create_utc_timestamp TIMESTAMP := (NOW() AT TIME ZONE 'UTC');
    _update_utc_timestamp TIMESTAMP := (NOW() AT TIME ZONE 'UTC');
    
    -- Original complaint values, used to compare against incoming changes
    _original_caller_name VARCHAR(120);
    _original_caller_phone_1 VARCHAR(15);
    _original_caller_phone_2 VARCHAR(15);
    _original_caller_phone_3 VARCHAR(15);
    _original_caller_email VARCHAR(120);
    _original_caller_address VARCHAR(120);
    _original_reported_by_code VARCHAR(10);
    _original_reported_by_other_text VARCHAR(120);
    _original_species_code VARCHAR(10);
    _original_violation_type_code VARCHAR(10);
   
   _current_species_code VARCHAR(10);
   _current_violation_type_code VARCHAR(10);
   
    -- used to indicate if the update causes an edit to the complaint record
    update_edit_ind boolean = false;
   
    USERNAME_TXT CONSTANT varchar(8) = 'username';
   
BEGIN
    -- These fields are retrieved to potentially update an existing complaint record
    _update_caller_name := update_complaint_data ->> 'update_caller_name';
    _update_caller_phone_1 := format_phone_number(update_complaint_data ->> 'update_primary_phone');
    _update_caller_phone_2 := format_phone_number(update_complaint_data ->> 'update_alt_phone');
    _update_caller_phone_3 := format_phone_number(update_complaint_data ->> 'update_alt_phone_2');
    _update_caller_email := update_complaint_data ->> 'update_caller_email';
    _update_caller_address := update_complaint_data ->> 'update_caller_address';
    _update_webeoc_reported_by_code := update_complaint_data ->> 'update_reffered_by_lst';
    _update_reported_by_other_text := update_complaint_data ->> 'update_reffered_by_txt';
    _update_webeoc_species := update_complaint_data ->> 'update_species';
    _parent_report_type := update_complaint_data ->> 'parent_report_type';
    _create_userid := substring(update_complaint_data ->> USERNAME_TXT from 1 for 32);
    _update_userid := substring(update_complaint_data ->> USERNAME_TXT from 1 for 32);


    -- Get the codes from our application (inserting if necessary) for the codes retrieved from WebEOC
    SELECT *
    INTO   _update_reported_by_code
    FROM   PUBLIC.insert_and_return_code(_update_webeoc_reported_by_code, 'reprtdbycd');

   
    -- Get the current state of the complaint
    SELECT *
    INTO   current_complaint_record
    FROM   PUBLIC.complaint
    WHERE  complaint_identifier = _complaint_identifier;
   
    -- Get the original record via the history table
    select ch.data_after_executed_operation
    into original_complaint_record
    from PUBLIC.complaint_h ch 
    where ch.target_row_id = _complaint_identifier
    and ch.operation_type = 'I';
   
   -- Parse the variables out of the original complaint history record
    _original_caller_name := original_complaint_record ->> 'caller_name';
    _original_caller_phone_1 := format_phone_number(original_complaint_record ->> 'caller_phone_1');
    _original_caller_phone_2 := format_phone_number(original_complaint_record ->> 'caller_phone_2');
    _original_caller_phone_3 := format_phone_number(original_complaint_record ->> 'caller_phone_3');
    _original_caller_email := original_complaint_record ->> 'caller_email';
    _original_caller_address := original_complaint_record ->> 'caller_address';
    -- need to get from hrc/allegation history table
    _original_reported_by_code := original_complaint_record ->> 'referred_by_agency_code';
    _original_reported_by_other_text := original_complaint_record ->> 'referred_by_agency_other_text';
   
   -- update the complaint data, if the incoming webeoc contains applicable updates
   if ((COALESCE(_update_caller_name, '') <> COALESCE(_original_caller_name, '')) and 
    (COALESCE(_update_caller_name, '') <> COALESCE(current_complaint_record.caller_name, ''))) then
	    UPDATE complaint
	    SET caller_name = _update_caller_name
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _update_caller_phone_1 := format_phone_number(_update_caller_phone_1);
  if ((COALESCE(_update_caller_phone_1, '') <> COALESCE(_original_caller_phone_1, '')) and 
    (COALESCE(_update_caller_phone_1, '') <> COALESCE(current_complaint_record.caller_phone_1, ''))) then
        
	    UPDATE complaint
	    SET caller_phone_1 = _update_caller_phone_1
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _update_caller_phone_2 := format_phone_number(_update_caller_phone_2);
  if ((COALESCE(_update_caller_phone_2, '') <> COALESCE(_original_caller_phone_2, '')) and 
    (COALESCE(_update_caller_phone_2, '') <> COALESCE(current_complaint_record.caller_phone_2, ''))) then
    	
	    UPDATE complaint
	    SET caller_phone_2 = _update_caller_phone_2
	    WHERE complaint_identifier = _complaint_identifier;
	
	    update_edit_ind = true;
  end if;
  
  _update_caller_phone_3 := format_phone_number(_update_caller_phone_3);
  if ((COALESCE(_update_caller_phone_3, '') <> COALESCE(_original_caller_phone_3, '')) and 
    (COALESCE(_update_caller_phone_3, '') <> COALESCE(current_complaint_record.caller_phone_3, ''))) then
    	
	    UPDATE complaint
	    SET caller_phone_3 = _update_caller_phone_3
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
  
  if ((COALESCE(_update_caller_email, '') <> COALESCE(_original_caller_email, '')) and 
    (COALESCE(_update_caller_email, '') <> COALESCE(current_complaint_record.caller_email, ''))) then 
		UPDATE complaint
		SET caller_email = _update_caller_email
		WHERE complaint_identifier = _complaint_identifier;
		update_edit_ind = true;
  end if;
  
  if ((COALESCE(_update_caller_address, '') <> COALESCE(_original_caller_address, '')) and 
    (COALESCE(_update_caller_address, '') <> COALESCE(current_complaint_record.caller_address, ''))) then 
	    UPDATE complaint
	    SET caller_address = _update_caller_address
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
  
  if ((COALESCE(_update_reported_by_code, '') <> COALESCE(_original_reported_by_code, '')) and 
    (COALESCE(_update_reported_by_code, '') <> COALESCE(current_complaint_record.reported_by_code, ''))) then 
	    UPDATE complaint
	    SET reported_by_code = _update_reported_by_code
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
   
  if ((COALESCE(_update_reported_by_other_text, '') <> COALESCE(_original_reported_by_other_text, '')) and 
    (COALESCE(_update_reported_by_other_text, '') <> COALESCE(current_complaint_record.reported_by_other_text, ''))) then 
	    UPDATE complaint
	    SET reported_by_other_text = _update_reported_by_other_text
	    WHERE complaint_identifier = _complaint_identifier;
	    update_edit_ind = true;
  end if;
   
  -- the update caused an edit, set the audit fields
  if (update_edit_ind) then
	  update complaint
	  set update_user_id = _update_userid, update_utc_timestamp = _update_utc_timestamp, comp_last_upd_utc_timestamp = _update_utc_timestamp
	  where complaint_identifier = _complaint_identifier;
  end if;
  
  if (_parent_report_type = 'HWCR') then
    -- get the code based on the update from WebEOC
    SELECT *
    INTO   _update_species_code
    FROM   PUBLIC.insert_and_return_code(_update_webeoc_species, 'speciescd');
   
    -- get the current species code
   	SELECT hc.species_code 
   	INTO _current_species_code
	FROM hwcr_complaint hc 
	WHERE hc.complaint_identifier = _complaint_identifier;

    select hch.data_after_executed_operation ->> 'species_code'
    into _original_species_code
    from complaint c inner join hwcr_complaint hc on c.complaint_identifier = hc.complaint_identifier
    inner join hwcr_complaint_h hch on hc.hwcr_complaint_guid = hch.target_row_id
    where c.complaint_identifier = _complaint_identifier
    and hch.operation_type = 'I';

    if ((_update_species_code <> _original_species_code) and (_update_species_code <> _current_species_code)) then 
    	update hwcr_complaint
    	set species_code = _update_species_code
    	where complaint_identifier = _complaint_identifier;
    end if;

  end if;
 
  if (_parent_report_type = 'ERS') then
	 SELECT *
	 FROM   PUBLIC.insert_and_return_code( update_complaint_data->>'update_violation_type', 'violatncd' )
	 INTO   _update_violation_code;
	 
     select ac.violation_code
     into _current_violation_type_code
     from allegation_complaint ac
     where ac.complaint_identifier = _complaint_identifier;

     select ach.data_after_executed_operation ->> 'violation_code'
     into _original_violation_type_code
     from complaint c inner join allegation_complaint ac on c.complaint_identifier = ac.complaint_identifier 
     inner join allegation_complaint_h ach on ac.allegation_complaint_guid = ach.target_row_id
     where c.complaint_identifier  = _complaint_identifier
     and ach.operation_type = 'I';
    
     if ((_update_violation_code <> _original_violation_type_code) and (_update_violation_code <> _current_violation_type_code)) then 
	    if _update_violation_code = 'WASTE' OR _update_violation_code = 'PESTICDE' then
        UPDATE PUBLIC.complaint
        SET    owned_by_agency_code = 'EPO'
        WHERE  complaint_identifier = _complaint_identifier;
      else
        UPDATE PUBLIC.complaint
        SET    owned_by_agency_code = 'COS'
        WHERE  complaint_identifier = _complaint_identifier;
      end if;

    	update allegation_complaint
    	set violation_code  = _update_violation_code
    	where complaint_identifier = _complaint_identifier;
     end if;		    
  end if;

  -- We always want to update the complaint last updated field to indicate an update was received.
  update complaint
	set comp_last_upd_utc_timestamp = _update_utc_timestamp
	where complaint_identifier = _complaint_identifier;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="_complaint_identifier" type="character varying"/>
            <parameter mode="IN" name="update_complaint_data" type="jsonb"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: catalog_name, schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	myrec RECORD;
	okay boolean;
	cname varchar;
	real_schema name;
	unknown_srid integer;
	new_srid integer := new_srid_in;

BEGIN

	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <> true ) THEN
			RAISE EXCEPTION 'Invalid schema name';
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT INTO real_schema current_schema()::text;
	END IF;

	-- Ensure that column_name is in geometry_columns
	okay = false;
	FOR myrec IN SELECT type, coord_dimension FROM public.geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (NOT okay) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Ensure that new_srid is valid
	IF ( new_srid > 0 ) THEN
		IF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN
			RAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;
			RETURN false;
		END IF;
	ELSE
		unknown_srid := public.ST_SRID('POINT EMPTY'::public.geometry);
		IF ( new_srid != unknown_srid ) THEN
			new_srid := unknown_srid;
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;

	IF postgis_constraint_srid(real_schema, table_name, column_name) IS NOT NULL THEN
	-- srid was enforced with constraints before, keep it that way.
		-- Make up constraint name
		cname = 'enforce_srid_'  || column_name;

		-- Drop enforce_srid constraint
		EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
			'.' || quote_ident(table_name) ||
			' DROP constraint ' || quote_ident(cname);

		-- Update geometries SRID
		EXECUTE 'UPDATE ' || quote_ident(real_schema) ||
			'.' || quote_ident(table_name) ||
			' SET ' || quote_ident(column_name) ||
			' = public.ST_SetSRID(' || quote_ident(column_name) ||
			', ' || new_srid::text || ')';

		-- Reset enforce_srid constraint
		EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||
			'.' || quote_ident(table_name) ||
			' ADD constraint ' || quote_ident(cname) ||
			' CHECK (st_srid(' || quote_ident(column_name) ||
			') = ' || new_srid::text || ')';
	ELSE
		-- We will use typmod to enforce if no srid constraints
		-- We are using postgis_type_name to lookup the new name
		-- (in case Paul changes his mind and flips geometry_columns to return old upper case name)
		EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) ||
		' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || public.postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING public.ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;
	END IF;

	RETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;

END;]]></definition>
         <parameters>
            <parameter mode="IN" name="catalogn_name" type="character varying"/>
            <parameter mode="IN" name="schema_name" type="character varying"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
            <parameter mode="IN" name="column_name" type="character varying"/>
            <parameter mode="IN" name="new_srid_in" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updategeometrysrid(character varying, character varying, character varying, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret  text;
BEGIN
	SELECT public.UpdateGeometrySRID('',$1,$2,$3,$4) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="updategeometrysrid(character varying, character varying, integer)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[args: table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.]]></comment>
         <definition language="plpgsql"><![CDATA[DECLARE
	ret  text;
BEGIN
	SELECT public.UpdateGeometrySRID('','',$1,$2,$3) into ret;
	RETURN ret;
END;]]></definition>
         <parameters>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="character varying"/>
            <parameter mode="IN" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v1]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v1mc()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v1mc]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v3(namespace uuid, name text)" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v3]]></definition>
         <parameters>
            <parameter mode="IN" name="namespace" type="uuid"/>
            <parameter mode="IN" name="name" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="uuid_generate_v4()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v4]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_generate_v5(namespace uuid, name text)" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_generate_v5]]></definition>
         <parameters>
            <parameter mode="IN" name="namespace" type="uuid"/>
            <parameter mode="IN" name="name" type="text"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_nil()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_nil]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_dns()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_dns]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_oid()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_oid]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_url()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_url]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uuid_ns_x500()" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="c"><![CDATA[uuid_ns_x500]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="validate_coordinate_field(coordinate_field text)" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[DECLARE
    formatted_coordinate_field TEXT;
BEGIN
    -- Confirm the coordinate_field is a valid value 
    formatted_coordinate_field := regexp_substr(coordinate_field, '^[-+]?([0-9]{1,2}|1[0-7][0-9]|180)(\.[0-9]{1,10})');
    IF (formatted_coordinate_field IS NULL or (length(formatted_coordinate_field) = 0)) then
		return NULL;
	-- Valid match so return the formatted_coordinate_field
	else return formatted_coordinate_field;
    END IF;
END;]]></definition>
         <parameters>
            <parameter mode="IN" name="coordinate_field" type="text"/>
         </parameters>
      </routine>
   </routines>
</database>
